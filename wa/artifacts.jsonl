{"prompt":{"fileName":"assist.ts","endpoints":[{"endpointName":"getPrompt","endpointArgs":"queryArg: {\n      id: '' as string,\n      prompt: '' as string\n    }","endpointPath":"url: 'assist/prompt?id=:id&prompt=:prompt'","endpointResult":"resultType: { promptResult: [] as string[] }"}],"types":[]},"result":"assistApi = {\n  getPrompt: {\n    kind: EndpointType.QUERY,\n    url: 'assist/prompt?id=:id&prompt=:prompt',\n    method: 'GET',\n    opts: { cache: null } as ApiOptions,\n    queryArg: {\n      id: '' as string,\n      prompt: '' as string\n    },\n    resultType: { promptResult: [] as string[] }\n  },\n} as const"}
{"prompt":{"fileName":"booking_transcript.ts","endpoints":[{"endpointName":"postBookingTranscript","endpointArgs":"queryArg: { bookingTranscripts: [] as IBookingTranscript[] }","endpointPath":"url: 'booking_transcripts'","endpointResult":"resultType: [] as IBookingTranscript[]"},{"endpointName":"putBookingTranscript","endpointArgs":"queryArg: {} as IBookingTranscript","endpointPath":"url: 'booking_transcripts'","endpointResult":"resultType: {} as IBookingTranscript"},{"endpointName":"getBookingTranscripts","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'booking_transcripts'","endpointResult":"resultType: [] as IBookingTranscript[]"},{"endpointName":"getBookingTranscriptById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'booking_transcripts/:id'","endpointResult":"resultType: {} as IBookingTranscript"},{"endpointName":"deleteBookingTranscript","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'booking_transcripts/:id'","endpointResult":"resultType: {} as IBookingTranscript"},{"endpointName":"disableBookingTranscript","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'booking_transcripts/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"bookingTranscriptApi = {\n  postBookingTranscript: {\n    kind: EndpointType.MUTATION,\n    url: 'booking_transcripts',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { bookingTranscripts: [] as IBookingTranscript[] },\n    resultType: [] as IBookingTranscript[]\n  },\n  putBookingTranscript: {\n    kind: EndpointType.MUTATION,\n    url: 'booking_transcripts',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as IBookingTranscript,\n    resultType: {} as IBookingTranscript\n  },\n  getBookingTranscripts: {\n    kind: EndpointType.QUERY,\n    url: 'booking_transcripts',\n    method: 'GET',\n    opts: { cache: 180 } as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IBookingTranscript[]\n  },\n  getBookingTranscriptById: {\n    kind: EndpointType.QUERY,\n    url: 'booking_transcripts/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IBookingTranscript\n  },\n  deleteBookingTranscript: {\n    kind: EndpointType.MUTATION,\n    url: 'booking_transcripts/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IBookingTranscript\n  },\n  disableBookingTranscript: {\n    kind: EndpointType.MUTATION,\n    url: 'booking_transcripts/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"booking.ts","endpoints":[{"endpointName":"postBooking","endpointArgs":"queryArg: { bookings: [] as IBooking[] }","endpointPath":"url: 'bookings'","endpointResult":"resultType: [] as IBooking[]"},{"endpointName":"putBooking","endpointArgs":"queryArg: {} as IBooking","endpointPath":"url: 'bookings'","endpointResult":"resultType: {} as IBooking"},{"endpointName":"getBookings","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'bookings'","endpointResult":"resultType: [] as IBooking[]"},{"endpointName":"getBookingById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'bookings/:id'","endpointResult":"resultType: {} as IBooking"},{"endpointName":"deleteBooking","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'bookings/:id'","endpointResult":"resultType: { id : '' as string }"},{"endpointName":"disableBooking","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'bookings/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"bookingApi = {\n  postBooking: {\n    kind: EndpointType.MUTATION,\n    url: 'bookings',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { bookings: [] as IBooking[] },\n    resultType: [] as IBooking[]\n  },\n  putBooking: {\n    kind: EndpointType.MUTATION,\n    url: 'bookings',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as IBooking,\n    resultType: {} as IBooking\n  },\n  getBookings: {\n    kind: EndpointType.QUERY,\n    url: 'bookings',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IBooking[]\n  },\n  getBookingById: {\n    kind: EndpointType.QUERY,\n    url: 'bookings/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IBooking\n  },\n  deleteBooking: {\n    kind: EndpointType.MUTATION,\n    url: 'bookings/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id : '' as string }\n  },\n  disableBooking: {\n    kind: EndpointType.MUTATION,\n    url: 'bookings/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"contact.ts","endpoints":[{"endpointName":"postContact","endpointArgs":"queryArg: { name: '' as string, email: '' as string, phone: '' as string }","endpointPath":"url: 'contacts'","endpointResult":"resultType: {} as IContact"},{"endpointName":"putContact","endpointArgs":"queryArg: { id: '' as string, name: '' as string, email: '' as string, phone: '' as string }","endpointPath":"url: 'contacts'","endpointResult":"resultType: {} as IContact"},{"endpointName":"getContacts","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'contacts'","endpointResult":"resultType: [] as IContact[]"},{"endpointName":"getContactById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'contacts/:id'","endpointResult":"resultType: {} as IContact"},{"endpointName":"deleteContact","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'contacts/:id'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"disableContact","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'contacts/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"contactApi = {\n  postContact: {\n    kind: EndpointType.MUTATION,\n    url: 'contacts',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { name: '' as string, email: '' as string, phone: '' as string },\n    resultType: {} as IContact\n  },\n  putContact: {\n    kind: EndpointType.MUTATION,\n    url: 'contacts',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, name: '' as string, email: '' as string, phone: '' as string },\n    resultType: {} as IContact\n  },\n  getContacts: {\n    kind: EndpointType.QUERY,\n    url: 'contacts',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IContact[]\n  },\n  getContactById: {\n    kind: EndpointType.QUERY,\n    url: 'contacts/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IContact\n  },\n  deleteContact: {\n    kind: EndpointType.MUTATION,\n    url: 'contacts/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  },\n  disableContact: {\n    kind: EndpointType.MUTATION,\n    url: 'contacts/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"file.ts","endpoints":[{"endpointName":"postFile","endpointArgs":"queryArg: { name: '' as string, fileTypeId: '' as string, location: '' as string }","endpointPath":"url: 'files'","endpointResult":"resultType: { id: '' as string, newUuid: '' as string }"},{"endpointName":"putFile","endpointArgs":"queryArg: { id: '' as string, name: '' as string, fileTypeId: '' as string, location: '' as string }","endpointPath":"url: 'files'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"getFiles","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'files'","endpointResult":"resultType: [] as IFile[]"},{"endpointName":"getFileById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'files/:id'","endpointResult":"resultType: {} as IFile"},{"endpointName":"deleteFile","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'files/:id'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"disableFile","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'files/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":["export interface IPreviewFile extends File {\n  preview?: string;\n}"]},"result":"fileApi = {\n  postFile: {\n    kind: EndpointType.MUTATION,\n    url: 'files',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { name: '' as string, fileTypeId: '' as string, location: '' as string },\n    resultType: { id: '' as string, newUuid: '' as string }\n  },\n  putFile: {\n    kind: EndpointType.MUTATION,\n    url: 'files',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, name: '' as string, fileTypeId: '' as string, location: '' as string },\n    resultType: { id: '' as string }\n  },\n  getFiles: {\n    kind: EndpointType.QUERY,\n    url: 'files',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IFile[]\n  },\n  getFileById: {\n    kind: EndpointType.QUERY,\n    url: 'files/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IFile\n  },\n  deleteFile: {\n    kind: EndpointType.MUTATION,\n    url: 'files/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  },\n  disableFile: {\n    kind: EndpointType.MUTATION,\n    url: 'files/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"form.ts","endpoints":[{"endpointName":"postForm","endpointArgs":"queryArg: {} as IForm","endpointPath":"url: 'forms'","endpointResult":"resultType: {} as IForm"},{"endpointName":"postFormVersion","endpointArgs":"queryArg: { version: {} as IFormVersion }","endpointPath":"url: 'forms/:formId/versions'","endpointResult":"resultType: {} as IFormVersion"},{"endpointName":"putForm","endpointArgs":"queryArg: { id: '' as string, name: '' as string }","endpointPath":"url: 'forms'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"getForms","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'forms'","endpointResult":"resultType: [] as IForm[]"},{"endpointName":"getFormById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'forms/:id'","endpointResult":"resultType: {} as IForm"},{"endpointName":"deleteForm","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'forms/:id'","endpointResult":"resultType: {} as IForm"},{"endpointName":"disableForm","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'forms/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"formApi = {\n  postForm: {\n    kind: EndpointType.MUTATION,\n    url: 'forms',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {} as IForm,\n    resultType: {} as IForm\n  },\n  postFormVersion: {\n    kind: EndpointType.MUTATION,\n    url: 'forms/:formId/versions',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { version: {} as IFormVersion },\n    resultType: {} as IFormVersion\n  },\n  putForm: {\n    kind: EndpointType.MUTATION,\n    url: 'forms',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, name: '' as string },\n    resultType: { id: '' as string }\n  },\n  getForms: {\n    kind: EndpointType.QUERY,\n    url: 'forms',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IForm[]\n  },\n  getFormById: {\n    kind: EndpointType.QUERY,\n    url: 'forms/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IForm\n  },\n  deleteForm: {\n    kind: EndpointType.MUTATION,\n    url: 'forms/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IForm\n  },\n  disableForm: {\n    kind: EndpointType.MUTATION,\n    url: 'forms/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"group_feedback.ts","endpoints":[{"endpointName":"postGroupFeedback","endpointArgs":"queryArg: { message: '' as string, groupName: '' as string }","endpointPath":"url: 'feedback'","endpointResult":"resultType: { success: true as boolean }"},{"endpointName":"getGroupFeedback","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'feedback/:groupName'","endpointResult":"resultType: [] as IFeedback[]"}],"types":[]},"result":"groupFeedbackApi = {\n  postGroupFeedback: {\n    kind: EndpointType.MUTATION,\n    url: 'feedback',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { message: '' as string, groupName: '' as string },\n    resultType: { success: true as boolean }\n  },\n  getGroupFeedback: {\n    kind: EndpointType.QUERY,\n    url: 'feedback/:groupName',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: [] as IFeedback[]\n  },\n} as const"}
{"prompt":{"fileName":"group_form.ts","endpoints":[{"endpointName":"postGroupForm","endpointArgs":"queryArg: {} as IGroupForm","endpointPath":"url: 'group/:groupName/forms'","endpointResult":"resultType: [] as IGroupForm[]"},{"endpointName":"postGroupFormVersion","endpointArgs":"queryArg: {} as IGroupForm","endpointPath":"url: 'group/:groupName/forms/:id'","endpointResult":"resultType: [] as IGroupForm[]"},{"endpointName":"putGroupForm","endpointArgs":"queryArg: {} as IGroupForm","endpointPath":"url: 'group/:groupName/forms'","endpointResult":"resultType: {} as IGroupForm"},{"endpointName":"getGroupForms","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/forms'","endpointResult":"resultType: [] as IGroupForm[]"},{"endpointName":"getGroupFormById","endpointArgs":"queryArg: { groupName: '' as string, formId: '' as string }","endpointPath":"url: 'group/:groupName/forms/:formId'","endpointResult":"resultType: {} as IGroupForm"},{"endpointName":"deleteGroupForm","endpointArgs":"queryArg: { groupName: '' as string, ids: '' as string }","endpointPath":"url: 'group/:groupName/forms/:ids'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"groupFormApi = {\n  postGroupForm: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/forms',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {} as IGroupForm,\n    resultType: [] as IGroupForm[]\n  },\n  postGroupFormVersion: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/forms/:id',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {} as IGroupForm,\n    resultType: [] as IGroupForm[]\n  },\n  putGroupForm: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/forms',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as IGroupForm,\n    resultType: {} as IGroupForm\n  },\n  getGroupForms: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/forms',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: [] as IGroupForm[]\n  },\n  getGroupFormById: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/forms/:formId',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, formId: '' as string },\n    resultType: {} as IGroupForm\n  },\n  deleteGroupForm: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/forms/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: '' as string },\n    resultType: [] as { id: string }[]\n  },\n} as const"}
{"prompt":{"fileName":"group_role.ts","endpoints":[{"endpointName":"postGroupRole","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/roles'","endpointResult":"resultType: { success: true as boolean }"},{"endpointName":"putGroupRole","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/roles'","endpointResult":"resultType: { success: true as boolean }"},{"endpointName":"getGroupRoles","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/roles'","endpointResult":"resultType: [] as IGroupRole[]"},{"endpointName":"deleteGroupRole","endpointArgs":"queryArg: { groupName: '' as string, ids: '' as string }","endpointPath":"url: 'group/:groupName/roles/:ids'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"groupRoleApi = {\n  postGroupRole: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/roles',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: { success: true as boolean }\n  },\n  putGroupRole: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/roles',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: { success: true as boolean }\n  },\n  getGroupRoles: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/roles',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: [] as IGroupRole[]\n  },\n  deleteGroupRole: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/roles/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: '' as string },\n    resultType: [] as { id: string }[]\n  },\n} as const"}
{"prompt":{"fileName":"group_schedule.ts","endpoints":[{"endpointName":"postGroupSchedule","endpointArgs":"queryArg: {} as IGroupSchedule","endpointPath":"url: 'group/:groupName/schedules'","endpointResult":"resultType: {} as IGroupSchedule"},{"endpointName":"putGroupSchedule","endpointArgs":"queryArg: {} as IGroupSchedule","endpointPath":"url: 'group/:groupName/schedules'","endpointResult":"resultType: {} as IGroupSchedule"},{"endpointName":"getGroupSchedules","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/schedules'","endpointResult":"resultType: [] as IGroupSchedule[]"},{"endpointName":"getGroupScheduleMasterById","endpointArgs":"queryArg: { groupName: '' as string, scheduleId: '' as string }","endpointPath":"url: 'group/:groupName/schedules/master/:scheduleId'","endpointResult":"resultType: {} as ISchedule"},{"endpointName":"getGroupScheduleByDate","endpointArgs":"queryArg: { groupName: '' as string, scheduleId: '' as string, date: '' as string, timezone: '' as string }","endpointPath":"url: 'group/:groupName/schedules/:scheduleId/:date'","endpointResult":"resultType: [] as IGroupScheduleDateSlots[]"},{"endpointName":"deleteGroupSchedule","endpointArgs":"queryArg: { groupName: '' as string, ids: '' as string }","endpointPath":"url: 'group/:groupName/schedules/:ids'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"groupSchedulesApi = {\n  postGroupSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/schedules',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {} as IGroupSchedule,\n    resultType: {} as IGroupSchedule\n  },\n  putGroupSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/schedules',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as IGroupSchedule,\n    resultType: {} as IGroupSchedule\n  },\n  getGroupSchedules: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/schedules',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: [] as IGroupSchedule[]\n  },\n  getGroupScheduleMasterById: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/schedules/master/:scheduleId',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, scheduleId: '' as string },\n    resultType: {} as ISchedule\n  },\n  getGroupScheduleByDate: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/schedules/:scheduleId/:date',\n    method: 'GET',\n    opts: { cache: 'skip' } as ApiOptions,\n    queryArg: { groupName: '' as string, scheduleId: '' as string, date: '' as string, timezone: '' as string },\n    resultType: [] as IGroupScheduleDateSlots[]\n  },\n  deleteGroupSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/schedules/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: '' as string },\n    resultType: [] as { id: string }[]\n  },\n} as const"}
{"prompt":{"fileName":"group_service_addon.ts","endpoints":[{"endpointName":"postGroupServiceAddon","endpointArgs":"queryArg: {\n      groupName: '' as string,\n      serviceAddonId: '' as string\n    }","endpointPath":"url: 'group/:groupName/service_addons/:serviceAddonId'","endpointResult":"resultType: [] as IGroupServiceAddon[]"},{"endpointName":"getGroupServiceAddons","endpointArgs":"queryArg: {\n      groupName: '' as string\n    }","endpointPath":"url: 'group/:groupName/service_addons'","endpointResult":"resultType: [] as IGroupServiceAddon[]"},{"endpointName":"deleteGroupServiceAddon","endpointArgs":"queryArg: {\n      groupName: '' as string,\n      serviceAddonId: '' as string\n    }","endpointPath":"url: 'group/:groupName/service_addons/:serviceAddonId'","endpointResult":"resultType: [{ id: '' as string }]"}],"types":[]},"result":"groupServiceAddonApi = {\n  postGroupServiceAddon: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/service_addons/:serviceAddonId',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {\n      groupName: '' as string,\n      serviceAddonId: '' as string\n    },\n    resultType: [] as IGroupServiceAddon[]\n  },\n  getGroupServiceAddons: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/service_addons',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {\n      groupName: '' as string\n    },\n    resultType: [] as IGroupServiceAddon[]\n  },\n  deleteGroupServiceAddon: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/service_addons/:serviceAddonId',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: {\n      groupName: '' as string,\n      serviceAddonId: '' as string\n    },\n    resultType: [{ id: '' as string }]\n  }\n} as const"}
{"prompt":{"fileName":"group_service.ts","endpoints":[{"endpointName":"postGroupService","endpointArgs":"queryArg: { groupName: '' as string, serviceId: '' as string }","endpointPath":"url: 'group/:groupName/services'","endpointResult":"resultType: [] as IGroupService[]"},{"endpointName":"getGroupServices","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/services'","endpointResult":"resultType: [] as IGroupService[]"},{"endpointName":"deleteGroupService","endpointArgs":"queryArg: { groupName: '' as string, ids: '' as string }","endpointPath":"url: 'group/:groupName/services/:ids'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"groupServicesApi = {\n  postGroupService: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/services',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, serviceId: '' as string },\n    resultType: [] as IGroupService[]\n  },\n  getGroupServices: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/services',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: [] as IGroupService[]\n  },\n  deleteGroupService: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/services/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: '' as string },\n    resultType: [] as { id: string }[]\n  }\n} as const"}
{"prompt":{"fileName":"group_user_schedule.ts","endpoints":[{"endpointName":"postGroupUserSchedule","endpointArgs":"queryArg: { groupName: '' as string, groupScheduleId: '' as string, userScheduleId: '' as string }","endpointPath":"url: 'group/:groupName/user_schedules'","endpointResult":"resultType: [] as IGroupUserSchedule[]"},{"endpointName":"getGroupUserSchedules","endpointArgs":"queryArg: { groupName: '' as string, groupScheduleId: '' as string }","endpointPath":"url: 'group/:groupName/user_schedules/:groupScheduleId'","endpointResult":"resultType: [] as IGroupUserSchedule[]"},{"endpointName":"getGroupUserScheduleStubs","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/user_schedules/stubs'","endpointResult":"resultType: { stubs: [] as IGroupUserScheduleStub[] }"},{"endpointName":"getGroupUserScheduleStubReplacement","endpointArgs":"queryArg: { groupName: '' as string, userScheduleId: '' as string, slotDate: '' as string, startTime: '' as string, tierName: '' as string }","endpointPath":"url: 'group/:groupName/user_schedules/stub_replacement/:userScheduleId'","endpointResult":"resultType: { stubs: [] as IGroupUserScheduleStub[] }"},{"endpointName":"putGroupUserScheduleStubReplacement","endpointArgs":"queryArg: {} as IGroupUserSchedule & IGroupUserScheduleStubReplacement","endpointPath":"url: 'group/:groupName/user_schedules/stub_replacement'","endpointResult":"resultType: { success: true as boolean }"},{"endpointName":"deleteGroupUserScheduleByUserScheduleId","endpointArgs":"queryArg: { groupName: '' as string, ids: '' as string }","endpointPath":"url: 'group/:groupName/user_schedules/:ids'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"groupUserSchedulesApi = {\n  postGroupUserSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/user_schedules',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, groupScheduleId: '' as string, userScheduleId: '' as string },\n    resultType: [] as IGroupUserSchedule[]\n  },\n  getGroupUserSchedules: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/user_schedules/:groupScheduleId',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, groupScheduleId: '' as string },\n    resultType: [] as IGroupUserSchedule[]\n  },\n  getGroupUserScheduleStubs: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/user_schedules/stubs',\n    method: 'GET',\n    opts: { cache: 'skip' } as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: { stubs: [] as IGroupUserScheduleStub[] }\n  },\n  getGroupUserScheduleStubReplacement: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/user_schedules/stub_replacement/:userScheduleId',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, userScheduleId: '' as string, slotDate: '' as string, startTime: '' as string, tierName: '' as string },\n    resultType: { stubs: [] as IGroupUserScheduleStub[] }\n  },\n  putGroupUserScheduleStubReplacement: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/user_schedules/stub_replacement',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as IGroupUserSchedule & IGroupUserScheduleStubReplacement,\n    resultType: { success: true as boolean }\n  },\n  deleteGroupUserScheduleByUserScheduleId: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/user_schedules/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: '' as string },\n    resultType: [] as { id: string }[]\n  },\n} as const"}
{"prompt":{"fileName":"group_user.ts","endpoints":[{"endpointName":"putGroupUser","endpointArgs":"queryArg: { groupName: '' as string, userId: '' as string, roleId: '' as string, roleName: '' as string }","endpointPath":"url: 'group/:groupName/users'","endpointResult":"resultType: [{ id: '' as string, roleId: '' as string, roleName: '' as string }]"},{"endpointName":"getGroupUsers","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/users'","endpointResult":"resultType: [] as IGroupUser[]"},{"endpointName":"getGroupUserById","endpointArgs":"queryArg: { groupName: '' as string, userId: '' as string }","endpointPath":"url: 'group/:groupName/users/:userId'","endpointResult":"resultType: {} as IGroupUser"},{"endpointName":"deleteGroupUser","endpointArgs":"queryArg: { groupName: '' as string, ids: [] as string[] }","endpointPath":"url: 'group/:groupName/users/:ids'","endpointResult":"resultType: [] as { id: string }[]"},{"endpointName":"lockGroupUser","endpointArgs":"queryArg: { groupName: '' as string, ids: [] as string[] }","endpointPath":"url: 'group/:groupName/users/:ids/lock'","endpointResult":"resultType: [] as { id: string }[]"},{"endpointName":"unlockGroupUser","endpointArgs":"queryArg: { groupName: '' as string, ids: [] as string[] }","endpointPath":"url: 'group/:groupName/users/:ids/unlock'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"groupUsersApi = {\n  putGroupUser: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/users',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, userId: '' as string, roleId: '' as string, roleName: '' as string },\n    resultType: [{ id: '' as string, roleId: '' as string, roleName: '' as string }]\n  },\n  getGroupUsers: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/users',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: [] as IGroupUser[]\n  },\n  getGroupUserById: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/users/:userId',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, userId: '' as string },\n    resultType: {} as IGroupUser\n  },\n  deleteGroupUser: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/users/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: [] as string[] },\n    resultType: [] as { id: string }[]\n  },\n  lockGroupUser: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/users/:ids/lock',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: [] as string[] },\n    resultType: [] as { id: string }[]\n  },\n  unlockGroupUser: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/users/:ids/unlock',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string, ids: [] as string[] },\n    resultType: [] as { id: string }[]\n  }\n} as const"}
{"prompt":{"fileName":"group.ts","endpoints":[{"endpointName":"postGroup","endpointArgs":"queryArg: {\n      name: '' as string,\n      purpose: '' as string,\n      roles: {} as Record<string, IRole>,\n      allowedDomains: '' as string,\n      defaultRoleId: '' as string,\n    }","endpointPath":"url: 'group'","endpointResult":"resultType: [] as IGroup[]"},{"endpointName":"putGroup","endpointArgs":"queryArg: {\n      id: '' as string,\n      name: '' as string,\n      roles: {} as Record<string, IRole>,\n      allowedDomains: '' as string,\n      defaultRoleId: '' as string,\n    }","endpointPath":"url: 'group'","endpointResult":"resultType: [] as IGroup[]"},{"endpointName":"putGroupAssignments","endpointArgs":"queryArg: {\n      groupName: '' as string,\n      assignments: {} as Record<string, { actions: { name: string }[] }>,\n    }","endpointPath":"url: 'group/:groupName/assignments'","endpointResult":"resultType: { success: true as boolean }"},{"endpointName":"getGroups","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'group'","endpointResult":"resultType: [] as IGroup[]"},{"endpointName":"getGroupAssignments","endpointArgs":"queryArg: { groupName: '' as string }","endpointPath":"url: 'group/:groupName/assignments'","endpointResult":"resultType: {} as Record<string, IGroupRoleAuthActions>"},{"endpointName":"getGroupById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'group/:id'","endpointResult":"resultType: {} as IGroup"},{"endpointName":"deleteGroup","endpointArgs":"queryArg: { ids: '' as string }","endpointPath":"url: 'group'","endpointResult":"resultType: [] as { id: string }[]"},{"endpointName":"checkGroupName","endpointArgs":"queryArg: { name: '' as string }","endpointPath":"url: 'group/valid/:name'","endpointResult":"resultType: { isValid: true as boolean }"},{"endpointName":"inviteGroupUser","endpointArgs":"queryArg: { users: [] as { email: string }[] }","endpointPath":"url: 'group/users/invite'","endpointResult":"resultType: { users: [] as { email: string }[] }"},{"endpointName":"joinGroup","endpointArgs":"queryArg: { code: '' as string }","endpointPath":"url: 'group/join/:code'","endpointResult":"resultType: { success: true as boolean }"},{"endpointName":"leaveGroup","endpointArgs":"queryArg: { code: '' as string }","endpointPath":"url: 'group/leave/:code'","endpointResult":"resultType: { success: true as boolean }"}],"types":[]},"result":"groupApi = {\n  postGroup: {\n    kind: EndpointType.MUTATION,\n    url: 'group',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {\n      name: '' as string,\n      purpose: '' as string,\n      roles: {} as Record<string, IRole>,\n      allowedDomains: '' as string,\n      defaultRoleId: '' as string,\n    },\n    resultType: [] as IGroup[]\n  },\n  putGroup: {\n    kind: EndpointType.MUTATION,\n    url: 'group',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {\n      id: '' as string,\n      name: '' as string,\n      roles: {} as Record<string, IRole>,\n      allowedDomains: '' as string,\n      defaultRoleId: '' as string,\n    },\n    resultType: [] as IGroup[]\n  },\n  putGroupAssignments: {\n    kind: EndpointType.MUTATION,\n    url: 'group/:groupName/assignments',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {\n      groupName: '' as string,\n      assignments: {} as Record<string, { actions: { name: string }[] }>,\n    },\n    resultType: { success: true as boolean }\n  },\n  getGroups: {\n    kind: EndpointType.QUERY,\n    url: 'group',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IGroup[]\n  },\n  getGroupAssignments: {\n    kind: EndpointType.QUERY,\n    url: 'group/:groupName/assignments',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { groupName: '' as string },\n    resultType: {} as Record<string, IGroupRoleAuthActions>\n  },\n  getGroupById: {\n    kind: EndpointType.QUERY,\n    url: 'group/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IGroup\n  },\n  deleteGroup: {\n    kind: EndpointType.MUTATION,\n    url: 'group',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { ids: '' as string },\n    resultType: [] as { id: string }[]\n  },\n  checkGroupName: {\n    kind: EndpointType.QUERY,\n    url: 'group/valid/:name',\n    method: 'GET',\n    opts: { cache: null } as ApiOptions,\n    queryArg: { name: '' as string },\n    resultType: { isValid: true as boolean }\n  },\n  inviteGroupUser: {\n    kind: EndpointType.MUTATION,\n    url: 'group/users/invite',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { users: [] as { email: string }[] },\n    resultType: { users: [] as { email: string }[] }\n  },\n  joinGroup: {\n    kind: EndpointType.MUTATION,\n    url: 'group/join/:code',\n    method: 'POST',\n    opts: { cache: 'skip' } as ApiOptions,\n    queryArg: { code: '' as string },\n    resultType: { success: true as boolean }\n  },\n  leaveGroup: {\n    kind: EndpointType.MUTATION,\n    url: 'group/leave/:code',\n    method: 'POST',\n    opts: { cache: 'skip' } as ApiOptions,\n    queryArg: { code: '' as string },\n    resultType: { success: true as boolean }\n  }\n} as const"}
{"prompt":{"fileName":"lookup.ts","endpoints":[{"endpointName":"getLookups","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'lookup'","endpointResult":"resultType: {\n      budgets: [] as ILookup[],\n      timelines: [] as ILookup[],\n      timeUnits: [] as ITimeUnit[]\n    }"}],"types":[]},"result":"lookupApi = {\n  getLookups: {\n    kind: EndpointType.QUERY,\n    url: 'lookup',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: {\n      budgets: [] as ILookup[],\n      timelines: [] as ILookup[],\n      timeUnits: [] as ITimeUnit[]\n    }\n  },\n} as const"}
{"prompt":{"fileName":"manage_group.ts","endpoints":[{"endpointName":"postManageGroups","endpointArgs":"queryArg: { name: '' as string, roles: {} as Record<string, boolean> }","endpointPath":"url: 'manage/groups'","endpointResult":"resultType: { id: '' as string, name: '' as string, roles: {} as Record<string, boolean> }"},{"endpointName":"putManageGroups","endpointArgs":"queryArg: { id: '' as string, name: '' as string, roles: {} as Record<string, boolean> }","endpointPath":"url: 'manage/groups'","endpointResult":"resultType: { id: '' as string, name: '' as string, roles: {} as Record<string, boolean> }"},{"endpointName":"getManageGroups","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'manage/groups'","endpointResult":"resultType: [] as IGroup[]"},{"endpointName":"deleteManageGroups","endpointArgs":"queryArg: { ids: [''] as string[] }","endpointPath":"url: 'manage/groups'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"manageGroupsApi = {\n  postManageGroups: {\n    kind: EndpointType.MUTATION,\n    url: 'manage/groups',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { name: '' as string, roles: {} as Record<string, boolean> },\n    resultType: { id: '' as string, name: '' as string, roles: {} as Record<string, boolean> }\n  },\n  putManageGroups: {\n    kind: EndpointType.MUTATION,\n    url: 'manage/groups',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, name: '' as string, roles: {} as Record<string, boolean> },\n    resultType: { id: '' as string, name: '' as string, roles: {} as Record<string, boolean> }\n  },\n  getManageGroups: {\n    kind: EndpointType.QUERY,\n    url: 'manage/groups',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IGroup[]\n  },\n  deleteManageGroups: {\n    kind: EndpointType.MUTATION,\n    url: 'manage/groups',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { ids: [''] as string[] },\n    resultType: [] as { id: string }[]\n  }\n} as const"}
{"prompt":{"fileName":"manage_role.ts","endpoints":[{"endpointName":"postManageRoles","endpointArgs":"queryArg: { name: '' as string }","endpointPath":"url: 'manage/roles'","endpointResult":"resultType: { id: '' as string, name: '' as string }"},{"endpointName":"putManageRoles","endpointArgs":"queryArg: { id: '' as string, name: '' as string }","endpointPath":"url: 'manage/roles'","endpointResult":"resultType: { id: '' as string, name: '' as string }"},{"endpointName":"getManageRoles","endpointArgs":"queryArg: {} as Record<string, never>","endpointPath":"url: 'manage/roles'","endpointResult":"resultType: [] as IRole[]"},{"endpointName":"deleteManageRoles","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'manage/roles'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"manageRolesApi = {\r\n  postManageRoles: {\r\n    kind: EndpointType.MUTATION,\r\n    url: 'manage/roles',\r\n    method: 'POST',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { name: '' as string },\r\n    resultType: { id: '' as string, name: '' as string }\r\n  },\r\n  putManageRoles: {\r\n    kind: EndpointType.MUTATION,\r\n    url: 'manage/roles',\r\n    method: 'PUT',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { id: '' as string, name: '' as string },\r\n    resultType: { id: '' as string, name: '' as string }\r\n  },\r\n  getManageRoles: {\r\n    kind: EndpointType.QUERY,\r\n    url: 'manage/roles',\r\n    method: 'GET',\r\n    opts: {} as ApiOptions,\r\n    queryArg: {} as Record<string, never>,\r\n    resultType: [] as IRole[]\r\n  },\r\n  deleteManageRoles: {\r\n    kind: EndpointType.MUTATION,\r\n    url: 'manage/roles',\r\n    method: 'DELETE',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { id: '' as string },\r\n    resultType: { id: '' as string }\r\n  }\r\n} as const"}
{"prompt":{"fileName":"payment.ts","endpoints":[{"endpointName":"postPayment","endpointArgs":"queryArg: {} as IPayment","endpointPath":"url: 'payments'","endpointResult":"resultType: {} as IPayment"},{"endpointName":"putPayment","endpointArgs":"queryArg: {} as IPayment","endpointPath":"url: 'payments'","endpointResult":"resultType: {} as IPayment"},{"endpointName":"getPayments","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'payments'","endpointResult":"resultType: [] as IPayment[]"},{"endpointName":"getPaymentById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'payments/:id'","endpointResult":"resultType: {} as IPayment"},{"endpointName":"deletePayment","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'payments/:id'","endpointResult":"resultType: {} as IPayment"},{"endpointName":"disablePayment","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'payments/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"paymentApi = {\n  postPayment: {\n    kind: EndpointType.MUTATION,\n    url: 'payments',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {} as IPayment,\n    resultType: {} as IPayment\n  },\n  putPayment: {\n    kind: EndpointType.MUTATION,\n    url: 'payments',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as IPayment,\n    resultType: {} as IPayment\n  },\n  getPayments: {\n    kind: EndpointType.QUERY,\n    url: 'payments',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IPayment[]\n  },\n  getPaymentById: {\n    kind: EndpointType.QUERY,\n    url: 'payments/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IPayment\n  },\n  deletePayment: {\n    kind: EndpointType.MUTATION,\n    url: 'payments/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IPayment\n  },\n  disablePayment: {\n    kind: EndpointType.MUTATION,\n    url: 'payments/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"profile.ts","endpoints":[{"endpointName":"postUserProfile","endpointArgs":"queryArg: { firstName: '' as string, lastName: '' as string, username: '' as string, email: '' as string, image: '' as string, sub: '' as string }","endpointPath":"url: 'profile'","endpointResult":"resultType: { id: '' as string, sub: '' as string, username: '' as string, firstName: '' as string, lastName: '' as string, email: '' as string, image: '' as string }"},{"endpointName":"putUserProfile","endpointArgs":"queryArg: { id: '' as string, firstName: '' as string, lastName: '' as string, email: '' as string, image: '' as string }","endpointPath":"url: 'profile'","endpointResult":"resultType: { id: '' as string, firstName: '' as string, lastName: '' as string, email: '' as string, image: '' as string }"},{"endpointName":"getUserProfileDetails","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'profile/details'","endpointResult":"resultType: {} as IUserProfile"},{"endpointName":"getUserProfileDetailsBySub","endpointArgs":"queryArg: { sub: '' as string }","endpointPath":"url: 'profile/details/sub/:sub'","endpointResult":"resultType: {} as IUserProfile"},{"endpointName":"getUserProfileDetailsById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'profile/details/id/:id'","endpointResult":"resultType: {} as IUserProfile"},{"endpointName":"disableUserProfile","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'profile/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"userProfileApi = {\r\n  postUserProfile: {\r\n    kind: EndpointType.MUTATION,\r\n    url: 'profile',\r\n    method: 'POST',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { firstName: '' as string, lastName: '' as string, username: '' as string, email: '' as string, image: '' as string, sub: '' as string },\r\n    resultType: { id: '' as string, sub: '' as string, username: '' as string, firstName: '' as string, lastName: '' as string, email: '' as string, image: '' as string }\r\n  },\r\n  putUserProfile: {\r\n    kind: EndpointType.MUTATION,\r\n    url: 'profile',\r\n    method: 'PUT',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { id: '' as string, firstName: '' as string, lastName: '' as string, email: '' as string, image: '' as string },\r\n    resultType: { id: '' as string, firstName: '' as string, lastName: '' as string, email: '' as string, image: '' as string }\r\n  },\r\n  getUserProfileDetails: {\r\n    kind: EndpointType.QUERY,\r\n    url: 'profile/details',\r\n    method: 'GET',\r\n    opts: {} as ApiOptions,\r\n    queryArg: {} as Void,\r\n    resultType: {} as IUserProfile\r\n  },\r\n  getUserProfileDetailsBySub: {\r\n    kind: EndpointType.QUERY,\r\n    url: 'profile/details/sub/:sub',\r\n    method: 'GET',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { sub: '' as string },\r\n    resultType: {} as IUserProfile\r\n  },\r\n  getUserProfileDetailsById: {\r\n    kind: EndpointType.QUERY,\r\n    url: 'profile/details/id/:id',\r\n    method: 'GET',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { id: '' as string },\r\n    resultType: {} as IUserProfile\r\n  },\r\n  disableUserProfile: {\r\n    kind: EndpointType.MUTATION,\r\n    url: 'profile/:id/disable',\r\n    method: 'PUT',\r\n    opts: {} as ApiOptions,\r\n    queryArg: { id: '' as string },\r\n    resultType: { id: '' as string }\r\n  }\r\n} as const"}
{"prompt":{"fileName":"quote.ts","endpoints":[{"endpointName":"postQuote","endpointArgs":"queryArg: {} as IQuote","endpointPath":"url: 'quotes'","endpointResult":"resultType: [] as IQuote[]"},{"endpointName":"putQuote","endpointArgs":"queryArg: { id: '' as string, serviceTierId: '' as string }","endpointPath":"url: 'quotes'","endpointResult":"resultType: {} as IQuote"},{"endpointName":"getQuotes","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'quotes'","endpointResult":"resultType: [] as IQuote[]"},{"endpointName":"getQuoteById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'quotes/:id'","endpointResult":"resultType: {} as IQuote"},{"endpointName":"deleteQuote","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'quotes/:id'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"disableQuote","endpointArgs":"queryArg: { ids: '' as string }","endpointPath":"url: 'quotes/disable/:ids'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"quoteApi = {\n  postQuote: {\n    kind: EndpointType.MUTATION,\n    url: 'quotes',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {} as IQuote,\n    resultType: [] as IQuote[]\n  },\n  putQuote: {\n    kind: EndpointType.MUTATION,\n    url: 'quotes',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, serviceTierId: '' as string },\n    resultType: {} as IQuote\n  },\n  getQuotes: {\n    kind: EndpointType.QUERY,\n    url: 'quotes',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IQuote[]\n  },\n  getQuoteById: {\n    kind: EndpointType.QUERY,\n    url: 'quotes/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IQuote\n  },\n  deleteQuote: {\n    kind: EndpointType.MUTATION,\n    url: 'quotes/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string },\n  },\n  disableQuote: {\n    kind: EndpointType.MUTATION,\n    url: 'quotes/disable/:ids',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { ids: '' as string },\n    resultType: [] as { id: string }[]\n  }\n} as const"}
{"prompt":{"fileName":"role.ts","endpoints":[{"endpointName":"postRole","endpointArgs":"queryArg: { name: '' as string }","endpointPath":"url: 'roles'","endpointResult":"resultType: {} as IRole"},{"endpointName":"putRole","endpointArgs":"queryArg: {} as IRole","endpointPath":"url: 'roles'","endpointResult":"resultType: {} as IRole"},{"endpointName":"getRoles","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'roles'","endpointResult":"resultType: [] as IRole[]"},{"endpointName":"getRoleById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'roles/:id'","endpointResult":"resultType: {} as IRole"},{"endpointName":"deleteRole","endpointArgs":"queryArg: { ids: '' as string }","endpointPath":"url: 'roles/:ids'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"roleApi = {\n  postRole: {\n    kind: EndpointType.MUTATION,\n    url: 'roles',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { name: '' as string },\n    resultType: {} as IRole\n  },\n  putRole: {\n    kind: EndpointType.MUTATION,\n    url: 'roles',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as IRole,\n    resultType: {} as IRole\n  },\n  getRoles: {\n    kind: EndpointType.QUERY,\n    url: 'roles',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IRole[]\n  },\n  getRoleById: {\n    kind: EndpointType.QUERY,\n    url: 'roles/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IRole\n  },\n  deleteRole: {\n    kind: EndpointType.MUTATION,\n    url: 'roles/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { ids: '' as string },\n    resultType: [] as { id: string }[]\n  }\n} as const"}
{"prompt":{"fileName":"schedule.ts","endpoints":[{"endpointName":"postSchedule","endpointArgs":"queryArg: {} as ISchedule","endpointPath":"url: 'schedules'","endpointResult":"resultType: {} as ISchedule"},{"endpointName":"postScheduleBrackets","endpointArgs":"queryArg: { scheduleId: '' as string, brackets: {} as Record<string, IScheduleBracket> }","endpointPath":"url: 'schedule/brackets'","endpointResult":"resultType: { id: '' as string, brackets: {} as Record<string, IScheduleBracket> }"},{"endpointName":"putSchedule","endpointArgs":"queryArg: {} as ISchedule","endpointPath":"url: 'schedules'","endpointResult":"resultType: {} as ISchedule"},{"endpointName":"getSchedules","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'schedules'","endpointResult":"resultType: [] as ISchedule[]"},{"endpointName":"getScheduleById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'schedules/:id'","endpointResult":"resultType: {} as ISchedule"},{"endpointName":"deleteSchedule","endpointArgs":"queryArg: { ids: '' as string }","endpointPath":"url: 'schedules/:ids'","endpointResult":"resultType: [] as { id: string }[]"},{"endpointName":"disableSchedule","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'schedules/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"scheduleApi = {\n  postSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'schedules',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: {} as ISchedule,\n    resultType: {} as ISchedule\n  },\n  postScheduleBrackets: {\n    kind: EndpointType.MUTATION,\n    url: 'schedule/brackets',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { scheduleId: '' as string, brackets: {} as Record<string, IScheduleBracket> },\n    resultType: { id: '' as string, brackets: {} as Record<string, IScheduleBracket> }\n  },\n  putSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'schedules',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: {} as ISchedule,\n    resultType: {} as ISchedule\n  },\n  getSchedules: {\n    kind: EndpointType.QUERY,\n    url: 'schedules',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as ISchedule[]\n  },\n  getScheduleById: {\n    kind: EndpointType.QUERY,\n    url: 'schedules/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as ISchedule\n  },\n  deleteSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'schedules/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { ids: '' as string },\n    resultType: [] as { id: string }[]\n  },\n  disableSchedule: {\n    kind: EndpointType.MUTATION,\n    url: 'schedules/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"service_addon.ts","endpoints":[{"endpointName":"postServiceAddon","endpointArgs":"queryArg: { name: '' as string }","endpointPath":"url: 'service_addons'","endpointResult":"resultType: {} as IServiceAddon"},{"endpointName":"putServiceAddon","endpointArgs":"queryArg: { id: '' as string, name: '' as string }","endpointPath":"url: 'service_addons'","endpointResult":"resultType: {} as IServiceAddon"},{"endpointName":"getServiceAddons","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'service_addons'","endpointResult":"resultType: [] as IServiceAddon[]"},{"endpointName":"getServiceAddonById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'service_addons/:id'","endpointResult":"resultType: {} as IServiceAddon"},{"endpointName":"deleteServiceAddon","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'service_addons/:id'","endpointResult":"resultType: {} as IServiceAddon"},{"endpointName":"disableServiceAddon","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'service_addons/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"serviceAddonApi = {\n  postServiceAddon: {\n    kind: EndpointType.MUTATION,\n    url: 'service_addons',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { name: '' as string },\n    resultType: {} as IServiceAddon\n  },\n  putServiceAddon: {\n    kind: EndpointType.MUTATION,\n    url: 'service_addons',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, name: '' as string },\n    resultType: {} as IServiceAddon\n  },\n  getServiceAddons: {\n    kind: EndpointType.QUERY,\n    url: 'service_addons',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IServiceAddon[]\n  },\n  getServiceAddonById: {\n    kind: EndpointType.QUERY,\n    url: 'service_addons/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IServiceAddon\n  },\n  deleteServiceAddon: {\n    kind: EndpointType.MUTATION,\n    url: 'service_addons/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IServiceAddon\n  },\n  disableServiceAddon: {\n    kind: EndpointType.MUTATION,\n    url: 'service_addons/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"service_tier.ts","endpoints":[{"endpointName":"postServiceTier","endpointArgs":"queryArg: { name: '' as string, serviceId: '' as string, multiplier: '' as string }","endpointPath":"url: 'service_tiers'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"putServiceTier","endpointArgs":"queryArg: { id: '' as string, name: '' as string, multiplier: '' as string }","endpointPath":"url: 'service_tiers'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"getServiceTiers","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'service_tiers'","endpointResult":"resultType: [] as IServiceTier[]"},{"endpointName":"getServiceTierById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'service_tiers/:id'","endpointResult":"resultType: {} as IServiceTier"},{"endpointName":"deleteServiceTier","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'service_tiers/:id'","endpointResult":"resultType: {} as IServiceTier"},{"endpointName":"disableServiceTier","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'service_tiers/:id/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"serviceTierApi = {\n  postServiceTier: {\n    kind: EndpointType.MUTATION,\n    url: 'service_tiers',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { name: '' as string, serviceId: '' as string, multiplier: '' as string },\n    resultType: { id: '' as string }\n  },\n  putServiceTier: {\n    kind: EndpointType.MUTATION,\n    url: 'service_tiers',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, name: '' as string, multiplier: '' as string },\n    resultType: { id: '' as string }\n  },\n  getServiceTiers: {\n    kind: EndpointType.QUERY,\n    url: 'service_tiers',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IServiceTier[]\n  },\n  getServiceTierById: {\n    kind: EndpointType.QUERY,\n    url: 'service_tiers/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IServiceTier\n  },\n  deleteServiceTier: {\n    kind: EndpointType.MUTATION,\n    url: 'service_tiers/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IServiceTier\n  },\n  disableServiceTier: {\n    kind: EndpointType.MUTATION,\n    url: 'service_tiers/:id/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"service.ts","endpoints":[{"endpointName":"postService","endpointArgs":"queryArg: { name: '' as string, cost: '' as string, formId: '' as string, tiers: {} as Record<string, IServiceTier> }","endpointPath":"url: 'services'","endpointResult":"resultType: {} as IService"},{"endpointName":"putService","endpointArgs":"queryArg: { id: '' as string, name: '' as string }","endpointPath":"url: 'services'","endpointResult":"resultType: {} as IService"},{"endpointName":"getServices","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'services'","endpointResult":"resultType: [] as IService[]"},{"endpointName":"getServiceById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'services/:id'","endpointResult":"resultType: {} as IService"},{"endpointName":"deleteService","endpointArgs":"queryArg: { ids: '' as string }","endpointPath":"url: 'services/:ids'","endpointResult":"resultType: [] as { id: string }[]"},{"endpointName":"disableService","endpointArgs":"queryArg: { ids: '' as string }","endpointPath":"url: 'services/:ids/disable'","endpointResult":"resultType: [] as { id: string }[]"}],"types":[]},"result":"serviceApi = {\n  postService: {\n    kind: EndpointType.MUTATION,\n    url: 'services',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { name: '' as string, cost: '' as string, formId: '' as string, tiers: {} as Record<string, IServiceTier> },\n    resultType: {} as IService\n  },\n  putService: {\n    kind: EndpointType.MUTATION,\n    url: 'services',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, name: '' as string },\n    resultType: {} as IService\n  },\n  getServices: {\n    kind: EndpointType.QUERY,\n    url: 'services',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IService[]\n  },\n  getServiceById: {\n    kind: EndpointType.QUERY,\n    url: 'services/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IService\n  },\n  deleteService: {\n    kind: EndpointType.MUTATION,\n    url: 'services/:ids',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { ids: '' as string },\n    resultType: [] as { id: string }[]\n  },\n  disableService: {\n    kind: EndpointType.MUTATION,\n    url: 'services/:ids/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { ids: '' as string },\n    resultType: [] as { id: string }[]\n  }\n} as const"}
{"prompt":{"fileName":"uuid_files.ts","endpoints":[{"endpointName":"postUuidFile","endpointArgs":"queryArg: { parentUuid: '' as string, fileId: '' as string }","endpointPath":"url: 'uuid_files'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"putUuidFile","endpointArgs":"queryArg: { id: '' as string, parentUuid: '' as string, fileId: '' as string }","endpointPath":"url: 'uuid_files'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"getUuidFiles","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'uuid_files'","endpointResult":"resultType: [] as IUuidFiles[]"},{"endpointName":"getUuidFileById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'uuid_files/:id'","endpointResult":"resultType: {} as IUuidFiles"},{"endpointName":"deleteUuidFile","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'uuid_files/:id'","endpointResult":"resultType: {} as IUuidFiles"},{"endpointName":"disableUuidFile","endpointArgs":"queryArg: { id: '' as string, parentUuid: '' as string, fileId: '' as string }","endpointPath":"url: 'uuid_files/disable'","endpointResult":"resultType: { id: '' as string }"}],"types":[]},"result":"uuidFilesApi = {\n  postUuidFile: {\n    kind: EndpointType.MUTATION,\n    url: 'uuid_files',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { parentUuid: '' as string, fileId: '' as string },\n    resultType: { id: '' as string }\n  },\n  putUuidFile: {\n    kind: EndpointType.MUTATION,\n    url: 'uuid_files',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, parentUuid: '' as string, fileId: '' as string },\n    resultType: { id: '' as string }\n  },\n  getUuidFiles: {\n    kind: EndpointType.QUERY,\n    url: 'uuid_files',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IUuidFiles[]\n  },\n  getUuidFileById: {\n    kind: EndpointType.QUERY,\n    url: 'uuid_files/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IUuidFiles\n  },\n  deleteUuidFile: {\n    kind: EndpointType.MUTATION,\n    url: 'uuid_files/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IUuidFiles\n  },\n  disableUuidFile: {\n    kind: EndpointType.MUTATION,\n    url: 'uuid_files/disable',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, parentUuid: '' as string, fileId: '' as string },\n    resultType: { id: '' as string }\n  }\n} as const"}
{"prompt":{"fileName":"uuid_notes.ts","endpoints":[{"endpointName":"postUuidNote","endpointArgs":"queryArg: { parentUuid: '' as string, note: '' as string }","endpointPath":"url: 'uuid_notes'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"putUuidNote","endpointArgs":"queryArg: { id: '' as string, parentUuid: '' as string, note: '' as string }","endpointPath":"url: 'uuid_notes'","endpointResult":"resultType: { id: '' as string }"},{"endpointName":"getUuidNotes","endpointArgs":"queryArg: {} as Void","endpointPath":"url: 'uuid_notes'","endpointResult":"resultType: [] as IUuidNotes[]"},{"endpointName":"getUuidNoteById","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'uuid_notes/:id'","endpointResult":"resultType: {} as IUuidNotes"},{"endpointName":"deleteUuidNote","endpointArgs":"queryArg: { id: '' as string }","endpointPath":"url: 'uuid_notes/:id'","endpointResult":"resultType: {} as IUuidNotes"}],"types":[]},"result":"uuidNotesApi = {\n  postUuidNote: {\n    kind: EndpointType.MUTATION,\n    url: 'uuid_notes',\n    method: 'POST',\n    opts: {} as ApiOptions,\n    queryArg: { parentUuid: '' as string, note: '' as string },\n    resultType: { id: '' as string }\n  },\n  putUuidNote: {\n    kind: EndpointType.MUTATION,\n    url: 'uuid_notes',\n    method: 'PUT',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string, parentUuid: '' as string, note: '' as string },\n    resultType: { id: '' as string }\n  },\n  getUuidNotes: {\n    kind: EndpointType.QUERY,\n    url: 'uuid_notes',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: {} as Void,\n    resultType: [] as IUuidNotes[]\n  },\n  getUuidNoteById: {\n    kind: EndpointType.QUERY,\n    url: 'uuid_notes/:id',\n    method: 'GET',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IUuidNotes\n  },\n  deleteUuidNote: {\n    kind: EndpointType.MUTATION,\n    url: 'uuid_notes/:id',\n    method: 'DELETE',\n    opts: {} as ApiOptions,\n    queryArg: { id: '' as string },\n    resultType: {} as IUuidNotes\n  }\n} as const"}
{"prompt":{"fileName":"BookingHome.tsx","defaultExportName":"BookingHome","hooks":["sh"],"childComponents":[]},"result":"export function BookingHome(): JSX.Element {\n\n  const { data: bookings } = sh.useGetBookingsQuery();\n  \n  console.log({ bookings })\n\n  return <></>;\n}"}
{"prompt":{"fileName":"BookingProvider.tsx","defaultExportName":"BookingProvider","hooks":["sh"],"childComponents":[]},"result":"export function BookingProvider ({ children }: IProps): JSX.Element {\n\n  const [bookingValuesChanged, setBookingValuesChanged] = useState(false);\n  const [selectedBooking, setSelectedBooking] = useState<IBooking[]>([]);\n\n  const { data : profile } = sh.useGetUserProfileDetailsQuery();\n\n  const bookingValues = useMemo(() => Object.values(profile?.bookings || {}), [profile]);\n\n  const bookingValuesContext = {\n    bookingValues,\n    setBookingValuesChanged,\n    bookingValuesChanged,\n    selectedBooking,\n    setSelectedBooking,\n    handleSelectPendingBooking(booking) {\n      const currentIndex = selectedBooking.indexOf(booking);\n      const newChecked = [...selectedBooking];\n\n      if (currentIndex === -1) {\n        newChecked.push(booking);\n      } else {\n        newChecked.splice(currentIndex, 1);\n      }\n\n      setSelectedBooking(newChecked);\n    },\n    handleSelectPendingBookingAll() {\n      const bookingValuesSet = selectedBooking.length === bookingValues.length ?\n        selectedBooking.filter(v => !bookingValues.includes(v)) :\n        [...selectedBooking, ...bookingValues.filter(v => !selectedBooking.includes(v))];\n      \n      setSelectedBooking(bookingValuesSet);\n    }\n  } as BookingContextType | null;\n\n  return <>\n    <BookingContext.Provider value={bookingValuesContext}>\n      {children}\n    </BookingContext.Provider>\n  </>;\n  \n}"}
{"prompt":{"fileName":"UpcomingBookingsMenu.tsx","defaultExportName":"UpcomingBookingsMenu","hooks":["sh"],"childComponents":[]},"result":"export function UpcomingBookingsMenu({ handleMenuClose, upcomingBookingsAnchorEl, upcomingBookingsMenuId, isUpcomingBookingsOpen }: IProps): JSX.Element {\n\n  const { data: profile } = sh.useGetUserProfileDetailsQuery();\n\n  const minsAgo15 = dayjs.duration(-15, 'minutes');\n  const startOfDay = dayjs().startOf('day');\n\n  const upcomingBookings = useMemo(() => Object.values(profile?.bookings || {}), [profile]);\n\n  const goToBooking = useCallback(() => {\n    console.log('navigate here');\n  }, []);\n\n  return <Menu\n    anchorEl={upcomingBookingsAnchorEl}\n    anchorOrigin={{\n      vertical: 'bottom',\n      horizontal: 'left',\n    }}\n    id={upcomingBookingsMenuId}\n    keepMounted\n    transformOrigin={{\n      vertical: 'top',\n      horizontal: 'right',\n    }}\n    open={!!isUpcomingBookingsOpen}\n    onClose={handleMenuClose}\n  >\n    <List>\n      {upcomingBookings.length ? <Box sx={{ width: 300 }}>\n        {upcomingBookings.map(({ slotDate, startTime, serviceName, serviceTierName }, i) => {\n\n          const dt = bookingDT(slotDate, startTime);\n\n          return <ListItem\n            key={`upcoming_appt_ub_${i}`}\n            secondaryAction={dayjs().isAfter(dt.add(minsAgo15)) && dt.startOf('day').isSame(startOfDay) && <>\n              <Tooltip title=\"Join Appointment\">\n                <Button\n                  aria-label={`go to appointment for ${shortNSweet(slotDate, startTime)}`}\n                  onClick={goToBooking}\n                  variant=\"text\"\n                  startIcon={<JoinFullIcon />}\n                >\n                  Join\n                </Button>\n              </Tooltip>\n            </>}\n          >\n            <ListItemText\n              primary={`${shortNSweet(slotDate, startTime)}`}\n              secondary={`${serviceName} ${serviceTierName}`}\n            />\n          </ListItem>\n        })}\n      </Box> : <Box sx={{ width: 250 }}>\n        <ListItem>\n          <ListItemText>No upcoming appointments.</ListItemText>\n        </ListItem>\n      </Box>}\n    </List>\n  </Menu>\n}"}
{"prompt":{"fileName":"AsyncAvatar.tsx","defaultExportName":"AsyncAvatar","hooks":["useFileStore"],"childComponents":[]},"result":"export function AsyncAvatar ({ image }: IProps): JSX.Element {\r\n  const [url, setUrl] = useState('');\r\n  const fileStore = useFileStore();\r\n  \r\n  useEffect(() => {\r\n    async function getImage() {\r\n      if (fileStore && image) {\r\n        setUrl(await fileStore?.get(image));\r\n      }\r\n    }\r\n    void getImage();\r\n  }, [fileStore, image])\r\n\r\n  return url.length ? <Avatar src={url || ''} /> : <></>\r\n}"}
{"prompt":{"fileName":"ConfirmAction.tsx","defaultExportName":"ConfirmAction","hooks":["useAppSelector","useUtil"],"childComponents":[]},"result":"export function ConfirmAction(): JSX.Element {\r\n\r\n  const { closeConfirm } = useUtil();\r\n  const util = useAppSelector(state => state.util);\r\n\r\n  return <>\r\n    {util && (\r\n      <Dialog open={!!util.isConfirming} fullWidth={true} maxWidth=\"sm\">\r\n        <Card>\r\n          <CardHeader title=\"Confirm Action\" subheader={`Action: ${util.confirmEffect}`} />\r\n          <Grid container sx={{ minHeight: '25vh' }}>\r\n            <Grid item xs={util.confirmSideEffect ? 6 : 12}>\r\n              <CardActionArea sx={{ height: '100%', padding: '50px' }} onClick={async () => {\r\n                await util.confirmAction(true);\r\n                closeConfirm();\r\n              }}>\r\n                <Grid container textAlign=\"center\" justifyContent=\"center\">\r\n                  <Grid item>\r\n                    {util.confirmSideEffect && <Typography variant=\"button\" fontSize={16}>{util.confirmSideEffect?.approvalAction}</Typography>}\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"caption\">{util.confirmSideEffect?.approvalEffect ? 'Click here to: ' + util.confirmSideEffect.approvalEffect : 'Click here to confirm approval.'}</Typography>\r\n                  </Grid>\r\n                </Grid>\r\n              </CardActionArea>\r\n            </Grid>\r\n            {util.confirmSideEffect && <Grid item xs={6}>\r\n\r\n              <CardActionArea sx={{ height: '100%', padding: '50px' }} onClick={async () => {\r\n                await util.confirmAction(false);\r\n                closeConfirm();\r\n              }}>\r\n                <Grid container textAlign=\"center\" justifyContent=\"center\">\r\n                  <Typography variant=\"button\" fontSize={16}>{util.confirmSideEffect.rejectionAction}</Typography>\r\n                  <Typography variant=\"caption\">Click here to: {util.confirmSideEffect.rejectionEffect}</Typography>\r\n                </Grid>\r\n              </CardActionArea>\r\n            </Grid>}\r\n          </Grid>\r\n          <CardActions>\r\n            <Button onClick={() => { closeConfirm(); }}>Cancel</Button>\r\n          </CardActions>\r\n        </Card>\r\n      </Dialog>\r\n    )}\r\n  </>\r\n}"}
{"prompt":{"fileName":"FileManager.tsx","defaultExportName":"FileManager","hooks":["sh","useGrid"],"childComponents":[]},"result":"export function FileManager(): JSX.Element {\n\n  const { data: files } = sh.useGetFilesQuery();\n  \n  const fileSelectRef = useRef<HTMLInputElement>(null);\n\n  const [toggle, setToggle] = useState(false);\n  const [selected, setSelected] = useState<string[]>([]);\n\n  const actions = useMemo(() => {\n    return [\n      <Button key={'delete_selected_files'} onClick={deleteFiles}>Delete</Button>,\n    ];\n  }, [selected]);\n\n  const FileGrid = useGrid({\n    rows: files || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Button onClick={addFiles}>Add</Button>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  })\n\n  function addFiles() {\n    if (fileSelectRef.current) {\n      fileSelectRef.current.click();\n    }\n  }\n\n  function deleteFiles() {\n    if (selected.length) {\n      // void api(DELETE_FILE, true, selected);\n      setToggle(!toggle);\n    }\n  }\n\n  // useEffect(() => {\n  //   if (newFiles.length) {\n  //     async function go() {\n  //       const postFiles: IFile[] = [];\n  //       for (let i = 0, v = newFiles.length; i < v; i++) {\n  //         const file = newFiles[i];\n  //         const location = await fileStore.post(file);\n  //         postFiles.push({ location, name: file.name, fileTypeName: FileStoreStrategies.FILE_SYSTEM })\n  //       }\n  //       void api(POST_FILE, true, postFiles);\n  //     }\n  //     void go();\n  //   }\n  // }, [newFiles])\n\n  return <>\n    {/* <input type=\"file\" multiple id=\"new-file\" onChange={e => e.target.files && setNewFiles(Array.from(e.target.files))} ref={fileSelectRef} style={{ display: 'none' }} /> */}\n\n    <Card>\n      <CardContent>\n        <FileGrid />\n      </CardContent>\n    </Card>\n  </>\n}"}
{"prompt":{"fileName":"Home.tsx","defaultExportName":"Home","hooks":["useComponents"],"childComponents":[]},"result":"export function Home(props: IProps): JSX.Element {\n  const { BookingHome, GroupHome, QuoteHome, PendingQuotesProvider } = useComponents();\n  return <>\n    <Box mb={2}>\n      <BookingHome {...props} />\n    </Box>\n    <Box mb={2}>\n      <PendingQuotesProvider>\n        <QuoteHome {...props} />\n      </PendingQuotesProvider>\n    </Box>\n    <Box mb={2}>\n      <GroupHome {...props} />\n    </Box>\n  </>\n}"}
{"prompt":{"fileName":"Onboard.tsx","defaultExportName":"Onboard","hooks":["useComponents","useUtil","sh"],"childComponents":[]},"result":"export function Onboard(props: IProps): JSX.Element {\n\n  const [joinGroup] = sh.useJoinGroupMutation();\n\n  const { setSnack } = useUtil();\n\n  const { ManageGroupModal } = useComponents();\n\n  const [groupCode, setGroupCode] = useState('');\n  const [dialog, setDialog] = useState('');\n\n  const joinGroupCb = useCallback(() => {\n    if (groupCode) {\n      if (/^[a-zA-Z0-9]{8}$/.test(groupCode)) {\n        joinGroup({ code: groupCode }).unwrap().then(() => keycloak.clearToken()).catch(console.error);\n      } else {\n        setSnack({ snackType: 'warning', snackOn: 'Invalid group code.' });\n      }\n    }\n  }, [groupCode]);\n\n  return <>\n\n    <Dialog fullScreen open={dialog === 'create_group'} fullWidth maxWidth=\"sm\">\n      <Box sx={{ bgcolor: 'primary.dark' }}>\n        <Grid container sx={{ placeContent: 'center', minHeight: '100vh', height: '100%' }}>\n          <Grid item xs={6}>\n            <Suspense>\n              <ManageGroupModal\n                {...props}\n                closeModal={() => {\n                  setDialog('');\n                }}\n              />\n            </Suspense>\n          </Grid>\n        </Grid>\n      </Box>\n    </Dialog>\n\n    <Box sx={{ bgcolor: 'primary.dark' }}>\n      <Grid container sx={{ placeItems: { xs: 'start', sm: 'center' }, minHeight: '100vh', height: '100%' }}>\n\n        <Grid p={4} item xs={12} sm={8} md={6}>\n          <Grid container spacing={2}>\n            <Grid item xs={4}>\n              <img src={Icon} alt=\"kbt-icon\" width=\"100%\" />\n            </Grid>\n\n            <Grid item xs={8}>\n              <Typography color=\"primary\" variant=\"h5\">Welcome to</Typography>\n              <Typography color=\"primary\" variant=\"h2\" component=\"h1\"><div>Awayto.</div><div>Exchange</div></Typography>\n            </Grid>\n\n            <Grid item xs={12}>\n              <Typography color=\"primary\" variant=\"body1\">It's a pleasure to welcome you! This application is designed to enhance the connection between an organization and its members. We provide a general platform, packed with functionality, which allows groups of all kinds to support different services related to their domain. Our users enjoy a great many niceties, such as a sleek desktop and mobile user interface, customizable features and profile, and even a hint of artificial intelligence!</Typography>\n            </Grid>\n\n            <Grid item xs={12}>\n              <Typography color=\"primary\" variant=\"body1\"><strong>AI:</strong> To get started, we need to know whether you're here to create a group for your organization, or join an existing group. From there, you'll be able to set up your services, create any necessary reporting forms and start scheduling appointments with your clients. You'll be meeting in one of our virtual sessions in no time!</Typography>\n            </Grid>\n\n          </Grid>\n        </Grid>\n\n        <Grid item xs={12} sm={4} md={6}>\n          <Grid container p={4} spacing={4}>\n\n            <Grid item xs={12}>\n              <Typography color=\"primary\" variant=\"h4\" component=\"h2\">Get Started!</Typography>\n\n              <Typography color=\"primary\" variant=\"body1\">We're honored to be able to assist in your efforts, and ready to help you streamline your processes. Let's get started!</Typography>\n            </Grid>\n\n            <Grid item xs={12}>\n              <Button fullWidth variant=\"contained\" color=\"secondary\" onClick={() => setDialog('create_group')}>Create a group</Button>\n            </Grid>\n\n            <Grid item xs={12}>\n              <Grid container direction=\"row\" alignItems=\"center\" spacing={2}>\n                <Grid item xs={1} />\n                <Grid item flexGrow={1}>\n                  <Divider />\n                </Grid>\n                <Grid item>\n                  <Typography variant=\"button\" color=\"primary\">Or</Typography>\n                </Grid>\n                <Grid item flexGrow={1}>\n                  <Divider />\n                </Grid>\n                <Grid item xs={1} />\n              </Grid>\n            </Grid>\n\n            <Grid item xs={12}>\n              <TextField\n                fullWidth\n                value={groupCode}\n                onChange={e => setGroupCode(e.target.value)}\n                label=\"Group Code\"\n              />\n            </Grid>\n\n            <Grid item xs={12}>\n              <Button fullWidth variant=\"contained\" color=\"secondary\" onClick={joinGroupCb}>Join a Group</Button>\n            </Grid>\n          </Grid>\n        </Grid>\n      </Grid>\n    </Box>\n  </>\n}"}
{"prompt":{"fileName":"PickTheme.tsx","defaultExportName":"PickTheme","hooks":["useStyles","useUtil"],"childComponents":[]},"result":"export function PickTheme (props: IProps): JSX.Element {\r\n\r\n  const { setTheme } = useUtil()\r\n\r\n  const { showTitle } = props;\r\n  const classes = useStyles();\r\n\r\n  const edit = (e: React.SyntheticEvent) => {\r\n    setTheme({ theme: e.currentTarget.id as PaletteMode });\r\n  };\r\n\r\n  return <>\r\n    <Grid container alignItems=\"center\">\r\n      {showTitle ? <Grid item><Typography>Theme</Typography></Grid> : <></>}\r\n      <Grid item onClick={edit} id=\"dark\"><Box bgcolor=\"gray\" className={classes.colorBox} /></Grid>\r\n      <Grid item onClick={edit} id=\"light\"><Box bgcolor=\"white\" className={classes.colorBox} /></Grid>\r\n      {/* <Grid item onClick={edit} id=\"blue\"><Box bgcolor=\"deepskyblue\" className={classes.colorBox} /></Grid> */}\r\n    </Grid>\r\n  </>\r\n}"}
{"prompt":{"fileName":"SelectLookup.tsx","defaultExportName":"SelectLookup","hooks":["MutationTrigger","SiteMutation","useUtil"],"childComponents":[]},"result":"export function SelectLookup({ lookupChange, disabled = false, invalidValues = [], attachAction, attachName, refetchAction, parentUuidName, parentUuid, lookups, lookupName, helperText, lookupValue, multiple = false, noEmptyValue = false, createAction, deleteAction, deleteActionIdentifier }: IProps): JSX.Element {\n  \n  const { setSnack } = useUtil();\n\n  const [addingNew, setAddingNew] = useState<boolean | undefined>();\n  const [newLookup, setNewLookup] = useState({ name: '' } as ILookup);\n  const [lookupUpdater, setLookupUpdater] = useState(null as unknown as string);\n\n  if (!lookupName || !lookupChange) return <Grid container justifyContent=\"center\"><CircularProgress /></Grid>;\n\n  const refresh = () => {\n    setAddingNew(false);\n    setNewLookup({ name: '' } as ILookup)\n\n    if (refetchAction && parentUuidName && parentUuid) {\n      refetchAction({ [parentUuidName]: parentUuid });\n    }\n  }\n\n  const handleSubmit = useCallback(() => {\n    if (invalidValues.includes(newLookup.name)) {\n      setSnack({ snackType: 'warning', snackOn: 'That value cannot be used here.' })\n      return;\n    }\n\n    setLookupUpdater(newLookup.name);\n    if (createAction) {\n      createAction({ name: newLookup.name }).unwrap().then(res => {\n        const { id: lookupId } = res;\n        if (attachAction && lookupId && parentUuid && parentUuidName && attachName) {\n          attachAction({ [parentUuidName]: parentUuid, [attachName]: lookupId }).unwrap().then(() => refresh()).catch(console.error);\n        } else {\n          refresh();\n        }\n      }).catch(console.error);\n    }\n  }, [newLookup, createAction, attachAction, attachName, parentUuid, parentUuidName]);\n\n  useEffect(() => {\n    if (lookupValue && lookups?.length && isStringArray(lookupValue) && lookupUpdater) {\n      const updater = lookups.find(l => l.name === lookupUpdater);\n      if (updater?.id) {\n        lookupChange([ ...lookupValue, updater.id ]);\n        setLookupUpdater('');\n      }\n    }\n  }, [lookups, lookupValue, lookupUpdater]);\n\n  useEffect(() => {\n    if (lookupValue && lookups && lookups?.length && noEmptyValue && !lookupValue?.length) {\n      const firstLookup = lookups.at(0) as Required<ILookup>;\n      lookupChange(isStringArray(lookupValue) ? [firstLookup.id] : firstLookup.id);\n    }\n  }, [lookups, lookupValue, noEmptyValue]);\n\n  // useEffect(() => {\n  //   if (defaultValue && !lookupValue) {\n  //     lookupChange(defaultValue);\n  //   }\n  // }, [defaultValue, lookupValue]);\n\n  return (addingNew ?\n    <TextField\n      autoFocus\n      fullWidth\n      label={`New ${lookupName}`}\n      value={newLookup.name}\n      onChange={e => {\n        setNewLookup({ name: e.target.value } as ILookup)\n      }}\n      onKeyDown={(e) => {\n        ('Enter' === e.key && newLookup.name) && handleSubmit();\n      }}\n      InputProps={{\n        endAdornment: (\n          <InputAdornment position=\"end\">\n            <Box mb={2}>\n              <IconButton aria-label=\"close new record\" onClick={() => {\n                setAddingNew(false);\n                setNewLookup({ ...newLookup, name: '' });\n              }}>\n                <ClearIcon style={{ color: 'red' }} />\n              </IconButton>\n              <IconButton aria-label=\"create new record\" onClick={() => {\n                newLookup.name ? handleSubmit() : void setSnack({ snackOn: 'Provide a name for the record.', snackType: 'info' });\n              }}>\n                <CheckIcon style={{ color: 'green' }} />\n              </IconButton>\n            </Box>\n          </InputAdornment>\n        ),\n      }}\n    /> : <TextField\n      select\n      disabled={disabled}\n      autoFocus={!!lookupUpdater}\n      id={`${lookupName}-lookup-selection`}\n      fullWidth\n      helperText={helperText || ''}\n      label={`${lookupName}s`}\n      onChange={e => {\n        const { value } = e.target as { value: string | string[] };\n        if (isStringArray(value) && value.indexOf('new') > -1) {\n        } else {\n          lookupChange(value);\n        }\n      }}\n      value={lookupValue}\n      SelectProps={{\n        multiple,\n        renderValue: selected => {\n          if (isStringArray(selected as string[])) \n            return (selected as string[]).map(v => lookups?.find(r => r.id === v)?.name ).join(', ')\n          \n          return lookups?.find(r => r.id === selected)?.name as string\n        }\n      }}\n      \n    >\n      {!multiple && !noEmptyValue && <MenuItem value=\"\">No selection</MenuItem>}\n      {createAction && <MenuItem value=\"new\" onClick={e => {\n        e.preventDefault();\n        setAddingNew(true);\n      }}>Add a {lookupName} to this list</MenuItem>}\n      {!lookups?.length && <MenuItem disabled>You have no pre-defined {lookupName}s.<br /> Click the button above to add some.</MenuItem>}\n      {lookups?.length ? lookups.map((lookup, i) => (\n        <MenuItem key={i} style={{ display: 'flex' }} value={lookup.id}>\n          <span style={{ flex: '1' }}>{lookup.name}</span>\n          {refetchAction && deleteAction && <ClearIcon style={{ color: 'red', marginRight: '8px' }} onClick={e => {\n            e.stopPropagation();\n            if (isStringArray(lookupValue) && lookup.id) {\n              lookupChange([...lookupValue.filter(l => l !== lookup.id)]);\n            } else if (lookupValue === lookup.id) {\n              lookupChange('');\n            }\n\n            if (parentUuidName && parentUuid && attachName) {\n              deleteAction({ [parentUuidName]: parentUuid, [attachName]: lookup.id }).unwrap().then(() => refresh()).catch(console.error);\n            }\n\n            if (deleteActionIdentifier) {\n              deleteAction({ [deleteActionIdentifier]: lookup.id }).unwrap().then(() => refresh()).catch(console.error);\n            }\n\n          }} />}\n        </MenuItem>\n      )) : []}\n    </TextField>\n  )\n}"}
{"prompt":{"fileName":"Sidebar.tsx","defaultExportName":"Sidebar","hooks":["useSecure","useStyles"],"childComponents":[]},"result":"export function Sidebar(): JSX.Element {\r\n  const hasRole = useSecure();\r\n  const navigate = useNavigate();\r\n  const classes = useStyles();\r\n  const location = useLocation();\r\n\r\n  return <Grid container style={{ height: '100vh' }} alignContent=\"space-between\">\r\n    <Grid item xs={12} style={{ marginTop: '20px' }}>\r\n      <Grid container justifyContent=\"center\">\r\n        <Button onClick={() => navigate('/')}>\r\n          <img src={Icon} alt=\"kbt-icon\" className={classes.logo} />\r\n        </Button>\r\n      </Grid>\r\n      <List component=\"nav\">\r\n        <ListItem className={classes.menuIcon} onClick={() => navigate('/')} button key={'home'}>\r\n          <ListItemIcon><GroupIcon color={location.pathname === '/' ? \"secondary\" : \"primary\"} /></ListItemIcon>\r\n          <ListItemText classes={{ primary: classes.menuText }}>Home</ListItemText>\r\n        </ListItem>\r\n        <ListItem className={classes.menuIcon} onClick={() => navigate('/exchange')} button key={'exchange'}>\r\n          <ListItemIcon><TtyIcon color={location.pathname === '/exchange' ? \"secondary\" : \"primary\"} /></ListItemIcon>\r\n          <ListItemText classes={{ primary: classes.menuText }}>Exchange</ListItemText>\r\n        </ListItem>\r\n        {hasRole([SiteRoles.APP_GROUP_SERVICES]) && <ListItem className={classes.menuIcon} onClick={() => navigate('/service')} button key={'service'}>\r\n          <ListItemIcon><BusinessIcon color={location.pathname === '/service' ? \"secondary\" : \"primary\"} /></ListItemIcon>\r\n          <ListItemText classes={{ primary: classes.menuText }}>Service</ListItemText>\r\n        </ListItem>}\r\n        {hasRole([SiteRoles.APP_GROUP_SCHEDULES]) && <ListItem className={classes.menuIcon} onClick={() => navigate('/schedule')} button key={'schedule'}>\r\n          <ListItemIcon><EventNoteIcon color={location.pathname === '/schedule' ? \"secondary\" : \"primary\"} /></ListItemIcon>\r\n          <ListItemText classes={{ primary: classes.menuText }}>Schedule</ListItemText>\r\n        </ListItem>}\r\n        {hasRole([SiteRoles.APP_GROUP_BOOKINGS]) && <ListItem className={classes.menuIcon} onClick={() => navigate('/quote/request')} button key={'quote/request'}>\r\n          <ListItemIcon><MoreTimeIcon color={location.pathname === '/quote/request' ? \"secondary\" : \"primary\"} /></ListItemIcon>\r\n          <ListItemText classes={{ primary: classes.menuText }}>Request</ListItemText>\r\n        </ListItem>}\r\n      </List>\r\n    </Grid>\r\n    <Grid item xs={12}>\r\n      <List component=\"nav\">\r\n        <ListItem className={classes.menuIcon} onClick={() => navigate('/profile')} button key={'profile'}>\r\n          <ListItemIcon><AccountBoxIcon color={location.pathname === '/profile' ? \"secondary\" : \"primary\"} /></ListItemIcon>\r\n          <ListItemText classes={{ primary: classes.menuText }}>Profile</ListItemText>\r\n        </ListItem>\r\n        <ListItem className={classes.menuIcon} onClick={async () => {\r\n          await keycloak.logout({ redirectUri: `https://${process.env.REACT_APP_LAND_HOSTNAME as string}/` });\r\n        }} button key={'logout'}>\r\n          <ListItemIcon><ExitToAppIcon color=\"primary\" /></ListItemIcon>\r\n          <ListItemText classes={{ primary: classes.menuText }}>Logout</ListItemText>\r\n        </ListItem>\r\n      </List>\r\n    </Grid>\r\n  </Grid>\r\n}"}
{"prompt":{"fileName":"Topbar.tsx","defaultExportName":"Topbar","hooks":["useSecure","useComponents","sh","useAppSelector","useUtil"],"childComponents":[]},"result":"export function Topbar(props: IProps): JSX.Element {\n\n  const navigate = useNavigate();\n  const hasRole = useSecure();\n  const { FeedbackMenu, PendingQuotesMenu, PendingQuotesProvider, UpcomingBookingsMenu } = useComponents();\n  const location = useLocation();\n\n  const { theme } = useAppSelector(state => state.util);\n  const { setTheme } = useUtil();\n\n  const { data: profile } = sh.useGetUserProfileDetailsQuery();\n\n  const pendingQuotes = useMemo(() => Object.values(profile?.quotes || {}), [profile]);\n  const upcomingBookings = useMemo(() => Object.values(profile?.bookings || {}), [profile]);\n\n  const mobileMenuId = 'mobile-app-bar-menu';\n  const pendingQuotesMenuId = 'pending-requests-menu';\n  const feedbackMenuId = 'feedback-menu';\n  const upcomingBookingsMenuId = 'upcoming-bookings-menu';\n\n  const [mobileMoreAnchorEl, setMobileMoreAnchorEl] = useState<null | HTMLElement>(null);\n  const [pendingQuotesAnchorEl, setPendingQuotesAnchorEl] = useState<null | HTMLElement>(null);\n  const [feedbackAnchorEl, setFeedbackAnchorEl] = useState<null | HTMLElement>(null);\n  const [upcomingBookingsAnchorEl, setUpcomingBookingsAnchorEl] = useState<null | HTMLElement>(null);\n\n  const isMobileMenuOpen = Boolean(mobileMoreAnchorEl);\n  const isPendingQuotesOpen = Boolean(pendingQuotesAnchorEl);\n  const isFeedbackOpen = Boolean(feedbackAnchorEl);\n  const isUpcomingBookingsOpen = Boolean(upcomingBookingsAnchorEl);\n\n  const handleMenuClose = () => {\n    setUpcomingBookingsAnchorEl(null);\n    setPendingQuotesAnchorEl(null);\n    setFeedbackAnchorEl(null);\n    setMobileMoreAnchorEl(null)\n  };\n\n  const handleNavAndClose = (path: string) => {\n    handleMenuClose();\n    navigate(path);\n  };\n\n  return <Grid xs={12} container>\n    <Grid sx={{ display:{ xs: 'flex', md: 'none' } }}>\n      <Tooltip title=\"Menu\">\n        <Button\n          aria-label=\"show mobile main menu\"\n          aria-controls={mobileMenuId}\n          aria-haspopup=\"true\"\n          onClick={e => setMobileMoreAnchorEl(e.currentTarget)}\n        >\n          <img src={Icon} alt=\"kbt-icon\" width={48} />\n        </Button>\n      </Tooltip>\n    </Grid>\n    <Grid container sx={{ flexGrow: 1, justifyContent: 'right', alignItems: 'center' }}>\n      <Grid>\n        <Tooltip title=\"View Appointments\">\n          <IconButton\n            disableRipple\n            color=\"primary\"\n            aria-label={`show ${upcomingBookings.length} upcoming appointments`}\n            aria-controls={upcomingBookingsMenuId}\n            aria-haspopup=\"true\"\n            onClick={e => setUpcomingBookingsAnchorEl(e.currentTarget)}\n          >\n            <Badge badgeContent={upcomingBookings.length} color=\"error\">\n              <ThreePIcon sx={{ display:{ xs: 'flex', md: 'none' } }} />\n              <Typography variant=\"overline\" sx={{ display: { xs: 'none', md: 'flex' } }}>View Appointments</Typography>\n            </Badge>\n          </IconButton>\n        </Tooltip>\n      </Grid>\n      <Grid>\n        <Tooltip title=\"Approve Requests\">\n          <IconButton\n            disableRipple\n            color=\"primary\"\n            aria-label={`show ${pendingQuotes.length} pending requests`}\n            aria-controls={pendingQuotesMenuId}\n            aria-haspopup=\"true\"\n            onClick={e => setPendingQuotesAnchorEl(e.currentTarget)}\n          >\n            <Badge badgeContent={pendingQuotes.length} color=\"error\">\n              <ApprovalIcon sx={{ display:{ xs: 'flex', md: 'none' } }} />\n              <Typography variant=\"overline\" sx={{ display: { xs: 'none', md: 'flex' } }}>Approve Requests</Typography>\n            </Badge>\n          </IconButton>\n        </Tooltip>\n      </Grid>\n      <Grid>\n        <Tooltip title=\"Give Feedback\">\n          <IconButton\n            disableRipple\n            color=\"primary\"\n            aria-label={`give group feedback`}\n            aria-controls={feedbackMenuId}\n            aria-haspopup=\"true\"\n            onClick={e => setFeedbackAnchorEl(e.currentTarget)}\n          >\n            <CampaignIcon sx={{ display:{ xs: 'flex', md: 'none' } }} />\n            <Typography variant=\"overline\" sx={{ display: { xs: 'none', md: 'flex' } }}>Give Feedback</Typography>\n          </IconButton>\n        </Tooltip>\n      </Grid>\n    </Grid>\n\n    {/** MOBILE MENU */}\n    <Menu\n      anchorEl={mobileMoreAnchorEl}\n      anchorOrigin={{\n        vertical: 'bottom',\n        horizontal: 'left',\n      }}\n      id={mobileMenuId}\n      keepMounted\n      transformOrigin={{\n        vertical: 'top',\n        horizontal: 'right',\n      }}\n      open={isMobileMenuOpen}\n      onClose={() => setMobileMoreAnchorEl(null)}\n    >\n      <Box sx={{ width: 250 }}>\n        <MenuList>\n\n          <MenuItem aria-label=\"navigate to home\" onClick={() => handleNavAndClose('/')}>\n            <ListItemIcon><GroupIcon color={location.pathname === '/' ? \"secondary\" : \"primary\"} /></ListItemIcon>\n            <ListItemText>Home</ListItemText>\n          </MenuItem>\n\n          <MenuItem aria-label=\"navigate to profile\" onClick={() => handleNavAndClose('/profile')}>\n            <ListItemIcon><AccountCircleIcon color={location.pathname === '/profile' ? \"secondary\" : \"primary\"} /></ListItemIcon>\n            <ListItemText>Profile</ListItemText>\n          </MenuItem>\n\n          <MenuItem aria-label=\"switch between dark and light theme\">\n            <ListItemText>\n              Dark\n              <Switch\n                value={theme !== 'dark'}\n                onChange={e => setTheme({ theme: (e.target.checked ? 'light' : 'dark') as PaletteMode })}\n              />\n              Light\n            </ListItemText>\n          </MenuItem>\n\n          <Divider />\n\n          <MenuItem aria-label=\"navigate to exchange\" onClick={() => handleNavAndClose('/exchange')}>\n            <ListItemIcon><TtyIcon color={location.pathname === '/exchange' ? \"secondary\" : \"primary\"} /></ListItemIcon>\n            <ListItemText>Exchange</ListItemText>\n          </MenuItem>\n\n          <MenuItem hidden={!hasRole([SiteRoles.APP_GROUP_SERVICES])} aria-label=\"navigate to create service\" onClick={() => handleNavAndClose('/service')}>\n            <ListItemIcon><BusinessIcon color={location.pathname === '/service' ? \"secondary\" : \"primary\"} /></ListItemIcon>\n            <ListItemText>Service</ListItemText>\n          </MenuItem>\n\n          <MenuItem hidden={!hasRole([SiteRoles.APP_GROUP_SCHEDULES])} aria-label=\"navigate to create schedule\" onClick={() => handleNavAndClose('/schedule')}>\n            <ListItemIcon><EventNoteIcon color={location.pathname === '/schedule' ? \"secondary\" : \"primary\"} /></ListItemIcon>\n            <ListItemText>Schedule</ListItemText>\n          </MenuItem>\n\n          <MenuItem hidden={!hasRole([SiteRoles.APP_GROUP_BOOKINGS])} aria-label=\"navigate to create request\" onClick={() => handleNavAndClose('/quote/request')}>\n            <ListItemIcon><MoreTimeIcon color={location.pathname === '/quote/request' ? \"secondary\" : \"primary\"} /></ListItemIcon>\n            <ListItemText>Request</ListItemText>\n          </MenuItem>\n\n          <Divider />\n\n          <MenuItem aria-label=\"logout of the application\" onClick={async () => {\n            await keycloak.logout({\n              redirectUri: `https://${process.env.REACT_APP_LAND_HOSTNAME as string}/`\n            });\n          }}>\n            <ListItemIcon><LogoutIcon color=\"error\" /></ListItemIcon>\n            <ListItemText>Logout</ListItemText>\n          </MenuItem>\n\n        </MenuList>\n      </Box>\n    </Menu>\n\n    <UpcomingBookingsMenu\n      {...props}\n      upcomingBookingsAnchorEl={upcomingBookingsAnchorEl}\n      upcomingBookingsMenuId={upcomingBookingsMenuId}\n      isUpcomingBookingsOpen={isUpcomingBookingsOpen}\n      handleMenuClose={handleMenuClose}\n    />\n\n    {/** PENDING REQUESTS MENU */}\n    <PendingQuotesProvider>\n      <PendingQuotesMenu\n        {...props}\n        pendingQuotesAnchorEl={pendingQuotesAnchorEl}\n        pendingQuotesMenuId={pendingQuotesMenuId}\n        isPendingQuotesOpen={isPendingQuotesOpen}\n        handleMenuClose={handleMenuClose}\n      />\n    </PendingQuotesProvider>\n\n    <FeedbackMenu\n      feedbackAnchorEl={feedbackAnchorEl}\n      feedbackMenuId={feedbackMenuId}\n      isFeedbackOpen={isFeedbackOpen}\n      handleMenuClose={handleMenuClose}\n    />\n  </Grid>;\n}"}
{"prompt":{"fileName":"Video.tsx","defaultExportName":"Video","hooks":[],"childComponents":[]},"result":"export function Video({ srcObject, autoPlay = false }: VideoHTMLAttributes<HTMLVideoElement> & IProps): JSX.Element {\n  const refVideo = useCallback((node: HTMLVideoElement) => {\n    if (node && srcObject) node.srcObject = srcObject;\n  }, [srcObject])\n\n  return <video style={{ width: '100%' }} controls { ...{ autoPlay }} ref={refVideo} />\n}"}
{"prompt":{"fileName":"Exchange.tsx","defaultExportName":"Exchange","hooks":[],"childComponents":[]},"result":"export function Exchange(): JSX.Element {\r\n  // Destructure required properties and methods from the ExchangeContext\r\n  const {\r\n    chatLog,\r\n    messagesEndRef,\r\n    canStartStop,\r\n    localStreamElement,\r\n    senderStreamsElements,\r\n    submitMessageForm,\r\n    setLocalStreamAndBroadcast,\r\n    leaveCall\r\n  } = useContext(ExchangeContext) as ExchangeContextType;\r\n\r\n  // Get the theme for styling\r\n  const theme = useTheme();\r\n\r\n  // Manage the state of the chat interface (open or closed)\r\n  const [chatOpen, setChatOpen] = useState(true);\r\n\r\n  // Render the main component with video and chat interfaces\r\n  return <>\r\n    <Card>\r\n      <CardActions>\r\n        <Button onClick={() => setChatOpen(!chatOpen)} type=\"submit\" color=\"primary\"><ChatBubble /></Button>\r\n        {\r\n          !localStreamElement ? (\r\n            <>\r\n              <form onSubmit={e => {\r\n                e.preventDefault();\r\n                setLocalStreamAndBroadcast(true);\r\n              }}>\r\n                <Button disabled={'start' !== canStartStop} type=\"submit\" color=\"primary\"><Videocam color=\"primary\" /></Button>\r\n              </form>\r\n\r\n              <form onSubmit={e => {\r\n                e.preventDefault();\r\n                setLocalStreamAndBroadcast(false);\r\n              }}>\r\n                <Button disabled={'start' !== canStartStop} type=\"submit\" color=\"primary\"><Call color=\"primary\" /></Button>\r\n              </form>\r\n            </>\r\n          ) : (\r\n            <form onSubmit={leaveCall}>\r\n              <Button type=\"submit\" color=\"primary\">Leave Call</Button>\r\n            </form>\r\n          )\r\n        }\r\n      </CardActions>\r\n      <CardContent>\r\n        <Grid container direction=\"row\" justifyContent=\"space-evenly\">\r\n          <Grid item xs={12} md={5} style={{ height: '70vh', padding: '20px', backgroundColor: theme.palette.primary.dark }}>\r\n            document placeholder here\r\n          </Grid>\r\n          <Grid item xs={12} md={5}>\r\n            <Grid container direction=\"column\" style={{ height: '70vh', display: 'flex', flexWrap: 'nowrap' }}>\r\n              {localStreamElement && <Grid item xs={12} style={{ backgroundColor: 'black', position: 'relative', maxHeight: '390px', display: 'flex', flex: '1' }}>\r\n                <Grid container justifyContent=\"flex-end\" style={{ position: 'absolute' }}>\r\n                  {localStreamElement}\r\n                </Grid>\r\n                {!!Object.keys(senderStreamsElements).length && senderStreamsElements}\r\n              </Grid>}\r\n\r\n              {/* ---------- Chat ---------- */}\r\n              <Grid item xs={12} hidden={!chatOpen} style={{ height: '100%', flex: '1' }}>\r\n                <Grid container direction=\"column\" style={{ height: '100%' }}>\r\n                  <Grid item style={{ flex: '1', overflow: 'auto', color: theme.palette.primary.contrastText, backgroundColor: theme.palette.primary.dark, padding: '0 25px' }}>\r\n                    <Grid container direction=\"column\">\r\n                      {chatLog}\r\n                    </Grid>\r\n                    <Grid item ref={messagesEndRef} />\r\n                  </Grid>\r\n\r\n                  <Grid item style={{ backgroundColor: theme.palette.primary.dark, padding: '25px' }}>\r\n                    {submitMessageForm}\r\n                  </Grid>\r\n                </Grid>\r\n              </Grid>\r\n\r\n            </Grid>\r\n          </Grid>\r\n        </Grid>\r\n\r\n      </CardContent>\r\n    </Card>\r\n  </>;\r\n}"}
{"prompt":{"fileName":"ExchangeProvider.tsx","defaultExportName":"ExchangeProvider","hooks":["useComponents","useUtil"],"childComponents":[]},"result":"export function ExchangeProvider({ children }: IProps): JSX.Element {\n\n  const localId = `test-${(new Date).getTime()}`;\n\n  const { setSnack } = useUtil();\n\n  const { Video } = useComponents();\n\n  const socket = useRef<WebSocket>();\n  const speechRecognizer = useRef<SpeechRecognition>();\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  const [textMessage, setTextMessage] = useState('');\n  const [messages, setMessages] = useState<string[]>([]);\n  const [pendingMessages, setPendingMessages] = useState<string[]>([]);\n\n\n  const [localStream, setLocalStream] = useState<MediaStream>();\n  const [canStartStop, setCanStartStop] = useState('start');\n  const [senderStreams, setSenderStreams] = useState<SenderStreams>({});\n\n  const [pendingSDPs, setPendingSDPs] = useState<{ [prop: string]: RTCSessionDescriptionInit }>({});\n  const [pendingICEs, setPendingICEs] = useState<{ [prop: string]: RTCIceCandidateInit }>({});\n\n  const trackStream = (mediaStream: MediaStream) => {\n\n    const mediaRecorder = new MediaRecorder(mediaStream, {\n      mimeType: 'audio/webm'\n    });\n    const chunks: BlobPart[] = [];\n\n    // Listen for dataavailable event to obtain the recorded data\n    mediaRecorder.addEventListener('dataavailable', (event: BlobEvent) => {\n      chunks.push(event.data);\n    });\n\n    // Set the recording duration to 10 seconds\n    const RECORDING_DURATION_MS = 10000;\n    mediaRecorder.start(RECORDING_DURATION_MS);\n\n    // Speech recognition setup\n    speechRecognizer.current = new window.webkitSpeechRecognition();\n    speechRecognizer.current.maxAlternatives = 5;\n    speechRecognizer.current.continuous = true;\n    speechRecognizer.current.interimResults = true;\n    speechRecognizer.current.lang = 'en-US';\n\n    // const isSpeaking = false;\n    // const silenceStartTime = 0;\n\n    // Handle speech recognition results\n    speechRecognizer.current.addEventListener('result', (event: SpeechRecognitionEvent) => {\n      const transcript = Array.from(event.results)\n        .map(result => result[0].transcript)\n        .join('');\n      const lastResult = event.results[event.results.length - 1];\n      // console.log(lastResult)\n      const isFinal = lastResult.isFinal;\n      // const confidence = lastResult[0].confidence;\n      // const isSilence = lastResult[0].transcript === '';\n\n      // console.log({ transcript })\n\n      // Check if the user is speaking or not\n      if (isFinal) {\n        sendMessage(transcript);\n      }\n    });\n\n    speechRecognizer.current.start();\n  }\n\n  const setLocalStreamAndBroadcast = useCallback(async (video: boolean): Promise<void> => {\n    try {\n      if (socket.current && !localStream && localId && 'start' === canStartStop) {\n        setCanStartStop('');\n\n        const callOptions: MediaStreamConstraints = {\n          audio: {\n            autoGainControl: true\n          }\n        };\n\n        if (video) {\n          callOptions.video = {\n            width: 520,\n            height: 390,\n            frameRate: { max: 30 }\n          };\n        }\n\n        const mediaStream = await navigator.mediaDevices.getUserMedia(callOptions);\n        trackStream(mediaStream);\n        setLocalStream(mediaStream);\n        socket.current.send(JSON.stringify({\n          sender: localId,\n          type: 'join-call',\n          formats: Object.keys(callOptions),\n          rtc: true\n        }));\n        setCanStartStop('stop');\n      }\n    } catch (error) {\n      setSnack({ snackOn: (error as DOMException).message, snackType: 'error' });\n    }\n  }, [socket.current, localStream, canStartStop, localId]);\n\n  const submitMessage = useCallback((e?: KeyboardEvent | FormEvent): void => {\n    e && e.preventDefault();\n    if (!socket.current || !textMessage) return;\n    try {\n      sendMessage(textMessage);\n    } catch (error) {\n      setSnack({ snackOn: error as string });\n    }\n  }, [socket.current, messages, textMessage]);\n\n  const sendMessage = function(message: string) {\n    socket.current?.send(JSON.stringify({\n      sender: localId,\n      type: 'text',\n      message: message\n    }));\n    setTextMessage('');\n    // setMessages([...messages, textMessage]);\n  }\n\n  const messageHandler = useCallback(async (sockMsg: MessageEvent<{ text(): Promise<string> }>): Promise<void> => {\n    // console.log('setting handler')\n    if (!socket.current) return;\n    const { sender, type, formats, target, sdp, ice, message, rtc } = JSON.parse(await sockMsg.data.text()) as SocketResponseMessageAttributes;\n\n    if (sender === localId || (target !== localId && !(rtc || sdp || ice || message))) {\n      return;\n    }\n\n    if ('text' === type) {\n      setPendingMessages([message]);\n    } else if (['join-call', 'peer-response'].includes(type)) {\n      // Parties to an incoming caller's 'join-call' will see this, and then notify the caller that they exist in return\n      // The caller gets a party member's 'peer-response', and sets them up in return\n      if (!localStream && formats) {\n        setPendingMessages([`${sender} wants to start a ${formats.indexOf('video') > -1 ? 'video' : 'voice'} call.`])\n      }\n\n      setSenderStreams(Object.assign({}, senderStreams, {\n        [sender]: {\n          peerResponse: 'peer-response' === type ? true : false\n        }\n      }));\n    } else if (sdp) {\n      setPendingSDPs(Object.assign({}, pendingSDPs, {\n        [sender]: sdp\n      }));\n    } else if (ice) {\n      setPendingICEs(Object.assign({}, pendingICEs, {\n        [sender]: ice\n      }));\n    }\n  }, [socket.current, messages, senderStreams]);\n\n\n  function gotIceCandidate(event: RTCPeerConnectionIceEvent, sender: string) {\n    if (socket.current && event.candidate !== null) {\n      socket.current.send(JSON.stringify({\n        ice: event.candidate,\n        sender: localId,\n        target: sender,\n        rtc: true\n      }));\n    }\n  }\n\n  const gotRemoteStream = useCallback((event: RTCTrackEvent, id: string, sender: Sender) => {\n    sender.mediaStream = sender.mediaStream ? sender.mediaStream : new MediaStream();\n    sender.mediaStream.addTrack(event.track);\n    setSenderStreams(Object.assign({}, senderStreams, { [id]: sender }));\n  }, [senderStreams]);\n\n  const checkPeerDisconnect = useCallback((id: string, sender: Sender) => {\n    if (sender.pc) {\n      if (['failed', 'closed', 'disconnected'].includes(sender.pc.iceConnectionState)) {\n        const streams = { ...senderStreams };\n        delete streams[id];\n        setSenderStreams(streams);\n      }\n    }\n  }, [senderStreams]);\n\n  const localStreamRef = useCallback((node: HTMLVideoElement) => {\n    if (node && !node.srcObject && localStream) {\n      node.srcObject = localStream\n    }\n  }, [localStream]);\n\n  useEffect(() => {\n    async function go() {\n      try {\n        if (!keycloak.token) return;\n        // Make a type for api\n        await fetch(`https://${location.hostname}/api/ticket/`, {\n          headers: {\n            Authorization: keycloak.token\n          }\n        });\n        socket.current = new WebSocket(`wss://${location.hostname}/sock/${localId}`);\n      } catch (error) {\n        // console.log({ goterror: error });\n        setSnack({ snackOn: error as string, snackType: 'error' });\n      }\n    }\n    void go();\n  }, []);\n\n  useEffect(() => {\n    if (socket.current) {\n\n      const sock = socket.current;\n\n      if (!sock) return;\n\n      sock.addEventListener('error', console.log);\n      sock.addEventListener('open', heartbeat);\n      sock.addEventListener('ping', heartbeat);\n      sock.addEventListener('close', clearbeat);\n      sock.addEventListener('message', e => void messageHandler(e));\n\n      return () => {\n        sock.close();\n        sock.removeEventListener('error', console.log);\n        sock.removeEventListener('open', heartbeat);\n        sock.removeEventListener('ping', heartbeat);\n        sock.removeEventListener('close', clearbeat);\n        sock.removeEventListener('message', e => void messageHandler(e));\n      }\n    }\n  }, [socket.current]);\n\n  // Handle incoming peer streams\n  useEffect(() => {\n    async function go() {\n      const senders = Object.keys(senderStreams).filter(sender => !senderStreams[sender].pc);\n      const startedSenders: SenderStreams = {};\n\n      // console.log(JSON.stringify(senders));\n\n      await asyncForEach(senders, async (senderId) => {\n        const startedSender = senderStreams[senderId];\n\n        if (socket.current) {\n          // startedSender.pc = await generatePeerConnection(sender, startedSender.peerResponse);\n\n          // console.log('generating peer');\n          startedSender.pc = new RTCPeerConnection(peerConnectionConfig)\n          startedSender.pc.onicecandidate = event => gotIceCandidate(event, senderId);\n          startedSender.pc.ontrack = event => gotRemoteStream(event, senderId, startedSender);\n          startedSender.pc.oniceconnectionstatechange = () => checkPeerDisconnect(senderId, startedSender);\n          if (localStream) {\n            // console.log('sending local stream to peers');\n            const tracks = localStream.getTracks();\n            tracks.forEach(track => startedSender.pc?.addTrack(track));\n          }\n\n          if (startedSender.peerResponse && socket.current) {\n            // console.log('received peer response');\n            const description = await startedSender.pc.createOffer();\n            await startedSender.pc.setLocalDescription(description);\n            socket.current.send(JSON.stringify({\n              sdp: startedSender.pc.localDescription,\n              sender: localId,\n              target: senderId,\n              rtc: true\n            }));\n          } else {\n            socket.current.send(JSON.stringify({\n              sender: localId,\n              target: senderId,\n              type: 'peer-response',\n              rtc: true\n            }));\n          }\n\n          startedSenders[senderId] = startedSender;\n        }\n      });\n\n      if (Object.keys(startedSenders).length) {\n        // console.log('started peers', JSON.stringify(startedSenders, null, 2));\n        setSenderStreams(Object.assign({}, senderStreams, startedSenders));\n      }\n    }\n    void go();\n\n  }, [socket.current, senderStreams]);\n\n  // Handle incoming pending SDPs\n  useEffect(() => {\n    if (Object.keys(pendingSDPs).length) {\n\n      async function go() {\n\n        await asyncForEach(Object.keys(pendingSDPs), async sender => {\n          const senderSDP = pendingSDPs[sender];\n          const senderStream = senderStreams[sender];\n\n          if (senderStream && senderStream.pc) {\n            // console.log(\"going to assign\", senderSDP, \" to \", senderStream);\n\n            await senderStream.pc.setRemoteDescription(new RTCSessionDescription(senderSDP));\n\n            if ('offer' === senderSDP.type) {\n              const description = await senderStream.pc.createAnswer();\n              await senderStream.pc.setLocalDescription(description);\n              socket.current && socket.current.send(JSON.stringify({\n                sdp: senderStream.pc.localDescription,\n                sender: localId,\n                target: sender,\n                rtc: true\n              }));\n            }\n          }\n        })\n      }\n      void go();\n\n      setPendingSDPs({});\n    }\n  }, [socket.current, senderStreams, pendingSDPs]);\n\n  // Handle incoming pending ICEs\n  useEffect(() => {\n    if (Object.keys(pendingICEs).length) {\n\n      async function go() {\n\n        await asyncForEach(Object.keys(pendingICEs), async sender => {\n          const senderStream = senderStreams[sender];\n          if (senderStream && senderStream.pc && !['failed', 'closed', 'disconnected'].includes(senderStream.pc.iceConnectionState)) {\n            await senderStream.pc.addIceCandidate(new RTCIceCandidate(pendingICEs[sender]));\n          }\n        });\n      }\n      void go();\n\n      setPendingSDPs({});\n    }\n  }, [socket.current, senderStreams, pendingICEs]);\n\n  // Handle incoming text messages\n  useEffect(() => {\n    if (pendingMessages.length) {\n      setMessages([...messages, ...pendingMessages]);\n      setPendingMessages([]);\n    }\n  }, [pendingMessages, messages]);\n\n  // Chat auto scroll to bottom on new messages\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'auto', block: 'end', inline: 'nearest' })\n  }, [messagesEndRef.current, messages]);\n\n  const pendingQuotesContext = {\n    canStartStop,\n    messagesEndRef,\n    chatLog: useMemo(() => messages.map((msg, i) => <Typography color=\"primary\" style={{ overflowWrap: 'anywhere' }} key={i}>{msg}</Typography>), [messages]),\n    setLocalStreamAndBroadcast,\n    leaveCall() {\n      if (localStream) {\n        localStream.getTracks().forEach(t => {\n          localStream.removeTrack(t);\n          t.stop();\n        });\n        const streams = { ...senderStreams };\n        Object.keys(streams).forEach(sender => {\n          const senderStream = senderStreams[sender];\n          if (senderStream && senderStream.pc) {\n            senderStream.pc.close();\n            senderStream.mediaStream = undefined;\n          }\n        });\n        setSenderStreams(streams);\n        setLocalStream(undefined);\n        setCanStartStop('start');\n        speechRecognizer.current?.stop();\n        speechRecognizer.current = undefined;\n      }\n    },\n    senderStreamsElements: useMemo(() => Object.keys(senderStreams).map(sender => {\n      if (senderStreams[sender].mediaStream) {\n        return <Video key={sender} autoPlay srcObject={senderStreams[sender].mediaStream} />\n      }\n    }), [senderStreams]),\n    localStreamElement: useMemo(() => !localStream ? undefined : <video key={'local-video'} style={{ width: '25%' }} autoPlay controls ref={localStreamRef} />, [localStream, localStreamRef]),\n\n    submitMessage,\n\n    submitMessageForm: useMemo(() => {\n      return <form onSubmit={submitMessage}>\n        <TextField\n          fullWidth\n          multiline\n          id=\"message\"\n          label=\"Message\"\n          value={textMessage}\n          name=\"message\"\n          onChange={e => setTextMessage(e.target.value)}\n          InputProps={{\n            onKeyDown: e => {\n              if ('Enter' === e.key && !e.shiftKey) {\n                submitMessage(e);\n              }\n            },\n            endAdornment: (\n              <InputAdornment position=\"end\">\n                <IconButton type=\"submit\" aria-label=\"toggle password visibility\">\n                  <Send />\n                </IconButton>\n              </InputAdornment>\n            )\n          }}\n        />\n      </form>\n    }, [textMessage])\n  } as ExchangeContextType | null;\n\n  return <>\n    <ExchangeContext.Provider value={pendingQuotesContext}>\n      {children}\n    </ExchangeContext.Provider>\n  </>;\n\n}"}
{"prompt":{"fileName":"Transcript.tsx","defaultExportName":"Transcript","hooks":[],"childComponents":[]},"result":"function Transcript({ messages }: IProps): JSX.Element {\n  if (!messages) return <></>;\n  const sortedTranscript = useMemo(\n    () => messages.sort((a, b) => dayjs(a.timestamp).millisecond() - dayjs(b.timestamp).millisecond()),\n    [messages]\n  );\n\n  const groupedTranscript = useMemo(() => {\n    return sortedTranscript.reduce<Record<string, string[]>>((acc, message) => {\n      const { username, words: msg } = message;\n      if (!acc[username]) acc[username] = [] as string[];\n      acc[username].push(msg);\n      return acc;\n    }, {});\n  }, [sortedTranscript]);\n\n  const messagesLines = useMemo(() => {\n    const lines = [] as Record<string, string>[];\n    sortedTranscript.forEach(({ username, words: wrds, duration }) => {\n      const words = wrds.split(' ');\n      const wordsPerSec = words.length / duration;\n      const numLines = Math.ceil(words.length / (20 / wordsPerSec));\n      const wordsPerLine = Math.ceil(words.length / numLines);\n\n      for (let i = 0; i < numLines; i++) {\n        const lineWords = words.slice(i * wordsPerLine, (i + 1) * wordsPerLine);\n        const lineText = lineWords.join(' ');\n        lines.push({ username, text: lineText });\n      }\n    });\n    return lines;\n  }, [sortedTranscript]);\n\n  return (\n    <ul>\n      {Object.keys(groupedTranscript).map((username) => (\n        <li key={username}>\n          <h3>{username}</h3>\n          <ul>\n            {messagesLines\n              .filter((line) => line.username === username)\n              .map(({ text }, index) => (\n                <li key={index}>{text}</li>\n              ))}\n          </ul>\n        </li>\n      ))}\n    </ul>\n  );\n}"}
{"prompt":{"fileName":"Whiteboard.tsx","defaultExportName":"Whiteboard","hooks":[],"childComponents":[]},"result":"export default function Whiteboard(props: IProps): JSX.Element {\n  const { whiteboard, addLine } = props as Required<IProps>;\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return; \n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    function drawLine(startPoint: { x: number; y: number }, endPoint: { x: number; y: number }): void {\n      if (!ctx) return;\n      ctx.beginPath();\n      ctx.moveTo(startPoint.x, startPoint.y);\n      ctx.lineTo(endPoint.x, endPoint.y);\n      ctx.stroke();\n    }\n\n    for (const line of whiteboard.lines) {\n      drawLine(line.startPoint, line.endPoint);\n    }\n\n    function handleMouseDown(event: MouseEvent): void {\n      const startPoint = { x: event.clientX, y: event.clientY };\n\n      function handleMouseMove(event: MouseEvent): void {\n        if (!ctx) return;\n        const endPoint = { x: event.clientX, y: event.clientY };\n        drawLine(startPoint, endPoint);\n        addLine(startPoint, endPoint);\n        startPoint.x = endPoint.x;\n        startPoint.y = endPoint.y;\n      }\n\n      document.addEventListener('mousemove', handleMouseMove);\n\n      document.addEventListener(\n        'mouseup',\n        function handleMouseUp(event: MouseEvent): void {\n          document.removeEventListener('mousemove', handleMouseMove);\n          document.removeEventListener('mouseup', handleMouseUp);\n        }\n      );\n    }\n\n    canvas.addEventListener('mousedown', handleMouseDown);\n\n    return () => {\n      canvas.removeEventListener('mousedown', handleMouseDown);\n    };\n  }, [whiteboard, addLine]);\n\n  return <canvas ref={canvasRef} width={800} height={600} />;\n}"}
{"prompt":{"fileName":"FeedbackMenu.tsx","defaultExportName":"FeedbackMenu","hooks":["sh"],"childComponents":[]},"result":"export function FeedbackMenu ({ handleMenuClose, feedbackAnchorEl, feedbackMenuId, isFeedbackOpen }: IProps): JSX.Element {\n\n  const [postFeedback] = sh.usePostGroupFeedbackMutation();\n\n  const { data: profile } = sh.useGetUserProfileDetailsQuery();\n  \n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\n  \n  const [group, setGroup] = useState(groupsValues[0]);\n  const [feedbackTarget, setFeedbackTarget] = useState('site');\n  const [message, setMessage] = useState('');\n\n  const handleSubmit = useCallback(function() {\n    if (message && handleMenuClose) {\n      postFeedback({ message, groupName: group.name }).catch(console.error);\n      setMessage('');\n      handleMenuClose();\n    }\n  }, [message])\n\n  return <Menu\n    anchorEl={feedbackAnchorEl}\n    anchorOrigin={{\n      vertical: 'bottom',\n      horizontal: 'left',\n    }}\n    id={feedbackMenuId}\n    keepMounted\n    transformOrigin={{\n      vertical: 'top',\n      horizontal: 'right',\n    }}\n    open={!!isFeedbackOpen}\n    onClose={handleMenuClose}\n  >\n    <Box p={1} sx={{ width: 300 }}>\n      <Grid spacing={2} container direction=\"row\">\n        <Grid item xs={12}>\n          <TextField\n            select\n            fullWidth\n            value={feedbackTarget}\n            label=\"Group or Site\"\n            variant=\"standard\"\n            onChange={e => setFeedbackTarget(e.target.value) }\n          >\n            <MenuItem key={`site-select-give-feedback`} value={'site'}>Site</MenuItem>\n            {groupsValues.map(group => <MenuItem key={`group-select${group.id}`} value={group.id}>{group.name}</MenuItem>)}\n          </TextField>\n        </Grid>\n        {'site' !== feedbackTarget && profile?.groups && profile?.groups.length && <>\n          <pre>{JSON.stringify(profile?.groups[feedbackTarget], null, 2)}</pre>\n        </>}\n        <Grid item xs={12}>\n          <TextField\n            fullWidth\n            multiline\n            autoFocus\n            rows={4}\n            inputProps={{ maxLength: 300 }}\n            helperText={`${300 - message.length}/300`}\n            value={message}\n            onChange={e => setMessage(e.target.value)}\n          />\n        </Grid>\n        <Grid item xs={12}>\n          <Button fullWidth onClick={handleSubmit}>Submit Feedback</Button>\n        </Grid>\n      </Grid>\n    </Box>\n  </Menu>\n}"}
{"prompt":{"fileName":"ManageFeedback.tsx","defaultExportName":"ManageFeedbacks","hooks":["useGrid","sh"],"childComponents":[]},"result":"export function ManageFeedbacks(): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n  \n  const { data: feedbacks } = sh.useGetGroupFeedbackQuery({ groupName });\n\n  const FeedbackGrid = useGrid({\n    rows: feedbacks || [],\n    columns: [\n      { flex: 1, headerName: 'User', field: 'username' },\n      { flex: 1, headerName: 'Message', field: 'message' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs(row.createdOn).format(\"YYYY-MM-DD hh:mm a\") }\n    ]\n  });\n\n  return <FeedbackGrid />\n}"}
{"prompt":{"fileName":"Field.tsx","defaultExportName":"Field","hooks":[],"childComponents":[]},"result":"function Field ({ field, editable = false }: IProps): JSX.Element {\n  if (!field) return <></>;\n  let FieldElement: (props: TextFieldProps) => JSX.Element;\n\n  switch (field.t) {\n    case 'date':\n      FieldElement = TextField;\n      break;\n    case 'time':\n      FieldElement = TextField;\n      break;\n    case 'text':\n      FieldElement = TextField;\n      break;\n    case 'labelntext':\n      FieldElement = () => <>\n        <Typography variant=\"h6\">{field.l || 'Label'}</Typography>\n        <Typography variant=\"caption\">{field.x || 'Text'}</Typography>\n      </>\n      break;\n    default:\n      FieldElement = () => <></>;\n      break;\n  }\n\n  return <FieldElement\n    fullWidth\n    disabled={!editable}\n    label={field.l || 'Click to edit.'}\n    type={field.t}\n    helperText={`${field.r ? 'Required. ' : ''}${field.h || ''}`}\n    value={String(field.v || '')}\n  />;\n}"}
{"prompt":{"fileName":"FormBuilder.tsx","defaultExportName":"FormBuilder","hooks":[],"childComponents":[]},"result":"export default function FormBuilder({ version, setVersion, editable = true }: IProps & Required<FormBuilderProps>): JSX.Element {\n\n  const [rows, setRows] = useState({} as Record<string, IField[]>);\n  const [cell, setCell] = useState({} as IField);\n  const [position, setPosition] = useState({ row: '', col: 0 });\n\n  useEffect(() => {\n    if (Object.keys(rows).length) {\n      setVersion({ ...version, form: rows });\n    }\n  }, [rows]);\n\n  useEffect(() => {\n    if (Object.keys(version.form).length) {\n      setRows({ ...version.form });\n    }\n  }, [version]);\n\n  const rowKeys = useMemo(() => Object.keys(rows), [rows]);\n\n  const addRow = useCallback(() => setRows({ ...rows, [(new Date()).getTime().toString()]: [makeField()] }), [rows]);\n\n  // const delRow = useCallback((row: string) => {\n  //   delete rows[row];\n  //   setRows({ ...rows });\n  // }, [rows]);\n\n  const addCol = useCallback((row: string) => setRows({ ...rows, [row]: Array.prototype.concat(rows[row], [makeField()]) }), [rows]);\n\n  const delCol = useCallback((row: string, col: number) => {\n    rows[row].splice(col, 1);\n    if (!rows[row].length) delete rows[row];\n    setRows({ ...rows });\n  }, [rows]);\n\n  const makeField = useCallback((): IField => ({ l: '', t: 'text', h: '', r: false, v: '', x: '' }), []);\n\n  const setCellAttr = useCallback((value: string, attr: string) => {\n    rows[position.row][position.col][attr] = value;\n    setRows({ ...rows })\n  }, [rows, position]);\n\n  return <Grid container spacing={2}>\n\n    <Grid item sx={{ display: 'flex', flex: 1, alignItems: 'start' }}>\n      <Grid container spacing={2}>\n        {Object.keys(rows).length < 3 && <Grid item xs={12}>\n          <Button variant=\"outlined\" fullWidth onClick={addRow}>add row</Button>\n        </Grid>}\n        {Object.keys(rows).length > 0 && <Grid item xs={12}>\n          <Typography variant=\"subtitle1\">Start by editing the field and adding a label.</Typography>\n        </Grid>}\n        {rowKeys.map((rowId, i) => <Grid key={`form_fields_row_${i}`} item xs={12}>\n          <Grid container spacing={2}>\n            {rows[rowId].length < 3 && <Grid item xs={12} md={2}>\n              <Grid container direction=\"column\" sx={{ placeItems: 'center', height: '100%' }}>\n                <Button fullWidth variant=\"outlined\" color=\"warning\" sx={{ display: 'flex', flex: 1 }} onClick={() => addCol(rowId)}>add column</Button>\n                {/* <ButtonBase sx={{ display: 'flex', padding: '2px', backgroundColor: 'rgba(255, 0, 0, .1)' }} onClick={() => delRow(rowId)}>- row</ButtonBase> */}\n              </Grid>\n            </Grid>}\n            <Grid item xs={12} md={rows[rowId].length < 3 ? 10 : 12}>\n              <Grid container spacing={2}>\n                {rows[rowId].map((field, j) => {\n                  return <Grid item xs={12 / rows[rowId].length} key={`form_fields_cell_${i + 1}_${j}`}>\n                    <ButtonBase\n                      sx={{\n                        width: '100%',\n                        backgroundColor: position.row === rowId && position.col === j ? 'rgba(0, 150, 200, .1)' : 'rgba(0, 0, 0, .1)',\n                        cursor: 'pointer !important'\n                      }}\n                      onClick={() => {\n                        setCell(field);\n                        setPosition({ row: rowId, col: j })\n                      }}\n                    >\n                      <Field field={field} />\n                    </ButtonBase>\n                  </Grid>\n                })}\n              </Grid>\n            </Grid>\n          </Grid>\n        </Grid>)}\n      </Grid>\n    </Grid>\n\n    {editable && Object.hasOwn(cell, 'l') && <Grid item>\n      <Divider orientation=\"vertical\" />\n    </Grid>}\n\n    {editable && Object.hasOwn(cell, 'l') && <Grid item xs={4}>\n      <Grid container spacing={2} direction=\"column\">\n\n        <Grid item>\n          <Grid container alignItems=\"center\">\n            <Grid item sx={{ display: 'flex', flex: 1 }}>\n              <Typography variant=\"body2\">Field Attributes</Typography>\n            </Grid>\n            <Grid item>\n              <Button variant=\"text\" onClick={() => {\n                setPosition({ row: '', col: 0 })\n                setCell({} as IField);\n              }}>X</Button>\n            </Grid>\n          </Grid>\n        </Grid>\n\n        <Grid item>\n          <Button fullWidth color=\"error\" onClick={() => {\n            setPosition({ row: '', col: 0 })\n            delCol(position.row, position.col);\n            setCell({} as IField);\n          }}>Delete</Button>\n        </Grid>\n\n        <Grid item>\n          <TextField fullWidth label=\"Label\" type=\"text\" helperText=\"Required.\" value={cell.l} onChange={e => setCellAttr(e.target.value, 'l')} />\n        </Grid>\n\n        {'labelntext' === cell.t && <Grid item>\n          <TextField fullWidth label=\"Text\" type=\"text\" value={cell.x} onChange={e => setCellAttr(e.target.value, 'x')} />\n        </Grid>}\n\n        <Grid item>\n          <TextField\n            fullWidth\n            select\n            label=\"Field Type\"\n            value={cell.t}\n            onChange={e => setCellAttr(e.target.value, 't')}\n          >\n            <MenuItem key={1111} value={'text'}>Textfield</MenuItem>\n            <MenuItem key={23432423} value={'date'}>Date</MenuItem>\n            <MenuItem key={235325} value={'time'}>Time</MenuItem>\n            <MenuItem key={235324325} value={'labelntext'}>Label and Text</MenuItem>\n          </TextField>\n        </Grid>\n\n        <Grid item>\n          <TextField fullWidth label=\"Helper Text\" type=\"text\" value={cell.h} onChange={e => setCellAttr(e.target.value, 'h')} />\n        </Grid>\n\n        <Grid item>\n          <Typography variant=\"body1\">Required</Typography>\n          <Switch value={cell.r} checked={cell.r} onChange={() => {\n            rows[position.row][position.col].r = !cell.r;\n            setRows({ ...rows })\n          }} />\n        </Grid>\n\n      </Grid>\n    </Grid>}\n\n  </Grid>;\n}"}
{"prompt":{"fileName":"FormDisplay.tsx","defaultExportName":"FormDisplay","hooks":[],"childComponents":[]},"result":"export default function FormDisplay({ form, setForm }: IProps & Required<FormDisplayProps>): JSX.Element {\n\n  const [rows, setRows] = useState({} as IFormTemplate);\n  const [formId, setFormId] = useState('');\n\n  useEffect(() => {\n    if (Object.keys(rows).length) {\n      setForm({\n        ...form,\n        version: {\n          ...form.version,\n          submission: Object.keys(rows).reduce((m, rowId) => {\n            return {\n              ...m,\n              [rowId]: rows[rowId].map(r => r.v)\n            }\n          }, {})\n        }\n      });\n    }\n  }, [rows]);\n\n  useEffect(() => {\n    if (form.id !== formId && Object.keys(form.version.form).length) {\n      setRows({ ...form.version.form });\n      setFormId(form.id)\n    }\n  }, [form, formId]);\n\n  const rowKeys = useMemo(() => Object.keys(rows), [rows]);\n\n  const setCellAttr = useCallback((row: string, col: number, value: string, attr: string) => {\n    rows[row][col][attr] = value;\n    setRows({ ...rows })\n  }, [rows]);\n\n  return <Grid container spacing={2}>\n\n    {rowKeys.map((rowId, i) => <Grid key={`form_fields_row_${i}`} item xs={12}>\n      <Grid container spacing={2}>\n        {rows[rowId].map((cell, j) => {\n          return <Grid key={`form_fields_cell_${i + 1}_${j}`} item xs={12 / rows[rowId].length}>\n            <TextField\n              fullWidth\n              label={cell.l}\n              type={cell.t || 'text'}\n              helperText={`${cell.r ? 'Required. ' : ''}${cell.h || ''}`}\n              onChange={e => setCellAttr(rowId, j, e.target.value, 'v')}\n            />\n          </Grid>\n        })}\n      </Grid>\n    </Grid>)}\n\n  </Grid>\n}"}
{"prompt":{"fileName":"ManageFormModal.tsx","defaultExportName":"ManageFormModal","hooks":["useComponents","sh","useUtil"],"childComponents":[]},"result":"export function ManageFormModal({ editForm, closeModal, ...props }: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const [postGroupFormVersion] = sh.usePostGroupFormVersionMutation();\n  const [postGroupForm] = sh.usePostGroupFormMutation();\n  const [getGroupFormById] = sh.useLazyGetGroupFormByIdQuery();\n\n  const { setSnack } = useUtil();\n\n  const { FormBuilder } = useComponents();\n  const [version, setVersion] = useState({ form: {} } as IFormVersion);\n  const [form, setForm] = useState({ name: '', ...editForm } as IForm);\n  const [editable, setEditable] = useState(true);\n\n  useEffect(() => {\n    if (editForm) {\n      getGroupFormById({ formId: editForm.id, groupName }).unwrap().then(res => {\n        setForm(res);\n        if (res.version) {\n          setVersion(res.version);\n        }\n      }).catch(console.error);\n    }\n  }, [editForm]);\n\n  useEffect(() => {\n    if (form.version && Object.keys(form.version).length) {\n      const vers = form.version;\n\n      Object.keys(vers.form).forEach(k => {\n        vers.form[k].forEach(f => {\n          if (!f.t) f.t = 'text';\n          if (!f.h) f.h = '';\n          if (!f.r) f.r = false;\n        });\n      });\n\n      setVersion(form.version);\n    }\n  }, [form]);\n\n  const handleSubmit = useCallback(() => {\n    setEditable(false);\n    const { id, name } = form;\n\n    if (!name || !Object.keys(version.form).length || Object.values(version.form).some(v => v.some(f => !f.l))) {\n      setSnack({ snackType: 'error', snackOn: 'Forms must have a name, and at least 1 field. All fields mus have a label.' });\n      setEditable(true);\n      return;\n    }\n\n    const newForm = Object.keys(version.form).reduce((m, k, i) => {\n      const fields = [...version.form[k]] as IField[];\n      return {\n        ...m,\n        [i]: fields.map(f => {\n          delete f.v;\n          if ('' === f.t) delete f.t;\n          if ('' === f.h) delete f.h;\n          if ('' === f.x) delete f.x;\n          if (false === f.r) delete f.r;\n          return f;\n        })\n      }\n    }, {});\n\n    const formVersion = {\n      id,\n      name,\n      version: {\n        form: newForm,\n        formId: id\n      }\n    } as IForm;\n\n    (id ? postGroupFormVersion : postGroupForm)((id ? { ...formVersion, formId: id, groupName } : { ...formVersion, groupName }) as IGroupForm).unwrap().then(() => closeModal && closeModal()).catch(console.error);\n  }, [form, version.form]);\n\n  return <Card sx={{ display: 'flex', flex: 1, flexDirection: 'column' }}>\n    <CardHeader title={editForm?.id ? 'Manage' : 'Create'} />\n    <CardContent sx={{ display: 'flex', flex: 1, flexDirection: 'column', overflow: 'auto' }}>\n      <Box mt={2} />\n\n      <Box mb={4}>\n        <TextField\n          fullWidth\n          autoFocus\n          id=\"name\"\n          label=\"Name\"\n          name=\"name\"\n          value={form.name}\n          onKeyDown={e => {\n            if ('Enter' === e.key) {\n              handleSubmit();\n            }\n          }}\n          onChange={e => setForm({ ...form, name: e.target.value })}\n        />\n      </Box>\n\n      <FormBuilder {...props} editable={editable} version={version} setVersion={setVersion} />\n\n    </CardContent>\n    <CardActions>\n      <Grid container justifyContent=\"space-between\">\n        <Button onClick={closeModal}>Cancel</Button>\n        <Button onClick={handleSubmit}>Submit</Button>\n      </Grid>\n    </CardActions>\n  </Card>\n}"}
{"prompt":{"fileName":"ManageForms.tsx","defaultExportName":"ManageForms","hooks":["sh","useGrid"],"childComponents":[]},"result":"export function ManageForms(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n  \n  const [deleteGroupForm] = sh.useDeleteGroupFormMutation();\n  const { data: groupForms, refetch: getGroupForms } = sh.useGetGroupFormsQuery({ groupName });\n\n  const [form, setForm] = useState<IGroupForm>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <Tooltip key={'manage_form'} title=\"Edit\">\n        <Button onClick={() => {\n          setForm(groupForms?.find(gf => gf.id === selected[0]));\n          setDialog('manage_form');\n          setSelected([]);\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip> \n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_group'} title=\"Delete\">\n        <Button onClick={() => {\n          if (selected.length) {\n            deleteGroupForm({ groupName, ids: selected.join(',') }).unwrap().then(() => {\n              setSelected([]);\n              void getGroupForms();\n            }).catch(console.error);\n          }\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ]\n  }, [selected]);\n\n  const FormGrid = useGrid<IGroupForm>({\n    rows: groupForms || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Forms:</Typography>\n      <Tooltip key={'manage_form'} title=\"Create\">\n        <Button onClick={() => {\n          setForm(undefined);\n          setDialog('manage_form')\n        }}\n        >\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\n          <NoteAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  });\n\n  return <>\n    <Dialog fullScreen open={dialog === 'manage_form'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageFormModal {...props} editForm={form} closeModal={() => {\n          setDialog('')\n          void getGroupForms();\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <FormGrid />\n\n  </>\n}"}
{"prompt":{"fileName":"GroupHome.tsx","defaultExportName":"GroupHome","hooks":[],"childComponents":[]},"result":"export function GroupHome (props: IProps): JSX.Element {\r\n  return <Box mb={4}>\r\n    <ManageGroups {...props} />\r\n  </Box>\r\n}"}
{"prompt":{"fileName":"GroupPaths.tsx","defaultExportName":"GroupPaths","hooks":["useComponents"],"childComponents":[]},"result":"export function GroupPaths (props: IProps): JSX.Element {\n  \n  const { ManageGroupHome } = useComponents();\n\n  return <Routes>\n    <Route path=\"manage/:component\" element={<ManageGroupHome {...props} />} />\n  </Routes>\n}"}
{"prompt":{"fileName":"GroupSecure.tsx","defaultExportName":"GroupSecure","hooks":["useGroupSecure"],"childComponents":[]},"result":"export function GroupSecure ({ contentGroupRoles = [SiteRoles.APP_GROUP_ADMIN], children }: IProps): JSX.Element {\r\n\r\n  const hasGroupRole = useGroupSecure();\r\n\r\n  const [isValid, setIsValid] = useState(false);\r\n\r\n  useEffect(() => {\r\n    setIsValid(hasGroupRole(contentGroupRoles));\r\n  }, [hasGroupRole]);\r\n\r\n  return <> {isValid ? children : <></>} </>\r\n}"}
{"prompt":{"fileName":"InviteUsersModal.tsx","defaultExportName":"InviteUsersModal","hooks":["sh","useUtil"],"childComponents":[]},"result":"export function InviteUsersModal({ closeModal }: IProps): JSX.Element {\n\n  const { setSnack } = useUtil();\n  const [inviteGroupUser] = sh.useInviteGroupUserMutation();\n\n  const [email, setEmail] = useState('');\n  const [users, setUsers] = useState<IUserProfile[]>([]);\n\n  const handleAdd = useCallback(() => {\n    setUsers([...users, { email } as IUserProfile]);\n    setEmail('');\n  }, [users, email]);\n\n  const handleSubmit = useCallback(() => {\n    if (!users.length) {\n      setSnack({ snackType: 'error', snackOn: 'Please provide at least 1 email.' });\n      return;\n    }\n\n    inviteGroupUser({ users }).unwrap().then(() => {\n      if (closeModal)\n        closeModal();\n    }).catch(console.error);\n  }, [users]);\n\n  return <>\n    <Card>\n      <CardContent>\n        <Typography variant=\"button\">Invite Users</Typography>\n      </CardContent>\n      <CardContent>\n        <Grid container>\n          <Grid item xs={12}>\n            <Grid container>\n              <Grid item xs={12}>\n                <TextField\n                  label=\"Email\"\n                  type=\"email\"\n                  placeholder=\"Type an email and press enter...\"\n                  fullWidth\n                  value={email}\n                  onChange={e => {\n                    setEmail(e.currentTarget.value)\n                  }}\n                  InputProps={{\n                    onKeyDown: e => {\n                      if ('Enter' === e.key && e.currentTarget.validity.valid) {\n                        handleAdd();\n                      }\n                    }\n                  }}\n                />\n              </Grid>\n              <Grid item xs={12}>\n                <ul>\n                  {users.map(({ email }, i) => <li key={`group_invite_email_${i}`}>{email}</li>)}\n                </ul>\n              </Grid>\n            </Grid>\n          </Grid>\n        </Grid>\n      </CardContent>\n      <CardActions>\n        <Grid container justifyContent=\"flex-end\">\n          <Button onClick={closeModal}>Cancel</Button>\n          <Button onClick={handleSubmit}>Submit</Button>\n        </Grid>\n      </CardActions>\n    </Card>\n  </>\n}"}
{"prompt":{"fileName":"JoinGroupModal.tsx","defaultExportName":"JoinGroupModal","hooks":["sh","useUtil"],"childComponents":[]},"result":"export function JoinGroupModal ({ closeModal }: IProps): JSX.Element {\r\n\r\n  const { setSnack } = useUtil();\r\n  const [joinGroup] = sh.useJoinGroupMutation();\r\n  const [code, setCode] = useState('');\r\n\r\n  const handleSubmit = useCallback(() => {\r\n    if (!code) {\r\n      setSnack({ snackType: 'error', snackOn: 'Please provide at least 1 code.' });\r\n      return;\r\n    }\r\n\r\n    joinGroup({ code }).unwrap().then(() => {\r\n      if (closeModal)\r\n        closeModal();\r\n    }).catch(console.error);\r\n  }, [code]);\r\n\r\n  return <>\r\n    <Card>\r\n      <CardContent>\r\n        <Typography variant=\"button\">Join a Group</Typography>\r\n      </CardContent>\r\n      <CardContent>\r\n        <Grid container>\r\n          <Grid item xs={12}>\r\n            <Grid container>\r\n              <Grid item xs={12}>\r\n                <TextField\r\n                  label=\"Code\"\r\n                  type=\"code\"\r\n                  placeholder=\"Type an code and press enter...\"\r\n                  fullWidth\r\n                  value={code}\r\n                  onChange={e => {\r\n                    setCode(e.currentTarget.value)\r\n                  }}\r\n                />\r\n              </Grid>\r\n            </Grid>\r\n          </Grid>\r\n        </Grid>\r\n      </CardContent>\r\n      <CardActions>\r\n        <Grid container justifyContent=\"flex-end\">\r\n          <Button onClick={closeModal}>Cancel</Button>\r\n          <Button onClick={handleSubmit}>Submit</Button>\r\n        </Grid>\r\n      </CardActions>\r\n    </Card>\r\n  </>\r\n}"}
{"prompt":{"fileName":"ManageGroupHome.tsx","defaultExportName":"ManageGroupHome","hooks":["sh","useComponents"],"childComponents":[]},"result":"export function ManageGroupHome(props: IProps): JSX.Element {\r\n  const { groupName, component } = useParams();\r\n\r\n  if (!groupName || !component) return <></>;\r\n\r\n  const navigate = useNavigate();\r\n\r\n  const { data : profile } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const { ManageFeedback, ManageUsers, ManageRoles, ManageRoleActions, ManageForms, ManageServices, ManageSchedules, GroupSecure } = useComponents();\r\n\r\n  const menuRoles: Record<string, SiteRoles[]> = {\r\n    users: [APP_GROUP_USERS],\r\n    roles: [APP_GROUP_ROLES],\r\n    matrix: [APP_GROUP_ADMIN],\r\n    feedback: [APP_GROUP_ADMIN],\r\n    forms: [APP_GROUP_ADMIN],\r\n    services: [APP_GROUP_SERVICES],\r\n    schedules: [APP_GROUP_SCHEDULES],\r\n  }\r\n\r\n  const menu = Object.keys(menuRoles).map(comp =>{\r\n    const selected = comp === component;\r\n    return groupName && component && <GroupSecure key={`menu_${comp}`} contentGroupRoles={menuRoles[comp]}>\r\n      <Grid item>\r\n        <Link\r\n          variant=\"button\"\r\n          color={selected ? \"secondary\" : \"primary\"}\r\n          sx={{ cursor: 'pointer' }}\r\n          style={selected ? { textDecoration: 'underline' } : undefined}\r\n          onClick={() => navigate(`/group/${groupName}/manage/${comp}`)}\r\n        >\r\n          {comp}\r\n        </Link>\r\n      </Grid>\r\n    </GroupSecure>\r\n  });\r\n\r\n  const viewPage = useMemo(() => {\r\n    switch (component) {\r\n      case 'users':\r\n        return <ManageUsers {...props} />\r\n      case 'roles':\r\n        return <ManageRoles {...props} />\r\n      case 'matrix':\r\n        return <ManageRoleActions {...props} />\r\n      case 'forms':\r\n        return <ManageForms {...props} />\r\n      case 'services':\r\n        return <ManageServices {...props} />\r\n      case 'schedules':\r\n        return <ManageSchedules {...props} />\r\n      case 'feedback':\r\n        return <ManageFeedback {...props} />\r\n      default:\r\n        return;\r\n    }\r\n  }, [component])\r\n\r\n  return <>\r\n\r\n    <Grid container pb={2} spacing={2} justifyContent=\"flex-start\" alignItems=\"center\">\r\n      <Grid item>\r\n        <Typography variant=\"button\">Controls:</Typography> \r\n      </Grid>\r\n      {menu}\r\n    </Grid>\r\n\r\n    {viewPage}\r\n  </>\r\n}"}
{"prompt":{"fileName":"ManageGroupModal.tsx","defaultExportName":"ManageGroupModal","hooks":["useComponents","sh","useUtil"],"childComponents":[]},"result":"export function ManageGroupModal({ editGroup, closeModal, ...props }: IProps): JSX.Element {\r\n\r\n  const { setSnack } = useUtil();\r\n\r\n  const { SelectLookup } = useComponents();\r\n\r\n  const { data : profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const [putGroup] = sh.usePutGroupMutation();\r\n  const [postGroup] = sh.usePostGroupMutation();\r\n  const [getPrompt] = sh.useLazyGetPromptQuery();\r\n  const [postRole] = sh.usePostRoleMutation();\r\n  const [deleteRole] = sh.useDeleteRoleMutation();\r\n  const [checkGroupName, { data: nameCheck }] = sh.useLazyCheckGroupNameQuery();\r\n  const { isValid: groupNameValid } = nameCheck || {};\r\n\r\n  const [defaultRoleId, setDefaultRoleId] = useState(editGroup?.defaultRoleId || '');\r\n  const [roleIds, setRoleIds] = useState<string[]>([]);\r\n  const [group, setGroup] = useState({ name: '', purpose: '', allowedDomains: '', ...editGroup } as IGroup);\r\n  const [viewStep, setViewStep] = useState(1);\r\n  const [editedPurpose, setEditedPurpose] = useState(false);\r\n  const [roleSuggestions, setRoleSuggestions] = useState([] as string[]);\r\n  const [allowedDomains, setAllowedDomains] = useState([profile?.username?.split('@')[1]] as string[]);\r\n  const [allowedDomain, setAllowedDomain] = useState('');\r\n\r\n  const [{ isValid, needCheckName, checkedName, checkingName }, setChecker] = useState<Partial<{\r\n    isValid: boolean,\r\n    needCheckName: boolean,\r\n    checkedName: string,\r\n    checkingName: boolean\r\n  }>>({\r\n    isValid: !!groupNameValid,\r\n    needCheckName: false,\r\n    checkedName: '',\r\n    checkingName: false\r\n  });\r\n\r\n  const progressMemo = useMemo(() => <CircularProgress size=\"20px\" />, []);\r\n  const roleValues = useMemo(() => Object.values(profile?.roles || {}), [profile]);\r\n\r\n  const formatName = useCallback((name: string) => name\r\n    .replaceAll(/__+/g, '_')\r\n    .replaceAll(/\\s/g, '_')\r\n    .replaceAll(/[\\W]+/g, '_')\r\n    .replaceAll(/__+/g, '_')\r\n    .replaceAll(/__+/g, '').toLowerCase() // Enforce a name like this_is_a_name\r\n    , []);\r\n\r\n  const badName = !checkingName && !isValid && !!group?.name && formatName(group.name) == checkedName;\r\n\r\n  const handleSubmit = useCallback(() => {\r\n    const { id, name, purpose } = group;\r\n\r\n    if (!name || !roleIds.length || !defaultRoleId) {\r\n      setSnack({ snackType: 'error', snackOn: 'All fields are required.' });\r\n      return;\r\n    }\r\n   \r\n    (id ? putGroup : postGroup)({\r\n      id,\r\n      name: formatName(name),\r\n      purpose,\r\n      allowedDomains: allowedDomains.join(','),\r\n      roles: Object.fromEntries(roleIds.map(id => [id, roleValues.find(r => r.id === id)] as [string, IRole])),\r\n      defaultRoleId\r\n    }).unwrap().then(() => {\r\n      id && setSnack({ snackType: 'success', snackOn: 'Group updated! Please allow up to a minute for any related permissions changes to persist.' })\r\n      !id && keycloak.clearToken();\r\n    }).catch(console.error);\r\n  }, [group, profile, roleIds, defaultRoleId]);\r\n\r\n\r\n  const handleName = useCallback((event: ChangeEvent<HTMLTextAreaElement>) => {\r\n    setChecker({ checkingName: true });\r\n    const name = event.target.value;\r\n    if (name.length <= 50) {\r\n      setGroup({ ...group, name });\r\n      setChecker({ checkedName: formatName(name), needCheckName: name != editGroup?.name });\r\n    } else if (isValid) {\r\n      setChecker({ checkingName: false });\r\n    }\r\n  }, [group, editGroup]);\r\n\r\n  const handleContinue = useCallback(() => {\r\n    getPrompt({ id: IPrompts.SUGGEST_ROLE, prompt: `${group.name}|||${group.purpose}` }).unwrap().then(res => {\r\n      setRoleSuggestions(res.promptResult);\r\n      setViewStep(2);\r\n    }).catch(console.error);\r\n  }, [group]);\r\n\r\n  if (!roleIds.length && roleValues?.length && group.roles && !defaultRoleId) {\r\n    setRoleIds(Object.keys(group.roles))\r\n  }\r\n\r\n  if (roleIds.length && !defaultRoleId) {\r\n    setDefaultRoleId(roleIds[0]);\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (needCheckName && checkedName?.length) {\r\n      setChecker({ checkingName: true, needCheckName: false, isValid: false });\r\n      checkGroupName({ name: checkedName }).catch(console.error);\r\n    }\r\n  }, [needCheckName, checkedName]);\r\n\r\n  const roleSuggestionLinks = <>\r\n    AI: {roleSuggestions.filter(s => s.toLowerCase() !== 'admin').map((s, i) => {\r\n      return <span key={`role-selection-${i}`}>\r\n        <Link sx={{ cursor: 'pointer' }} onClick={() => {\r\n          // The currently suggested role in the user detail's role list\r\n          const existingId = roleValues.find(r => r.name === s)?.id;\r\n\r\n          // If the role is not in the user detail roles list, or it is, but it doesn't exist in the current list, continue\r\n          if (!existingId || (existingId && !roleIds.includes(existingId))) {\r\n\r\n            // If the role is in the user details roles list\r\n            if (existingId) {\r\n              setRoleIds([...roleIds, existingId])\r\n            } else {\r\n              postRole({ name: s }).unwrap().then(async newRole => {\r\n                await getUserProfileDetails();\r\n                !roleIds.includes(newRole.id) && setRoleIds([...roleIds, newRole.id]);\r\n              }).catch(console.error);\r\n            }\r\n          }\r\n        }}>{s}</Link>{i !== roleSuggestions.length - 1 ? ',' : ''}&nbsp;\r\n      </span>\r\n    })}\r\n  </>\r\n\r\n  return <>\r\n    <Card>\r\n      <CardHeader title={(editGroup ? 'Manage' : 'Create') + ' Group'}></CardHeader>\r\n      <CardContent>\r\n        {1 === viewStep ? <Grid container spacing={4}>\r\n          <Grid item xs={12}>\r\n            <TextField\r\n              fullWidth\r\n              id=\"name\"\r\n              label=\"Name\"\r\n              value={group.name}\r\n              name=\"name\"\r\n              onChange={handleName}\r\n              multiline\r\n              helperText=\"Group names can only contain letters, numbers, and underscores. Max 50 characters.\"\r\n              error={badName}\r\n              InputProps={{\r\n                endAdornment: group.name && (\r\n                  <InputAdornment\r\n                    component={({ children }) =>\r\n                      <Grid container style={{ width: 'calc(100% + 5em)', maxWidth: 'calc(100% + 5em)' }}>\r\n                        {children}\r\n                      </Grid>\r\n                    }\r\n                    position=\"start\"\r\n                  >\r\n                    <Grid item style={{ alignSelf: 'center' }}>\r\n                      {checkingName ? progressMemo :\r\n                        badName ? <NotInterestedIcon color=\"error\" /> : <ArrowRightAlt />}\r\n                    </Grid>\r\n                    <Grid item xs style={{ wordBreak: 'break-all' }}>\r\n                      <Typography style={{\r\n                        padding: '2px 4px',\r\n                        border: `1px solid #666`,\r\n                        lineHeight: '1.15em'\r\n                      }}>\r\n                        {formatName(group.name)}\r\n                      </Typography>\r\n                    </Grid>\r\n                  </InputAdornment>\r\n                ),\r\n              }}\r\n            />\r\n          </Grid>\r\n          <Grid item xs={12}>\r\n            <TextField\r\n              id={`group-purpose-entry`}\r\n              fullWidth\r\n              inputProps={{ minLength: 25, maxLength: 100 }}\r\n              helperText={'Enter a short phrase about the function of your group (25 to 100 characters).'}\r\n              label={`Group Purpose`}\r\n              error={editedPurpose && !!group.purpose && group.purpose.length < 25}\r\n              onBlur={() => setEditedPurpose(true)}\r\n              onFocus={() => setEditedPurpose(false)}\r\n              onChange={e => setGroup({ ...group, purpose: e.target.value })}\r\n              value={group.purpose}\r\n            />\r\n          </Grid>\r\n          <Grid item xs={12}>\r\n            <TextField\r\n              id={`group-allowed-domains-entry`}\r\n              fullWidth\r\n              helperText={`These domains will be allowed to join the group. Remove all for unrestricted access.`}\r\n              label={`Allowed Domains`}\r\n              onChange={e => setAllowedDomain(e.target.value)}\r\n              value={allowedDomain}\r\n              InputProps={{\r\n                endAdornment: <Button\r\n                  variant=\"text\"\r\n                  color=\"secondary\"\r\n                  onClick={() => {\r\n                    if (!/[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*/.test(allowedDomain)) {\r\n                      setSnack({ snackType: 'info', snackOn: 'Must be an email domain, like DOMAIN.COM'})\r\n                    } else {\r\n                      setAllowedDomains([ ...allowedDomains, allowedDomain ])\r\n                      setAllowedDomain('');\r\n                    }\r\n                  }}\r\n                >Add</Button>\r\n              }}\r\n            />\r\n            <Grid container>\r\n              {allowedDomains.map((ad, i) => <Box key={`allowed-domain-selection-${i}`} mt={2} mr={2}>\r\n                <Chip\r\n                  label={ad}\r\n                  color=\"secondary\"\r\n                  onDelete={() => {\r\n                    setAllowedDomains(allowedDomains.filter(da => da !== ad))\r\n                  }}\r\n                />\r\n              </Box>)}\r\n            </Grid>\r\n          </Grid>\r\n        </Grid> :\r\n          <Grid container spacing={4}>\r\n            <Grid item>\r\n              <Typography variant=\"h6\">Roles</Typography>\r\n              <Typography variant=\"body2\">Each group needs a set of roles to assign to its users. After creating this group, visit the Matrix page to assign site functionality to your roles.</Typography>\r\n            </Grid>\r\n            <Grid item xs={12}>\r\n              <SelectLookup\r\n                multiple\r\n                helperText={!roleSuggestions.length ? 'Ex: Consultant, Project Manager, Advisor, Business Analyst' : roleSuggestionLinks}\r\n                lookupName='Group Role'\r\n                lookups={roleValues}\r\n                lookupChange={setRoleIds}\r\n                lookupValue={roleIds}\r\n                invalidValues={['admin']}\r\n                refetchAction={getUserProfileDetails}\r\n                createAction={postRole}\r\n                deleteAction={deleteRole}\r\n                deleteActionIdentifier='ids'\r\n                {...props}\r\n              />\r\n            </Grid>\r\n            {defaultRoleId && <Grid item xs={12}>\r\n              <TextField\r\n                select\r\n                id={`group-default-role-selection`}\r\n                fullWidth\r\n                helperText={'Set the group default role. When members join the group, this role will be assigned.'}\r\n                label={`Default Role`}\r\n                onChange={e => setDefaultRoleId(e.target.value)}\r\n                value={defaultRoleId}\r\n              >\r\n                {roleIds.map(roleId => <MenuItem key={`${roleId}_primary_role_select`} value={roleId}>{roleValues.find(role => role.id === roleId)?.name || ''}</MenuItem>)}\r\n              </TextField>\r\n            </Grid>}\r\n            <Grid item>\r\n              <Alert severity=\"info\">An Admin group is created automatically. Only create groups for your members.</Alert>\r\n            </Grid>\r\n          </Grid>}\r\n      </CardContent>\r\n      <CardActions>\r\n        <Grid container justifyContent=\"space-between\">\r\n          {1 === viewStep ? <Grid container justifyContent=\"space-between\">\r\n            <Button onClick={closeModal}>Cancel</Button>\r\n            <Button\r\n              disabled={group.purpose.length < 25 || !isValid || checkingName || badName}\r\n              onClick={handleContinue}\r\n            >\r\n              Continue\r\n            </Button>\r\n          </Grid> : <Grid container justifyContent=\"space-between\">\r\n            <Button onClick={() => { setViewStep(1); }}>Back</Button>\r\n            <Button onClick={handleSubmit}>Submit</Button>\r\n          </Grid>}        </Grid>\r\n      </CardActions>\r\n    </Card>\r\n  </>\r\n}"}
{"prompt":{"fileName":"ManageGroups.tsx","defaultExportName":"ManageGroups","hooks":["useAppSelector","useSecure","useGrid","sh","useUtil"],"childComponents":[]},"result":"export function ManageGroups(props: IProps): JSX.Element {\r\n  const [deleteGroup] = sh.useDeleteGroupMutation();\r\n  const [leaveGroup] = sh.useLeaveGroupMutation();\r\n\r\n  const { openConfirm, setLoading } = useUtil();\r\n\r\n  const hasRole = useSecure();\r\n  const navigate = useNavigate();\r\n  const util = useAppSelector(state => state.util);\r\n\r\n  const [group, setGroup] = useState<IGroup>();\r\n  const [dialog, setDialog] = useState('');\r\n  const [selected, setSelected] = useState<string[]>([]);\r\n\r\n  const { data: profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const { groups } = profile || {};\r\n\r\n  const actions = useMemo(() => {\r\n    if (!groups) return [];\r\n    const { length } = selected;\r\n    const gr = groups[selected[0]];\r\n    const isOwner = gr?.createdSub === profile?.sub;\r\n    const acts = length == 1 ? [\r\n      gr && !isOwner && <Tooltip key={'leave_group'} title=\"Leave\">\r\n        <Button onClick={() => {\r\n          openConfirm({\r\n            isConfirming: true,\r\n            confirmEffect: 'Leave the group ' + gr.name + ' and refresh the session.',\r\n            confirmAction: () => {\r\n              leaveGroup({ code: gr.code }).unwrap().then(() => keycloak.clearToken()).catch(console.error);\r\n            }\r\n          });\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Leave</Typography>\r\n          <Logout sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>,\r\n      gr && isOwner && hasRole([SiteRoles.APP_GROUP_ADMIN]) && <Tooltip key={'view_group_details'} title=\"Details\">\r\n        <Button onClick={() => {\r\n          navigate(`/group/${gr.name}/manage/users`)\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Details</Typography>\r\n          <ManageAccountsIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>,\r\n      isOwner && <Tooltip key={'manage_group'} title=\"Edit\">\r\n        <Button onClick={() => {\r\n          setGroup(groups[selected[0]]);\r\n          setDialog('manage_group');\r\n          setSelected([]);\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\r\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ] : [];\r\n\r\n    return [\r\n      ...acts,\r\n      isOwner && <Tooltip key={'delete_group'} title=\"Delete\">\r\n        <Button onClick={() => {\r\n          openConfirm({\r\n            isConfirming: true,\r\n            confirmEffect: 'Delete the group ' + gr.name + ' and refresh the session.',\r\n            confirmAction: () => {\r\n              deleteGroup({ ids: selected.join(',') }).unwrap().then(() => keycloak.clearToken()).catch(console.error);\r\n            }\r\n          });\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\r\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ];\r\n  }, [selected, groups]);\r\n\r\n  const GroupsGrid = useGrid({\r\n    rows: Object.values(groups || {}),\r\n    columns: [\r\n      { flex: 1, headerName: 'Name', field: 'name' },\r\n      { flex: 1, headerName: 'Code', field: 'code' },\r\n      { flex: 1, headerName: 'Users', field: 'usersCount', renderCell: ({ row }) => row.usersCount || 0 },\r\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\r\n    ],\r\n    selected,\r\n    onSelected: p => setSelected(p as string[]),\r\n    toolbar: () => <>\r\n      <Typography variant=\"button\">Groups:</Typography>\r\n      <Tooltip key={'join_group'} title=\"Join\">\r\n        <Button key={'join_group_button'} onClick={() => {\r\n          setGroup(undefined);\r\n          setDialog('join_group');\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Join</Typography>\r\n          <DomainAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n      <Tooltip key={'create_group'} title=\"Create\">\r\n        <Button key={'create_group_button'} onClick={() => {\r\n          setGroup(undefined);\r\n          setDialog('create_group');\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\r\n          <GroupAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\r\n    </>\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (groups && Object.keys(groups).length === 1 && Object.keys(profile?.availableUserGroupRoles || {}).length && util.isLoading) {\r\n      setLoading({ isLoading: false, loadingMessage: '' });\r\n    }\r\n  }, [groups, profile?.availableUserGroupRoles, util.isLoading]);\r\n\r\n  return <>\r\n    <Dialog open={dialog === 'create_group'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <ManageGroupModal {...props} editGroup={group} closeModal={() => {\r\n          setDialog('');\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <Dialog open={dialog === 'join_group'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <JoinGroupModal {...props} editGroup={group} closeModal={() => {\r\n          setDialog('');\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <Dialog open={dialog === 'manage_group'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <ManageGroupModal {...props} editGroup={group} closeModal={() => {\r\n          setDialog('');\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <GroupsGrid />\r\n\r\n  </>\r\n}"}
{"prompt":{"fileName":"Profile.tsx","defaultExportName":"Profile","hooks":["sh","useComponents","useFileStore","useStyles","useUtil"],"childComponents":[]},"result":"export function Profile(props: IProps): JSX.Element {\r\n  const classes = useStyles();\r\n\r\n  const { setSnack } = useUtil();\r\n  const [putUserProfile] = sh.usePutUserProfileMutation();\r\n\r\n  const fileStore = useFileStore();\r\n  const { PickTheme, ManageGroups } = useComponents();\r\n\r\n  const { data : user } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const [displayImage, setDisplayImage] = useState('');\r\n  const [file, setFile] = useState<IPreviewFile>();\r\n  const [profile, setProfile] = useState({\r\n    firstName: '',\r\n    lastName: '',\r\n    email: '',\r\n    image: ''\r\n  } as IUserProfile);\r\n\r\n  const { getRootProps, getInputProps } = useDropzone({\r\n    maxSize: 1000000,\r\n    maxFiles: 1,\r\n    accept: {\r\n      'image/*': []\r\n    },\r\n    onDrop: (acceptedFiles: File[]) => {\r\n      const acceptedFile = acceptedFiles.pop()\r\n      if (acceptedFile) {\r\n        setFile(acceptedFile);\r\n        setDisplayImage(URL.createObjectURL(acceptedFile));\r\n      }\r\n    }\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (file?.preview) URL.revokeObjectURL(file.preview);\r\n  }, [file]);\r\n\r\n  useEffect(() => {\r\n    async function go() {\r\n      if (fileStore && profile.image) {\r\n        setDisplayImage(await fileStore.get(profile.image));\r\n      }\r\n    }\r\n    void go();\r\n  }, [fileStore, profile.image]);\r\n\r\n  useEffect(() => {\r\n    if (user) {\r\n      setProfile({ ...profile, ...user });\r\n    }\r\n  }, [user]);\r\n\r\n  const deleteFile = () => {\r\n    setProfile({ ...profile, ...{ image: '' } });\r\n    setDisplayImage('');\r\n  }\r\n\r\n  const handleSubmit = async () => {\r\n    if (file) {\r\n      profile.image = await fileStore?.put(file);\r\n    }\r\n\r\n    putUserProfile(profile).unwrap().then(() => {\r\n      setSnack({ snackType: 'success', snackOn: 'Profile updated!' });\r\n      setFile(undefined);\r\n    }).catch(console.error);\r\n  }\r\n\r\n  return <>\r\n    <Grid container spacing={6}>\r\n      <Grid item sm={12} md={4}>\r\n        <Grid container direction=\"column\" spacing={2}>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Profile</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <TextField fullWidth id=\"firstName\" label=\"First Name\" autoComplete=\"on\" value={profile.firstName} name=\"firstName\" onChange={e => setProfile({ ...profile, firstName: e.target.value })} />\r\n          </Grid>\r\n          <Grid item>\r\n            <TextField fullWidth id=\"lastName\" label=\"Last Name\" autoComplete=\"on\" value={profile.lastName} name=\"lastName\" onChange={e => setProfile({ ...profile, lastName: e.target.value })} />\r\n          </Grid>\r\n          <Grid item>\r\n            <TextField fullWidth id=\"email\" label=\"Email\" autoComplete=\"on\" value={profile.email} name=\"email\" onChange={e => setProfile({ ...profile, email: e.target.value })} />\r\n          </Grid>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Image</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <CardActionArea style={{ padding: '12px' }}>\r\n              {!displayImage ?\r\n                <Grid {...getRootProps()} container alignItems=\"center\" direction=\"column\">\r\n                  <input {...getInputProps()} />\r\n                  <Grid item>\r\n                    <Avatar>\r\n                      <PersonIcon />\r\n                    </Avatar>\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"subtitle1\">Click or drag and drop to add a profile pic.</Typography>\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"caption\">Max size: 1MB</Typography>\r\n                  </Grid>\r\n                </Grid> :\r\n                <Grid onClick={deleteFile} container alignItems=\"center\" direction=\"column\">\r\n                  <Grid item>\r\n                    <Avatar src={displayImage} /> {/*<AsyncAvatar image={profile.image || ''} {...props} /> */}\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"h6\" style={{ wordBreak: 'break-all' }}>{user?.image ? \"Current profile image.\" : file ? `${file.name || ''} added.` : ''}</Typography>\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"subtitle1\">To remove, click here then submit.</Typography>\r\n                  </Grid>\r\n                </Grid>\r\n              }\r\n            </CardActionArea>\r\n          </Grid>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Settings</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <PickTheme {...props} />\r\n          </Grid>\r\n        </Grid>\r\n      </Grid>\r\n      <Grid item sm={12} md={8}>\r\n        <Grid container direction=\"column\" spacing={2}>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Group</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <ManageGroups {...props} />\r\n          </Grid>\r\n        </Grid>\r\n      </Grid>\r\n      <Grid item xs={12}>\r\n        <Button className={classes.red} onClick={handleSubmit}>Submit</Button>\r\n      </Grid>\r\n    </Grid>\r\n  </>\r\n}"}
{"prompt":{"fileName":"PendingQuotesMenu.tsx","defaultExportName":"PendingQuotesMenu","hooks":[],"childComponents":[]},"result":"export function PendingQuotesMenu({ handleMenuClose, pendingQuotesAnchorEl, pendingQuotesMenuId, isPendingQuotesOpen }: IProps): JSX.Element {\n\n  const {\n    pendingQuotes,\n    selectedPendingQuotes,\n    handleSelectPendingQuote,\n    handleSelectPendingQuoteAll,\n    approvePendingQuotes,\n    denyPendingQuotes\n  } = useContext(PendingQuotesContext) as PendingQuotesContextType;\n\n  return <Menu\n    anchorEl={pendingQuotesAnchorEl}\n    anchorOrigin={{\n      vertical: 'bottom',\n      horizontal: 'left',\n    }}\n    id={pendingQuotesMenuId}\n    keepMounted\n    transformOrigin={{\n      vertical: 'top',\n      horizontal: 'right',\n    }}\n    open={!!isPendingQuotesOpen}\n    onClose={handleMenuClose}\n  >\n    <List>\n      {pendingQuotes.length ? <Box sx={{ width: 300 }}>\n        <ListItem\n          disablePadding\n          secondaryAction={!!selectedPendingQuotes.length && <>\n            <Tooltip title=\"Approve\">\n              <IconButton\n                edge=\"end\"\n                aria-label={\"approve selected pending quotes\"}\n                onClick={approvePendingQuotes}\n              >\n                <ApprovalIcon />\n              </IconButton>\n            </Tooltip>\n            &nbsp;&nbsp;&nbsp;\n            <Tooltip title=\"Deny\">\n              <IconButton\n                edge=\"end\"\n                aria-label=\"deny selected pending quotes\"\n                onClick={denyPendingQuotes}\n              >\n                <DoNotDisturbIcon />\n              </IconButton>\n            </Tooltip>\n          </>}\n        >\n          <ListItemButton role={undefined} dense>\n            <ListItemIcon>\n              <Checkbox\n                disableRipple\n                tabIndex={-1}\n                onClick={handleSelectPendingQuoteAll}\n                checked={selectedPendingQuotes.length === pendingQuotes.length && pendingQuotes.length !== 0}\n                indeterminate={selectedPendingQuotes.length !== pendingQuotes.length && selectedPendingQuotes.length !== 0}\n                disabled={pendingQuotes.length === 0}\n                inputProps={{ 'aria-label': 'all pending requests selected' }}\n              />\n            </ListItemIcon>\n            <ListItemText primary=\"Pending Requests\" />\n          </ListItemButton>\n        </ListItem>\n\n        <Divider />\n\n        {pendingQuotes.map((pq, i) => {\n          return <ListItem\n            key={`pending_quotes_pqs_${i}`}\n            disablePadding\n          >\n            <ListItemButton role={undefined} onClick={() => handleSelectPendingQuote(pq.id)} dense>\n              <ListItemIcon>\n                <Checkbox\n                  checked={selectedPendingQuotes.indexOf(pq.id) !== -1}\n                  tabIndex={-1}\n                  disableRipple\n                  inputProps={{ 'aria-labelledby': `checkbox-list-label-${i}` }}\n                />\n              </ListItemIcon>\n              <ListItemText\n                id={`checkbox-list-label-${i}`}\n                primary={`${shortNSweet(pq.slotDate, pq.startTime)}`}\n                secondary={`${pq.serviceName} ${pq.serviceTierName} with ${pq.username}`}\n              />\n            </ListItemButton>\n          </ListItem>\n        })}\n      </Box> : <Box sx={{ width: 250 }}>\n        <ListItem>\n          <ListItemText>No pending requests.</ListItemText>\n        </ListItem>\n      </Box>}\n    </List>\n  </Menu>\n}"}
{"prompt":{"fileName":"PendingQuotesProvider.tsx","defaultExportName":"PendingQuotesProvider","hooks":["sh","useUtil"],"childComponents":[]},"result":"export function PendingQuotesProvider ({ children }: IProps): JSX.Element {\n\n  const { setSnack, openConfirm } = useUtil();\n  const [disableQuote] = sh.useDisableQuoteMutation();\n  const [postBooking] = sh.usePostBookingMutation();\n\n  const [pendingQuotesChanged, setPendingQuotesChanged] = useState(false);\n  const [selectedPendingQuotes, setSelectedPendingQuotes] = useState<string[]>([]);\n\n  const { data : profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\n\n  const pendingQuotes = useMemo(() => Object.values(profile?.quotes || {}), [profile]);\n\n  const pendingQuotesContext = {\n    pendingQuotes,\n    pendingQuotesChanged,\n    selectedPendingQuotes,\n    setSelectedPendingQuotes,\n    handleSelectPendingQuote(quote) {\n      const currentIndex = selectedPendingQuotes.indexOf(quote);\n      const newChecked = [...selectedPendingQuotes];\n\n      if (currentIndex === -1) {\n        newChecked.push(quote);\n      } else {\n        newChecked.splice(currentIndex, 1);\n      }\n\n      setSelectedPendingQuotes(newChecked);\n    },\n    handleSelectPendingQuoteAll() {\n      const pendingQuotesSet = selectedPendingQuotes.length === pendingQuotes.length ?\n        selectedPendingQuotes.filter(v => !pendingQuotes.map(pq => pq.id).includes(v)) :\n        [...selectedPendingQuotes, ...pendingQuotes.filter(v => !selectedPendingQuotes.includes(v.id)).map(pq => pq.id)];\n      \n      setSelectedPendingQuotes(pendingQuotesSet);\n    },\n    approvePendingQuotes() {\n      const selectedValues = pendingQuotes.filter(pq => selectedPendingQuotes.includes(pq.id));\n      if (!selectedValues.every(s => s.slotDate === selectedValues[0].slotDate && s.scheduleBracketSlotId === selectedValues[0].scheduleBracketSlotId)) {\n        setSnack({ snackType: 'error', snackOn: 'Only appointments of the same date and time can be mass approved.' });\n        return;\n      }\n\n      const { slotDate, startTime, scheduleBracketSlotId } = selectedValues[0];\n\n      const copies = pendingQuotes.filter(q => !selectedValues.some(s => s.id === q.id)).filter(q => q.slotDate === slotDate && q.scheduleBracketSlotId === scheduleBracketSlotId);\n\n      openConfirm({\n        isConfirming: true,\n        confirmEffect: `Approve ${plural(selectedValues.length, 'request', 'requests')}, creating ${plural(selectedValues.length, 'booking', 'bookings')}, for ${shortNSweet(slotDate, startTime)}.`,\n        confirmSideEffect: !copies.length ? undefined : {\n          approvalAction: 'Auto-Deny Remaining',\n          approvalEffect: `Automatically deny all other requests for ${shortNSweet(slotDate, startTime)} (this cannot be undone).`,\n          rejectionAction: 'Confirm Quote/Booking Only',\n          rejectionEffect: 'Just submit the approvals.',\n        },\n        confirmAction: approval => {\n          const newBookings = selectedValues.map(s => ({\n            quoteId: s.id,\n            slotDate: s.slotDate,\n            scheduleBracketSlotId: s.scheduleBracketSlotId\n          }) as IBooking);\n\n          postBooking({ bookings: newBookings }).unwrap().then(() => {\n            const disableQuoteIds = selectedValues.concat(approval ? copies : []).map(s => s.id).join(',');\n            \n            disableQuote({ ids: disableQuoteIds }).unwrap().then(() => {\n              setSelectedPendingQuotes([]);\n              setPendingQuotesChanged(!pendingQuotesChanged);\n              void getUserProfileDetails();\n            }).catch(console.error);\n          }).catch(console.error);\n        }\n      });\n    },\n    denyPendingQuotes() {\n      disableQuote({ ids: selectedPendingQuotes.join(',') }).unwrap().then(() => {\n        setSelectedPendingQuotes([]);\n        setPendingQuotesChanged(!pendingQuotesChanged);\n        void getUserProfileDetails();\n      }).catch(console.error);\n    }\n  } as PendingQuotesContextType | null;\n\n  return <PendingQuotesContext.Provider value={pendingQuotesContext}>\n    {children}\n  </PendingQuotesContext.Provider>;\n}"}
{"prompt":{"fileName":"QuoteHome.tsx","defaultExportName":"QuoteHome","hooks":["useGrid"],"childComponents":[]},"result":"function QuoteHome(): JSX.Element {\n\n  const {\n    pendingQuotes,\n    selectedPendingQuotes,\n    setSelectedPendingQuotes,\n    approvePendingQuotes,\n    denyPendingQuotes\n  } = useContext(PendingQuotesContext) as PendingQuotesContextType;\n\n  const actions = useMemo(() => {\n    const { length } = selectedPendingQuotes;\n    const acts = length == 1 ? [\n      // Extra actions\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'approve_quote'} title=\"Approve\">\n        <IconButton onClick={approvePendingQuotes}>\n          <ApprovalIcon />\n        </IconButton>\n      </Tooltip>,\n      <Tooltip key={'deny_quote'} title=\"Deny\">\n        <IconButton onClick={denyPendingQuotes}>\n          <DoNotDisturbIcon />\n        </IconButton>\n      </Tooltip>\n    ]\n  }, [selectedPendingQuotes]);\n\n  const QuoteGrid = useGrid<IQuote>({\n    rows: pendingQuotes,\n    columns: [\n      { flex: 1, headerName: 'Booking Slot', field: 'slotDate', renderCell: ({ row }) => shortNSweet(row.slotDate, row.startTime) },\n      { flex: 1, headerName: 'Service', field: 'serviceName' },\n      { flex: 1, headerName: 'Tier', field: 'serviceTierName' },\n      { flex: 1, headerName: 'Requested On', field: 'createdOn', renderCell: ({ row }) => utcDTLocal(row.createdOn) }\n    ],\n    selected: selectedPendingQuotes,\n    onSelected: selection => setSelectedPendingQuotes(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Pending Requests</Typography>\n      {!!selectedPendingQuotes.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  });\n  return <QuoteGrid />\n}"}
{"prompt":{"fileName":"RequestQuote.tsx","defaultExportName":"RequestQuote","hooks":["useComponents","useStyles","useGrid","sh","useUtil"],"childComponents":[]},"result":"export function RequestQuote(props: IProps): JSX.Element {\n  const classes = useStyles();\n\n  const { setSnack } = useUtil();\n  const [getGroupFormById] = sh.useLazyGetGroupFormByIdQuery();\n  const [postQuote] = sh.usePostQuoteMutation();\n  const [getGroupSchedules, { data: groupSchedules }] = sh.useLazyGetGroupSchedulesQuery();\n  const [getGroupScheduleMasterById] = sh.useLazyGetGroupScheduleMasterByIdQuery();\n  const [getGroupUserSchedules, { data: groupUserSchedules }] = sh.useLazyGetGroupUserSchedulesQuery();\n\n  const navigate = useNavigate();\n  const { FileManager, FormDisplay, ScheduleDatePicker, ScheduleTimePicker } = useComponents();\n\n  const [_, { data: dateSlots }] = sh.useLazyGetGroupScheduleByDateQuery();\n\n  const { data: lookups } = sh.useGetLookupsQuery();\n\n  const { data: profile } = sh.useGetUserProfileDetailsQuery();\n\n  const [services, setServices] = useState({} as Record<string, IService>);\n  const [schedule, setSchedule] = useState({ id: '' } as ISchedule);\n  const [service, setService] = useState({ id: '', tiers: {} } as IService);\n  const [tier, setTier] = useState({ id: '' } as IServiceTier);\n  const [serviceForm, setServiceForm] = useState({} as IForm);\n  const [tierForm, setTierForm] = useState({} as IForm);\n  const [group, setGroup] = useState({ id: '' } as IGroup);\n  const [quote, setQuote] = useState({} as IQuote);\n  \n  const [bracketSlotDate, setBracketSlotDate] = useState<dayjs.Dayjs | null>();\n  const [bracketSlotTime, setBracketSlotTime] = useState<dayjs.Dayjs | null>();\n  \n  const [activeSchedule, setActiveSchedule] = useState('');\n  const [firstAvailable, setFirstAvailable] = useState({ time: dayjs().startOf('day') } as IGroupScheduleDateSlots);\n\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\n  const servicesValues = useMemo(() => Object.values(services || {}), [services]);\n\n  const loadSchedule = useCallback((sched: ISchedule) => {\n    sched.scheduleTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.scheduleTimeUnitId)?.name as ITimeUnitNames;\n    sched.bracketTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.bracketTimeUnitId)?.name as ITimeUnitNames;\n    sched.slotTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.slotTimeUnitId)?.name as ITimeUnitNames;    \n    setSchedule(sched);\n  }, [lookups]);\n\n  if (groupsValues.length && !group.id) {\n    setGroup(groupsValues[0]);\n  }\n\n  if (schedule.id && activeSchedule !== schedule.id && dateSlots?.length && !firstAvailable.scheduleBracketSlotId) {\n    const [slot] = dateSlots;\n    setFirstAvailable({ ...slot, time: quotedDT(slot.weekStart, slot.startTime) });\n    setActiveSchedule(schedule.id);\n  }\n\n  const serviceTiers = useMemo(() => Object.values(service.tiers || {}).sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime()), [service.tiers]);\n\n  if (serviceTiers.length && (!tier.id || !serviceTiers.map(t => t.id).includes(tier.id))) {\n    setTier(serviceTiers[0]);\n  }\n\n  if (groupSchedules?.length && !schedule.id) {\n    loadSchedule(groupSchedules[0]);\n  }\n\n  const serviceTierAddons = useMemo(() => {\n    return serviceTiers\n      .sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime())\n      .reduce<string[]>((memo, { addons }) => {\n        const serviceAddons = Object.values(addons);\n        if (serviceAddons) {\n          for (let i = 0, v = serviceAddons.length; i < v; i++) {\n            const { name } = serviceAddons[i];\n            if (memo.indexOf(name) < 0) memo.push(name);\n          }\n        }\n        return memo;\n      }, []);\n  }, [serviceTiers]);\n\n  const TierGrid = useGrid({\n    rows: serviceTierAddons.map(name => ({ name })),\n    columns: [\n      { type: 'string', field: 'name', headerName: '' },\n      ...serviceTiers.reduce((memo, { name, addons }) => {\n        memo.push({\n          headerName: name,\n          field: '',\n          renderCell: ({ row }) => {\n            return Object.values(addons).map(ad => ad.name).indexOf(row.name) > -1 ? <Avatar sx={{ width: 24, height: 24, backgroundColor: 'white' }}><CheckIcon className={classes.green} /></Avatar> : '--';\n          }\n        });\n        return memo;\n      }, [] as GridColDef<{ name: string }>[])\n    ]\n  });\n\n  useEffect(() => {\n    async function go() {\n      const [firstGroupSchedule] = await getGroupSchedules({ groupName: group.name }).unwrap();\n      if (firstGroupSchedule) {\n        const masterSchedule = await getGroupScheduleMasterById({ groupName: group.name, scheduleId: firstGroupSchedule.id }).unwrap();\n        loadSchedule(masterSchedule);\n      }\n    }\n    if (group.name) {\n      void go();\n    }\n  }, [group]);\n\n  useEffect(() => {\n    if (group.name && schedule.id) {\n      getGroupUserSchedules({ groupName: group.name, groupScheduleId: schedule.id }).catch(console.error);\n    }\n  }, [group, schedule]);\n\n  useEffect(() => {\n    if (groupUserSchedules?.length && (!tier.id && !Object.keys(services).length && !service.id)) {\n      let newServices = {} as Record<string, IService>;\n\n      for (const sched of groupUserSchedules) {\n        newServices = { ...newServices, ...sched.services };\n      }\n\n      setServices(newServices);\n  \n      const someService = Object.values(newServices)[0] || {};\n      setService(someService);\n\n      setTier(Object.values(someService.tiers).sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime())[0]);\n    }\n  }, [groupUserSchedules, tier, services, service]);\n\n  useEffect(() => {\n    if (group.name && service.formId && service.formId != serviceForm.id) {\n      getGroupFormById({ groupName: group.name, formId: service.formId }).unwrap().then(groupServiceForm => {\n        setServiceForm(groupServiceForm);\n      }).catch(console.error);\n    }\n  }, [service, serviceForm, group]);\n\n  useEffect(() => {\n    if (group.name && tier.formId && tier.formId != tierForm.id) {\n      getGroupFormById({ groupName: group.name, formId: tier.formId }).unwrap().then(groupTierForm => {\n        setTierForm(groupTierForm);\n      }).catch(console.error);\n    }\n  }, [tier, tierForm, group]);\n\n  return <>\n    <Grid container spacing={2}>\n\n      <Grid item xs={12}>\n        <Card>\n          <CardHeader\n            title=\"Create Request\"\n            subheader=\"Request services from a group. Some fields may be required depending on the service.\"\n            action={\n              <TextField\n                select\n                value={group.id}\n                label=\"Group\"\n                onChange={e => setGroup(groupsValues.filter(g => g.id === e.target.value)[0])}\n              >\n                {groupsValues.map(group => <MenuItem key={`group-select${group.id}`} value={group.id}>{group.name}</MenuItem>)}\n              </TextField>\n            }\n          />\n          <CardContent>\n\n            <Grid container spacing={2}>\n              <Grid item xs={4}>\n                <TextField\n                  select\n                  label=\"Schedules\"\n                  fullWidth\n                  value={schedule.id}\n                  onChange={e => {\n                    if (e.target.value !== schedule.id) {\n                      const sched = groupSchedules?.find(gs => gs.id === e.target.value);\n                      if (sched) {\n                        loadSchedule(sched);\n                      }\n                    }\n                  }}\n                >\n                  {groupSchedules?.map((sched, i) => <MenuItem key={i} value={sched.id}>{sched.name}</MenuItem>)}\n                </TextField>\n              </Grid>\n              <Grid item xs={4}>\n                <TextField\n                  select\n                  label=\"Service\"\n                  fullWidth\n                  value={service.id}\n                  onChange={e => {\n                    const serv = services[e.target.value];\n                    if (serv) {\n                      setService(serv);\n                    }\n                  }}\n                >\n                  {servicesValues.map((service, i) => <MenuItem key={`service_request_selection_${i}`} value={service.id}>{service.name}</MenuItem>)}\n                </TextField>\n              </Grid>\n              <Grid item xs={4}>\n                <TextField\n                  select\n                  label=\"Level\"\n                  fullWidth\n                  value={tier.id}\n                  onChange={e => {\n                    setTier(serviceTiers.find(t => t.id === e.target.value) as IServiceTier);\n                  }}\n                >\n                  {serviceTiers.sort((a, b) => new Date(b.createdOn).getTime() - new Date(a.createdOn).getTime()).map((tier, i) => {\n                    return <MenuItem key={i} value={tier.id}>{tier.name}</MenuItem>\n                  })}\n                </TextField>\n              </Grid>\n            </Grid>\n\n          </CardContent>\n        </Card>\n\n        <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"tiers-and-features-content\"\n            id=\"tiers-and-features-header\"\n          >\n            <Typography>Features</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <TierGrid />\n          </AccordionDetails>\n        </Accordion>\n\n        {serviceForm.version && <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"service-request-section-service-questionnaire-content\"\n            id=\"service-request-section-service-questionnaire-header\"\n          >\n            <Typography>{service.name} Questionnaire</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <FormDisplay form={serviceForm} setForm={setServiceForm} />\n          </AccordionDetails>\n        </Accordion>}\n\n        {tierForm.version && <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"service-request-section-tier-questionnaire-content\"\n            id=\"service-request-section-tier-questionnaire-header\"\n          >\n            <Typography>{tier.name} Questionnaire</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <FormDisplay form={tierForm} setForm={setTierForm} />\n          </AccordionDetails>\n        </Accordion>}\n\n        <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"service-request-section-time-selection-content\"\n            id=\"service-request-section-time-selection-header\"\n          >\n            <Typography>Schedule</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <Grid container spacing={2}>\n              <Grid item xs={4}>\n                <ScheduleDatePicker\n                  key={schedule.id}\n                  scheduleId={schedule.id}\n                  groupName={group.name}\n                  firstAvailable={firstAvailable}\n                  value={bracketSlotDate || firstAvailable.time || null}\n                  onDateChange={(date: dayjs.Dayjs | null) => setBracketSlotDate(date ? date.isBefore(firstAvailable.time) ? firstAvailable.time : date  : null)}\n                />\n              </Grid>\n              {timeUnitOrder.indexOf(schedule.slotTimeUnitName) <= timeUnitOrder.indexOf(TimeUnit.HOUR) && <Grid item xs={4}>\n                <ScheduleTimePicker\n                  key={schedule.id}\n                  firstAvailable={firstAvailable}\n                  bracketSlotDate={bracketSlotDate}\n                  bracketTimeUnitName={schedule.bracketTimeUnitName}\n                  slotTimeUnitName={schedule.slotTimeUnitName}\n                  value={bracketSlotTime || firstAvailable.time}\n                  onTimeChange={({ time, quote: newQuote }: { time: dayjs.Dayjs | null, quote?: IQuote }) => {\n                    setBracketSlotTime(time);\n                    if (newQuote) {\n                      setQuote({\n                        ...quote,\n                        ...newQuote\n                      })\n                    }\n                  }}\n                  onTimeAccept={(newQuote: IQuote) => {\n                    setQuote({\n                      ...quote,\n                      ...newQuote\n                    })\n                  }}\n                />\n              </Grid>}\n\n              {/*\n              TODO LATER SHOULD ONLY SHOW USER SELECTION BASED ON AUTO/ROUND-ROBIN/DIRECT-SELECT\n              {quote.scheduleBracketSlotId && <Grid item xs={4}>\n                <TextField\n                  select\n                  fullWidth\n                  label=\"User\"\n                  value={quote.scheduleBracketSlotId}\n                  onChange={e => {\n                    setQuote({ ...quote, scheduleBracketSlotId: e.target.value })\n                  }}\n                >\n                  {bracketsValues\n                    .filter(bv => Object.values(bv.slots).findIndex(s => s.startTime === quote.slotTime) === -1)\n                    .map((bv, i) => {\n                      const { name } = Object.values(groupUserSchedules).find(gus => gus.userScheduleId === bv.scheduleId) || {};\n                      return <MenuItem key={`schedule-slot-selection-${i}`} value={bv.id}>{name}</MenuItem>\n                    })}\n                </TextField>\n              </Grid>} */}\n            </Grid>\n          </AccordionDetails>\n        </Accordion>\n\n        <FileManager {...props} />\n      </Grid>\n\n      <Grid item xs={12}>\n        <Card>\n          <CardActionArea onClick={async () => {\n            quote.serviceTierId = tier.id;\n\n            if (!quote.scheduleBracketSlotId) {\n              const { scheduleBracketSlotId, startDate } = firstAvailable;\n              quote.scheduleBracketSlotId = scheduleBracketSlotId;\n              quote.slotDate = startDate;\n            }\n\n            if (Object.keys(serviceForm).length) {\n              const missingValues = Object.keys(serviceForm.version.form).some(rowId => serviceForm.version.form[rowId].some((field, i) => field.r && [undefined, ''].includes(serviceForm.version.submission[rowId][i])));\n              if (missingValues) {\n                setSnack({ snackType: 'error', snackOn: 'The Service Questionnaire is missing required fields!' });\n                return;\n              }\n              quote.serviceForm = {\n                formVersionId: serviceForm.version.id,\n                submission: serviceForm.version.submission\n              }\n            }\n\n            if (Object.keys(tierForm).length) {\n              const missingValues = Object.keys(tierForm.version.form).some(rowId => tierForm.version.form[rowId].some((field, i) => field.r && [undefined, ''].includes(tierForm.version.submission[rowId][i])));\n              if (missingValues) {\n                setSnack({ snackType: 'error', snackOn: 'The Tier Questionnaire is missing required fields!' });\n                return;\n              }\n              quote.tierForm = {\n                formVersionId: tierForm.version.id,\n                submission: tierForm.version.submission\n              }\n            }\n\n            await postQuote(quote).unwrap();\n            setSnack({ snackOn: 'Your request has been made successfully!' });\n            navigate('/');\n            \n          }}>\n            <Box m={2} sx={{ display: 'flex' }}>\n              <Typography color=\"secondary\" variant=\"button\">Submit Request</Typography>\n            </Box>\n          </CardActionArea>\n        </Card>\n      </Grid>\n\n    </Grid>\n  </>\n\n}"}
{"prompt":{"fileName":"ManageRoleActions.tsx","defaultExportName":"ManageRoleActions","hooks":["useGrid","useAppSelector","sh","useUtil"],"childComponents":[]},"result":"export function ManageRoleActions(): JSX.Element {\r\n  const { groupName } = useParams();\r\n  if (!groupName) return <></>;\r\n\r\n  const { setSnack, setUpdateAssignments } = useUtil();\r\n  const [putAssignments] = sh.usePutGroupAssignmentsMutation();\r\n\r\n  const { data: availableGroupAssignments } = sh.useGetGroupAssignmentsQuery({ groupName })\r\n\r\n  const { data: profile } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const { canSubmitAssignments } = useAppSelector(state => state.util);\r\n  \r\n  const [assignments, setAssignments] = useState(availableGroupAssignments || {});\r\n\r\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\r\n\r\n  const handleCheck = useCallback((subgroup: string, action: string, add: boolean) => {\r\n    const newAssignments = { ...assignments };\r\n    newAssignments[subgroup] = { actions: add ? [...(newAssignments[subgroup]?.actions || []), { name: action }] : newAssignments[subgroup]?.actions.filter(a => a.name !== action) };\r\n    setAssignments(newAssignments);\r\n  }, [assignments]);\r\n\r\n  const handleSubmit = useCallback(() => {\r\n    try {\r\n      setUpdateAssignments({ canSubmitAssignments: false });\r\n      putAssignments({ groupName, assignments }).unwrap().then(() => {\r\n        setSnack({ snackType: 'success', snackOn: 'Assignments can be updated again in 1 minute.' });\r\n        setTimeout(() => setUpdateAssignments({ canSubmitAssignments: true }), 58 * 1000);\r\n      }).catch(console.error);\r\n    } catch (error) {\r\n      setUpdateAssignments({ canSubmitAssignments: true });\r\n    }\r\n  }, [groupName, assignments]);\r\n\r\n  const columns = useMemo(() => {\r\n    if (groupsValues.length && groupName) {\r\n      const group = groupsValues.find(g => g.name === groupName);\r\n      if (group && Object.keys(group.roles).length) {\r\n\r\n        const cols: GridColDef<{ name: string }>[] = [{ width: 200, field: 'id', headerName: '', renderCell: ({ row }) => row.name } as GridColDef<{ name: string }>];\r\n        \r\n        for (const roleId in group.roles) {\r\n          const { name } = group.roles[roleId];\r\n          const subgroup = `/${groupName}/${name}`;\r\n          cols.push({\r\n            flex: 1,\r\n            minWidth: 75,\r\n            headerName: name,\r\n            field: name,\r\n            renderCell: ({ row }) => <Checkbox\r\n              checked={assignments[subgroup] ? assignments[subgroup].actions.some(a => a.name === row.name) : false}\r\n              onChange={e => handleCheck(subgroup, row.name, e.target.checked)}\r\n            />\r\n          });\r\n        }\r\n        \r\n        return cols;\r\n      }\r\n    }\r\n    return [];\r\n  }, [groupsValues, assignments, groupName]);\r\n\r\n  const options = useMemo(() => Object.values(SiteRoles).filter(r => ![SiteRoles.APP_ROLE_CALL, SiteRoles.APP_GROUP_ADMIN].includes(r)).map((name, id) => ({ id, name })), []);\r\n\r\n  const RoleActionGrid = useGrid({\r\n    rows: options,\r\n    columns,\r\n    noPagination: true\r\n  });\r\n\r\n  return <>\r\n\r\n    <Grid container>\r\n      <Grid item mb={2} xs={12}>\r\n        <Card>\r\n          <CardActionArea disabled={!canSubmitAssignments} onClick={handleSubmit}>\r\n            <Grid container direction=\"row\" justifyContent=\"space-between\">\r\n              <Grid item>\r\n                <Box m={2}>\r\n                  <Typography color=\"secondary\" variant=\"button\">Update Assignments </Typography>\r\n                </Box>\r\n              </Grid>\r\n              <Grid item>\r\n                <Box m={2}>\r\n                  <Typography color=\"GrayText\" variant=\"button\">Changes will persist within 1 minute</Typography>\r\n                </Box>\r\n              </Grid>\r\n            </Grid>\r\n          </CardActionArea>\r\n        </Card>\r\n      </Grid>\r\n    </Grid>\r\n\r\n    <RoleActionGrid />\r\n\r\n  </>\r\n}"}
{"prompt":{"fileName":"ManageRoleModal.tsx","defaultExportName":"ManageRoleModal","hooks":["useUtil","sh"],"childComponents":[]},"result":"export function ManageRoleModal ({ editRole, closeModal }: IProps): JSX.Element {\r\n\r\n  const { setSnack } = useUtil();\r\n  const [putRole] = sh.usePutRoleMutation();\r\n  const [postRole] = sh.usePostRoleMutation();\r\n\r\n  const [role, setRole] = useState<Partial<IRole>>({\r\n    name: '',\r\n    ...editRole\r\n  });\r\n  \r\n  const handleSubmit = useCallback(() => {\r\n    const { id, name } = role;\r\n\r\n    if (!name) {\r\n      setSnack({snackType: 'error', snackOn: 'Roles must have a name.' });\r\n      return;\r\n    }\r\n\r\n    (id ? putRole : postRole)(role as IRole).unwrap().then(() => {\r\n      if (closeModal)\r\n        closeModal();\r\n    }).catch(console.error);\r\n  }, [role]);\r\n\r\n  return <>\r\n    <Card>\r\n      <CardContent>\r\n        <Typography variant=\"button\">Manage role</Typography>\r\n        <Grid container direction=\"row\" spacing={2}>\r\n          <Grid item xs={12}>\r\n            <Grid container direction=\"column\" spacing={4} justifyContent=\"space-evenly\" >\r\n              <Grid item>\r\n                <Typography variant=\"h6\">Role</Typography>\r\n              </Grid>\r\n              <Grid item>\r\n                <TextField\r\n                  fullWidth\r\n                  autoFocus\r\n                  id=\"name\"\r\n                  label=\"Name\"\r\n                  name=\"name\"\r\n                  value={role.name}\r\n                  onKeyDown={e => {\r\n                    if ('Enter' === e.key) {\r\n                      handleSubmit();\r\n                    }\r\n                  }}\r\n                  onChange={e => setRole({ ...role, name: e.target.value })} />\r\n              </Grid>\r\n            </Grid>\r\n          </Grid>\r\n        </Grid>\r\n      </CardContent>\r\n      <CardActions>\r\n        <Grid container justifyContent=\"space-between\">\r\n          <Button onClick={closeModal}>Cancel</Button>\r\n          <Button onClick={handleSubmit}>Submit</Button>\r\n        </Grid>\r\n      </CardActions>\r\n    </Card>\r\n  </>\r\n}"}
{"prompt":{"fileName":"ManageRoles.tsx","defaultExportName":"ManageRoles","hooks":["sh","useGrid"],"childComponents":[]},"result":"export function ManageRoles(props: IProps): JSX.Element {\r\n\r\n  const { data: profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const [deleteRole] = sh.useDeleteRoleMutation();\r\n\r\n  const [role, setRole] = useState<IRole>();\r\n  const [selected, setSelected] = useState<string[]>([]);\r\n  const [dialog, setDialog] = useState('');\r\n\r\n  const actions = useMemo(() => {\r\n    const { length } = selected;\r\n    const acts = length == 1 ? [\r\n      <Tooltip key={'manage_role'} title=\"Edit\">\r\n        <Button onClick={() => {\r\n          if (profile?.roles) {\r\n            setRole(profile?.roles[selected[0]]);\r\n            setDialog('manage_role');\r\n            setSelected([]);\r\n          }\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\r\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ] : [];\r\n\r\n    return [\r\n      ...acts,\r\n      <Tooltip key={'delete_role'} title=\"Delete\">\r\n        <Button onClick={async () => {\r\n          await deleteRole({ ids: selected.join(',') }).unwrap();\r\n          void getUserProfileDetails();\r\n          setSelected([]);\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\r\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ]\r\n  }, [selected]);\r\n\r\n  const RoleGrid = useGrid({\r\n    rows: Object.values(profile?.roles || {}),\r\n    columns: [\r\n      { flex: 1, headerName: 'Name', field: 'name' },\r\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\r\n    ],\r\n    selected,\r\n    onSelected: selection => setSelected(selection as string[]),\r\n    toolbar: () => <>\r\n      <Typography variant=\"button\">Roles:</Typography>\r\n      <Tooltip key={'manage_role'} title=\"Create\">\r\n        <Button onClick={() => {\r\n          setRole(undefined);\r\n          setDialog('manage_role')\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\r\n          <GroupAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\r\n    </>\r\n  })\r\n\r\n  return <>\r\n    <Dialog open={dialog === 'manage_role'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <ManageRoleModal {...props} editRole={role} closeModal={() => {\r\n          setDialog('')\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <RoleGrid />\r\n  </>\r\n}"}
{"prompt":{"fileName":"ManageScheduleBrackets.tsx","defaultExportName":"ManageScheduleBrackets","hooks":["useGrid","useUtil","sh"],"childComponents":[]},"result":"export function ManageScheduleBrackets(props: IProps): JSX.Element {\n\n  const { setSnack, openConfirm } = useUtil();\n\n  const [deleteGroupUserScheduleByUserScheduleId] = sh.useDeleteGroupUserScheduleByUserScheduleIdMutation();\n  const [deleteSchedule] = sh.useDeleteScheduleMutation()\n\n  const [schedule, setSchedule] = useState<ISchedule>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n  const [group, setGroup] = useState({ id: '' } as IGroup);\n\n  const { data: schedules } = sh.useGetSchedulesQuery();\n  const { data: profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\n\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\n\n  if (groupsValues.length && !group.id) {\n    setGroup(groupsValues[0]);\n  }\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <IconButton key={'manage_schedule'} onClick={() => {\n        setSchedule(schedules?.find(s => s.id === selected[0]));\n        setDialog('manage_schedule');\n        setSelected([]);\n      }}>\n        <CreateIcon />\n      </IconButton>\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_schedule'} title=\"Delete\"><IconButton onClick={() => {\n        if (group.name) {\n          openConfirm({\n            isConfirming: true,\n            confirmEffect: `Remove ${plural(selected.length, 'schedule', 'schedules')}. This cannot be undone.`,\n            confirmAction: async () => {\n              const ids = selected.join(',');\n              await deleteGroupUserScheduleByUserScheduleId({ groupName: group.name, ids }).unwrap();\n              await deleteSchedule({ ids }).unwrap();\n              void getUserProfileDetails();\n              setSnack({ snackType: 'success', snackOn: 'Successfully removed schedule records.' });\n            }\n          });\n        }\n      }}>\n        <DeleteIcon />\n      </IconButton></Tooltip>\n    ]\n  }, [selected, group]);\n\n  const ScheduleBracketGrid = useGrid({\n    rows: schedules || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <TextField\n        select\n        value={group.id}\n        label=\"Group\"\n        variant=\"standard\"\n        onChange={e => {\n          if (profile?.groups) {\n            const gr = profile?.groups[e.target.value];\n            if (gr) setGroup(gr);\n          }\n        }}\n      >\n        {groupsValues.map(group => <MenuItem key={`group-select${group.id}`} value={group.id}>{group.name}</MenuItem>)}\n      </TextField>\n      <Box pt={2} sx={{ width: '100%' }}>\n        <Typography variant=\"button\">Schedules:</Typography>\n        <Button key={'create_schedule_button'} onClick={() => {\n          if (schedules?.length) {\n            setSchedule(undefined);\n            setDialog('manage_schedule');\n          } else {\n            setSnack({ snackType: 'warning', snackOn: 'There are no active group schedules.' })\n          }\n        }}>Create</Button>\n        {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n      </Box>\n    </>\n  })\n\n  return <>\n    <Dialog open={dialog === 'manage_schedule'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageScheduleBracketsModal {...props} group={group} editSchedule={schedule} closeModal={() => {\n          setDialog('');\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <ScheduleBracketGrid />\n  </>\n}"}
{"prompt":{"fileName":"ManageScheduleBracketsModal.tsx","defaultExportName":"ManageScheduleBracketsModal","hooks":["useComponents","sh","useUtil"],"childComponents":[]},"result":"export function ManageScheduleBracketsModal({ group, editSchedule, closeModal, ...props }: IProps): JSX.Element {\n\n  if (!group?.name) return <></>;\n\n  const { setSnack } = useUtil();\n\n  const { data: lookups } = sh.useGetLookupsQuery();\n  const { data: schedules } = sh.useGetSchedulesQuery();\n  const { data: groupServices } = sh.useGetGroupServicesQuery({ groupName: group.name });\n  const { data: groupSchedules } = sh.useGetGroupSchedulesQuery({ groupName: group.name });\n\n  const [getUserProfileDetails] = sh.useLazyGetUserProfileDetailsQuery();\n  const [getScheduleById] = sh.useLazyGetScheduleByIdQuery();\n  const [postSchedule] = sh.usePostScheduleMutation();\n  const [postScheduleBrackets] = sh.usePostScheduleBracketsMutation();\n  const [postGroupUserSchedule] = sh.usePostGroupUserScheduleMutation()\n  \n  const { ScheduleDisplay } = useComponents();\n\n  const scheduleParent = useRef<HTMLDivElement>(null);\n  const [viewStep, setViewStep] = useState(1);\n  const [schedule, setSchedule] = useState({ ...scheduleSchema, brackets: {} } as ISchedule);\n  const [bracket, setBracket] = useState({ ...bracketSchema, services: {}, slots: {} } as IScheduleBracket);\n\n  const attachScheduleUnits = useCallback((sched: ISchedule) => {\n    sched.scheduleTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.scheduleTimeUnitId)?.name as ITimeUnitNames;\n    sched.bracketTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.bracketTimeUnitId)?.name as ITimeUnitNames;\n    sched.slotTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.slotTimeUnitId)?.name as ITimeUnitNames;\n  }, [lookups]);\n\n  useEffect(() => {\n    if (groupSchedules?.length) {\n      if (editSchedule) {\n        getScheduleById({ id: editSchedule.id }).catch(console.error);\n      } else {\n        const sched = groupSchedules[0];\n        attachScheduleUnits(sched);\n        setSchedule({ ...sched, brackets: {} });\n      }\n    }\n  }, [editSchedule, groupSchedules]);\n\n  useEffect(() => {\n    if (editSchedule) {\n      const sched = schedules?.find(s => s.id === editSchedule.id);\n      if (sched) {\n        attachScheduleUnits(sched);\n        setSchedule({ ...sched });\n        if (Object.keys(sched.brackets).length) {\n          setViewStep(2);\n        }\n      }\n    }\n  }, [editSchedule, schedules]);\n\n  const scheduleBracketsValues = useMemo(() => Object.values(schedule.brackets || {}), [schedule.brackets]);\n  const bracketServicesValues = useMemo(() => Object.values(bracket.services || {}), [bracket.services]);\n\n  const remainingBracketTime = useMemo(() => {\n    if (schedule.scheduleTimeUnitName) {\n      // Complex time adjustment example - this gets the remaining time that can be scheduled based on the schedule context, which always selects its first child as the subcontext (Week > Day), multiply this by the schedule duration in that context (1 week is 7 days), then convert the result to whatever the bracket type is. So if the schedule is for 40 hours per week, the schedule duration is 1 week, which is 7 days. The bracket, in hours, gives 24 hrs per day * 7 days, resulting in 168 total hours. Finally, subtract the time used by selected slots in the schedule display.\n      const scheduleUnitChildUnit = timeUnitOrder[timeUnitOrder.indexOf(schedule.scheduleTimeUnitName) - 1];\n      const scheduleChildDuration = getRelativeDuration(1, schedule.scheduleTimeUnitName, scheduleUnitChildUnit); // 7\n      const usedDuration = scheduleBracketsValues.reduce((m, d) => m + d.duration, 0);\n      const totalDuration = getRelativeDuration(Math.floor(scheduleChildDuration), scheduleUnitChildUnit, schedule.bracketTimeUnitName);\n      return Math.floor(totalDuration - usedDuration);\n    }\n    return 0;\n  }, [schedule, scheduleBracketsValues]);\n\n  const handleSubmit = useCallback(async () => {\n    if (schedule) {\n      const { name, scheduleTimeUnitName } = schedule;\n      if (name && scheduleTimeUnitName && scheduleBracketsValues.length) {\n        const userSchedule = { ...schedule };\n        if (!editSchedule) {\n          const newSchedule = await postSchedule(schedule).unwrap();\n          userSchedule.id = newSchedule.id;\n        }\n        \n        const newBrackets = scheduleBracketsValues.map(\n          ({ id, duration, automatic, multiplier, slots, services }) => [\n            id,\n            {\n              id,\n              duration,\n              automatic,\n              multiplier,\n              slots: Object.values(slots).map(({ startTime }, i) => [String(i), { startTime } as IScheduleBracketSlot]),\n              services: Object.values(services).map(({ id }, i) => [String(i), { id } as IService])\n            }\n          ]\n        );\n\n        await postScheduleBrackets({\n          scheduleId: userSchedule.id,\n          brackets: Object.fromEntries(newBrackets) as Record<string, IScheduleBracket>\n        }).catch(console.error);\n\n        if (!editSchedule) {\n          await postGroupUserSchedule({\n            groupName: group?.name,\n            userScheduleId: userSchedule.id,\n            groupScheduleId: schedule.id\n          }).catch(console.error);\n        }\n\n        await getUserProfileDetails().catch(console.error);\n        setSnack({ snackOn: 'Successfully added ' + name, snackType: 'info' });\n        if (closeModal) closeModal();\n      } else {\n        setSnack({ snackOn: 'A schedule should have a name, a duration, and at least 1 bracket.', snackType: 'info' });\n      }\n    }\n  }, [group, schedule, scheduleBracketsValues]);\n\n  return <>\n    <DialogTitle>{!editSchedule?.id ? 'Create' : 'Manage'} Schedule Bracket</DialogTitle>\n    <DialogContent>\n\n      {1 === viewStep ? <>\n        <Box mt={2} />\n\n        <Box mb={4}>\n          <TextField\n            select\n            fullWidth\n            disabled={!!editSchedule?.id}\n            label=\"Group Schedules\"\n            helperText=\"Select a group schedule to add to.\"\n            value={schedule.id}\n            onChange={e => {\n              if (!editSchedule) {\n                const sched = groupSchedules?.find(gs => gs.id === e.target.value);\n                if (sched) {\n                  attachScheduleUnits(sched);\n                  setSchedule({ ...sched, brackets: {} });\n                }\n              }\n            }}\n          >\n            {groupSchedules?.map(s => {\n              return <MenuItem\n                key={`schedule-select${s.id}`}\n                value={s.id}\n                sx={{ alignItems: 'baseline' }}\n              >\n                {s.name}&nbsp;&nbsp;&nbsp;\n                <Typography variant=\"caption\" fontSize={10}>Timezone: {s.timezone}</Typography>\n              </MenuItem>\n            })}\n          </TextField>\n        </Box>\n\n        <Box mb={4}>\n          <Typography variant=\"body1\"></Typography>\n          <TextField\n            fullWidth\n            type=\"number\"\n            helperText={`Number of ${schedule.bracketTimeUnitName}s for this schedule. (Remaining: ${remainingBracketTime})`}\n            label={`# of ${schedule.bracketTimeUnitName}s`}\n            value={bracket.duration || ''}\n            onChange={e => setBracket({ ...bracket, duration: Math.min(Math.max(0, parseInt(e.target.value || '', 10)), remainingBracketTime) })}\n          />\n        </Box>\n\n        <Box sx={{ display: 'none' }}>\n          <Typography variant=\"h6\">Multiplier</Typography>\n          <Typography variant=\"body2\">Affects the cost of all services in this bracket.</Typography>\n          <Box sx={{ display: 'flex', alignItems: 'baseline' }}>\n            <Box>{bracket.multiplier}x <span>&nbsp;</span> &nbsp;</Box>\n            <Slider value={parseFloat(bracket.multiplier || '')} onChange={(_, val) => setBracket({ ...bracket, multiplier: parseFloat(val.toString()).toFixed(2) })} step={.01} min={1} max={5} />\n          </Box>\n        </Box>\n\n        <Box sx={{ display: 'none' }}>\n          <Typography variant=\"h6\">Automatic</Typography>\n          <Typography variant=\"body2\">Bracket will automatically accept new bookings.</Typography>\n          <Switch color=\"primary\" value={bracket.automatic} onChange={e => setBracket({ ...bracket, automatic: e.target.checked })} />\n        </Box>\n\n        <Box mb={4}>\n          <TextField\n            select\n            fullWidth\n            label=\"Services\"\n            helperText=\"Select the services available to be scheduled.\"\n            value={''}\n            onChange={e => {\n              const serv = groupServices?.find(gs => gs.id === e.target.value);\n              if (serv) {\n                bracket.services[e.target.value] = serv;\n                setBracket({ ...bracket, services: { ...bracket.services } });\n              }\n            }}\n          >\n            {groupServices?.filter(s => !Object.keys(bracket.services).includes(s.id)).map(service => <MenuItem key={`service-select${service.id}`} value={service.id}>{service.name}</MenuItem>)}\n          </TextField>\n\n          <Box sx={{ display: 'flex', alignItems: 'flex-end', flexWrap: 'wrap' }}>\n            {bracketServicesValues.map((service, i) => {\n              return <Box key={`service-chip${i + 1}new`} m={1}><Chip label={`${service.name} ${service.cost ? `Cost: ${service.cost}` : ''}`} onDelete={() => {\n                delete bracket.services[service.id];\n                setBracket({ ...bracket, services: { ...bracket.services } });\n              }} /></Box>\n            })}\n          </Box>\n        </Box>\n      </> : <>\n        <Suspense fallback={<CircularProgress />}>\n          <ScheduleDisplay {...props} parentRef={scheduleParent} schedule={schedule} setSchedule={setSchedule} />\n        </Suspense>\n      </>}\n    </DialogContent>\n    <DialogActions>\n      <Grid container justifyContent=\"space-between\">\n        <Button onClick={closeModal}>Cancel</Button>\n        {1 === viewStep ? <Grid item>\n          {!!scheduleBracketsValues.length && <Button\n            onClick={() => {\n              setViewStep(2);\n              setBracket({ ...bracketSchema, services: {}, slots: {} } as IScheduleBracket);\n            }}\n          >\n            Cancel Add\n          </Button>}\n          <Button\n            disabled={!bracket.duration || !bracketServicesValues.length}\n            onClick={() => {\n              if (bracket.duration && Object.keys(bracket.services).length) {\n                bracket.id = (new Date()).getTime().toString();\n                bracket.scheduleId = schedule.id;\n                schedule.brackets[bracket.id] = bracket;\n                setSchedule({ ...schedule, brackets: schedule.brackets })\n                setBracket({ ...bracketSchema, services: {}, slots: {} } as IScheduleBracket);\n                setViewStep(2);\n              } else {\n                void setSnack({ snackOn: 'Provide a duration, and at least 1 service.', snackType: 'info' });\n              }\n            }}\n          >\n            Continue\n          </Button>\n        </Grid> : <Grid item>\n          <Button onClick={() => { setViewStep(1); }}>Add another</Button>\n          <Button onClick={handleSubmit}>Submit</Button>\n        </Grid>}\n      </Grid>\n    </DialogActions>\n  </>\n}"}
{"prompt":{"fileName":"ManageSchedules.tsx","defaultExportName":"ManageSchedules","hooks":["useComponents","useGrid","sh","useUtil"],"childComponents":[]},"result":"export function ManageSchedules(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { openConfirm } = useUtil();\n  const { ManageScheduleStubs } = useComponents();\n\n  const [deleteGroupSchedule] = sh.useDeleteGroupScheduleMutation();\n  \n  const { data: groupSchedules, refetch: getGroupSchedules } = sh.useGetGroupSchedulesQuery({ groupName: groupName });\n\n  const [schedule, setSchedule] = useState<ISchedule>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <Tooltip key={'manage_schedule'} title=\"Edit\">\n        <Button onClick={() => {\n          setSchedule(groupSchedules?.find(gs => gs.id === selected[0]));\n          setDialog('manage_schedule');\n          setSelected([]);\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_schedule'} title=\"Delete\">\n        <Button onClick={() => {\n          openConfirm({\n            isConfirming: true,\n            confirmEffect: 'Are you sure you want to delete these schedules? This cannot be undone.',\n            confirmAction: async () => {\n              await deleteGroupSchedule({ groupName, ids: selected.join(',') }).unwrap();\n              void getGroupSchedules();\n              setSelected([]);\n            }\n          });\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ]\n  }, [selected, groupName]);\n\n  const ScheduleGrid = useGrid({\n    rows: groupSchedules || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Master Schedules:</Typography>\n      <Tooltip key={'manage_role'} title=\"Create\">\n        <Button onClick={() => {\n          setSchedule(undefined);\n          setDialog('manage_schedule')\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\n          <MoreTimeIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  });\n\n  return <>\n    <Dialog open={dialog === 'manage_schedule'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageSchedulesModal {...props} editSchedule={schedule} closeModal={() => {\n          setDialog('');\n          void getGroupSchedules();\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <Box mb={2}>\n      <ScheduleGrid />\n    </Box>\n\n    <Box mb={2}>\n      <ManageScheduleStubs {...props} />\n    </Box>\n  </>\n}"}
{"prompt":{"fileName":"ManageSchedulesModal.tsx","defaultExportName":"ManageScheduleModal","hooks":["useComponents","useUtil","sh"],"childComponents":[]},"result":"export function ManageScheduleModal({ editSchedule, closeModal, ...props }: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { setSnack } = useUtil();\n\n  const [postGroupSchedule] = sh.usePostGroupScheduleMutation();\n  const [putGroupSchedule] = sh.usePutGroupScheduleMutation();\n  const [getGroupSchedules] = sh.useLazyGetGroupSchedulesQuery();\n  const [getGroupScheduleMasterById] = sh.useLazyGetGroupScheduleMasterByIdQuery();\n\n  const { data: lookups } = sh.useGetLookupsQuery();\n  \n  const { SelectLookup } = useComponents();\n  \n  const [schedule, setSchedule] = useState({ ...scheduleSchema, ...editSchedule } as ISchedule);\n\n  const attachScheduleUnits = useCallback((sched: ISchedule): ISchedule => {\n    sched.scheduleTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.scheduleTimeUnitId)?.name as ITimeUnitNames;\n    sched.bracketTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.bracketTimeUnitId)?.name as ITimeUnitNames;\n    sched.slotTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.slotTimeUnitId)?.name as ITimeUnitNames;\n    return sched;\n  }, [lookups]);\n\n  const setDefault = useCallback((type: string) => {\n    const weekId = lookups?.timeUnits?.find(s => s.name === TimeUnit.WEEK)?.id;\n    const hourId = lookups?.timeUnits?.find(s => s.name === TimeUnit.HOUR)?.id;\n    const dayId = lookups?.timeUnits?.find(s => s.name === TimeUnit.DAY)?.id;\n    const minuteId = lookups?.timeUnits?.find(s => s.name === TimeUnit.MINUTE)?.id;\n    const monthId = lookups?.timeUnits?.find(s => s.name === TimeUnit.MONTH)?.id;\n    if ('40hoursweekly30minsessions' === type) {\n      setSchedule(attachScheduleUnits({\n        ...schedule,\n        scheduleTimeUnitId: weekId as string,\n        bracketTimeUnitId: hourId as string,\n        slotTimeUnitId: minuteId as string,\n        slotDuration: 30\n      }));\n    } else if ('dailybookingpermonth') {\n      setSchedule(attachScheduleUnits({\n        ...schedule,\n        scheduleTimeUnitId: monthId as string,\n        bracketTimeUnitId: weekId as string,\n        slotTimeUnitId: dayId as string,\n        slotDuration: 1\n      }));\n    }\n  }, [lookups, schedule]);\n\n  const slotDurationMarks = useMemo(() => {\n    const { scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName } = schedule;\n    const factors = [] as Mark[];\n    if (!bracketTimeUnitName || !slotTimeUnitName || !scheduleTimeUnitName) return factors;\n    // const subdivided = bracketTimeUnitName !== slotTimeUnitName;\n    // const finalDuration = !subdivided ? \n    //   Math.round(getRelativeDuration(duration, scheduleTimeUnitName, bracketTimeUnitName)) : \n    const finalDuration = Math.round(getRelativeDuration(1, bracketTimeUnitName, slotTimeUnitName));\n    for (let value = 1; value <= finalDuration; value++) {\n      if (finalDuration % value === 0) {\n        factors.push({ value, label: value });\n      }\n    }\n    return factors;\n  }, [schedule]);\n\n  const handleSubmit = useCallback(async () => {\n\n    const { id, name, startTime, endTime } = schedule;\n    if (!id) {\n      if (name && startTime) {\n        schedule.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        await postGroupSchedule({ ...schedule, groupName } as IGroupSchedule).unwrap();\n        await getGroupSchedules({ groupName }).unwrap();\n        setSnack({ snackOn: 'Successfully added ' + name + ' as a master schedule!', snackType: 'info' });\n      } else {\n        setSnack({ snackOn: 'A schedule should have a name, a start time.', snackType: 'info' });\n      }\n    } else {\n      await putGroupSchedule({ id, startTime, endTime, groupName } as IGroupSchedule).unwrap();\n      setSnack({ snackOn: 'Schedule updated!', snackType: 'info' });\n    }\n\n    if (closeModal)\n      closeModal();\n  }, [schedule]);\n\n  useEffect(() => {\n    async function go() {\n      if (groupName && editSchedule) {\n        const masterSchedule = await getGroupScheduleMasterById({ groupName, scheduleId: editSchedule.id }).unwrap();\n        attachScheduleUnits(masterSchedule);\n        setSchedule(masterSchedule);\n      } else {\n        setDefault('40hoursweekly30minsessions');\n      }\n    }\n    void go();\n  }, []);\n\n  return <>\n    <DialogTitle>{schedule.id ? 'Manage' : 'Create'} Schedule</DialogTitle>\n    <DialogContent>\n      <Box mt={2} />\n\n      <Box mb={4}>\n        <TextField\n          fullWidth\n          disabled={!!schedule.id}\n          label=\"Name\"\n          helperText=\"Ex: Spring 2022 Campaign, Q1 Offering\"\n          value={schedule.name || ''}\n          onChange={e => setSchedule({ ...schedule, name: e.target.value })}\n        />\n      </Box>\n\n      <Box mb={4}>\n        <Grid container spacing={2} direction=\"row\">\n          <Grid item xs={6}>\n            \n            <TextField\n              fullWidth\n              label=\"Start Date\"\n              type=\"date\"\n              value={schedule.startTime || ''}\n              helperText=\"Schedule is active after this date. Clear this date to deactivate the schedule. Deactivated schedules do not allow new bookings to be made.\"\n              onChange={e => setSchedule({ ...schedule, startTime: e.target.value })}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n            {/* <DesktopDatePicker\n              label=\"Start Date\"\n              value={schedule.startTime ? schedule.startTime : null}\n              onChange={e => {\n                // if (e) {\n                //   console.log({ schedule, e, str: e ? nativeJs(new Date(e.toString())) : null })\n                //   setSchedule({ ...schedule, startTime: nativeJs(new Date(e.toString())).toString() })\n                //   // setSchedule({ ...schedule, startTime: e ? e.format(DateTimeFormatter.ofPattern(\"yyyy-mm-dd\")) : '' });\n                // }\n              }}\n              renderInput={(params) => <TextField helperText=\"Bookings can be scheduled any time after this date. Removing this value and saving the schedule will deactivate it, preventing it from being seen during booking.\" {...params} />}\n            /> */}\n          </Grid>\n          <Grid item xs={6}>\n            <TextField\n              fullWidth\n              label=\"End Date\"\n              type=\"date\"\n              value={schedule.endTime || ''}\n              helperText=\"Optional. No bookings will be allowed after this date.\"\n              onChange={e => setSchedule({ ...schedule, endTime: e.target.value })}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </Grid>\n        </Grid>\n      </Box>\n\n      <Box mb={4}>\n        {!schedule.id ? <>\n          <Typography variant=\"body2\">Use premade selections for this schedule.</Typography>\n          <Button color=\"secondary\" onClick={() => setDefault('40hoursweekly30minsessions')}>40 hours per week, 30 minute slot</Button>\n          <Button color=\"secondary\" onClick={() => setDefault('dailybookingpermonth')}>daily booking per month</Button>\n        </> : <>\n          <Alert color=\"info\">Schedule template durations are read-only after creation.</Alert>\n        </>}\n      </Box>\n\n      <Box mb={4}>\n        <SelectLookup\n          noEmptyValue\n          disabled={!!schedule.id}\n          lookupName=\"Schedule Duration\"\n          helperText=\"The length of time the schedule will run over. This determines the overall context of the schedule and how time will be divided and managed within. For example, a 40 hour per week schedule would require configuring a 1 week Schedule Duration.\"\n          lookupValue={schedule.scheduleTimeUnitId}\n          lookups={lookups?.timeUnits?.filter(sc => ![TimeUnit.MINUTE, TimeUnit.HOUR, TimeUnit.YEAR].includes(sc.name as TimeUnit))}\n          lookupChange={(val: string) => {\n            const { id, name } = lookups?.timeUnits?.find(c => c.id === val) || {};\n            if (!id || !name) return;\n            setSchedule({ ...schedule, scheduleTimeUnitName: name, scheduleTimeUnitId: id, bracketTimeUnitId: lookups?.timeUnits?.find(s => s.name === timeUnitOrder[timeUnitOrder.indexOf(name) - 1])?.id as string })\n          }}\n          {...props}\n        />\n      </Box>\n\n      {/* <Box mb={4}>\n        <TextField\n          fullWidth\n          type=\"number\"\n          disabled={!!schedule.id}\n          label={`# of ${schedule.scheduleTimeUnitName}s`}\n          helperText=\"Provide a duration. After this duration, the schedule will reset, and all bookings will be available again.\"\n          value={schedule.duration}\n          onChange={e => {\n            setSchedule({ ...schedule, duration: Math.min(Math.max(0, parseInt(e.target.value || '', 10)), 999) })\n          }}\n        />\n      </Box> */}\n\n      <Box mb={4}>\n        <SelectLookup\n          noEmptyValue\n          disabled={!!schedule.id}\n          lookupName=\"Bracket Duration Type\"\n          helperText=\"How to measure blocks of time within the Schedule Duration. For example, in a 40 hour per week situation, blocks of time are divided in hours. Multiple brackets can be used on a single schedule, and all of them share the same Bracket Duration Type.\"\n          lookupValue={schedule.bracketTimeUnitId}\n          lookups={lookups?.timeUnits?.filter(sc => sc.name !== schedule.scheduleTimeUnitName && timeUnitOrder.indexOf(sc.name) <= timeUnitOrder.indexOf(schedule.scheduleTimeUnitName))}\n          lookupChange={(val: string) => {\n            const { name, id } = lookups?.timeUnits?.find(c => c.id === val) as ITimeUnit;\n            setSchedule({ ...schedule, bracketTimeUnitName: name, bracketTimeUnitId: id, slotTimeUnitName: name, slotTimeUnitId: id, slotDuration: 1 });\n          }}\n          {...props}\n        />\n      </Box>\n\n      <Box mb={4}>\n        <SelectLookup\n          noEmptyValue\n          disabled={!!schedule.id}\n          lookupName=\"Booking Slot Length\"\n          helperText={`The # of ${schedule.slotTimeUnitName}s to deduct from the bracket upon accepting a booking. Alternatively, if you meet with clients, this is the length of time per session.`}\n          lookupValue={schedule.slotTimeUnitId}\n          lookups={lookups?.timeUnits?.filter(sc => [timeUnitOrder.indexOf(schedule.bracketTimeUnitName), Math.max(timeUnitOrder.indexOf(schedule.bracketTimeUnitName) - 1, 0)].includes(timeUnitOrder.indexOf(sc.name)))}\n          lookupChange={(val: string) => {\n            const { name, id } = lookups?.timeUnits?.find(c => c.id === val) || {};\n            if (!name || !id) return;\n            setSchedule({ ...schedule, slotTimeUnitName: name, slotTimeUnitId: id, slotDuration: 1 })\n          }}\n          {...props}\n        />\n\n        <Box mt={2} sx={{ display: 'flex', alignItems: 'baseline' }}>\n          <Box>{schedule.slotDuration} <span>&nbsp;</span> &nbsp;</Box>\n          <Slider\n            disabled={!!schedule.id}\n            value={schedule.slotDuration}\n            step={null}\n            marks={slotDurationMarks}\n            max={Math.max(...slotDurationMarks.map(m => m.value))}\n            onChange={(_, val) => {\n              setSchedule({ ...schedule, slotDuration: parseFloat(val.toString()) });\n            }}\n          />\n        </Box>\n      </Box>\n\n    </DialogContent>\n    <DialogActions>\n      <Grid container justifyContent=\"space-between\">\n        <Button onClick={closeModal}>{schedule.id ? 'Close' : 'Cancel'}</Button>\n        <Button onClick={handleSubmit}>Submit</Button>\n      </Grid>\n    </DialogActions>\n  </>\n}"}
{"prompt":{"fileName":"ManageScheduleStubModal.tsx","defaultExportName":"ManageScheduleStubModal","hooks":["sh"],"childComponents":[]},"result":"export function ManageScheduleStubModal({ editGroupUserScheduleStub, closeModal }: IProps): JSX.Element {\n  if (!editGroupUserScheduleStub) return <></>;\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const [putGroupUserScheduleStubReplacement] = sh.usePutGroupUserScheduleStubReplacementMutation();\n  const [getGroupUserScheduleStubReplacement] = sh.useLazyGetGroupUserScheduleStubReplacementQuery(); \n\n  const [_, { data: dateSlots }] = sh.useLazyGetGroupScheduleByDateQuery();\n\n  const [firstAvailable, setFirstAvailable] = useState({ time: dayjs() } as IGroupScheduleDateSlots);\n  const [activeSchedule, setActiveSchedule] = useState('');\n\n  const [bracketSlotDate, setBracketSlotDate] = useState<dayjs.Dayjs | null>();\n  const [bracketSlotTime, setBracketSlotTime] = useState<dayjs.Dayjs | null>();\n\n  const [replacement, setReplacement] = useState(editGroupUserScheduleStub.replacement);\n\n  const originalReplacement = editGroupUserScheduleStub?.replacement && { ...editGroupUserScheduleStub.replacement };\n\n  if (editGroupUserScheduleStub.userScheduleId && activeSchedule !== editGroupUserScheduleStub.userScheduleId && dateSlots?.length && !firstAvailable.scheduleBracketSlotId) {\n    const [slot] = dateSlots;\n    setFirstAvailable({ ...slot, time: quotedDT(slot.weekStart, slot.startTime) });\n    setActiveSchedule(editGroupUserScheduleStub.userScheduleId);\n  }\n\n  const handleSubmit = useCallback(async () => {\n    await putGroupUserScheduleStubReplacement({\n      groupName,\n      userScheduleId: editGroupUserScheduleStub.userScheduleId,\n      quoteId: editGroupUserScheduleStub.quoteId,\n      slotDate: (bracketSlotDate || firstAvailable.time).format(\"YYYY-MM-DD\"),\n      startTime: replacement.startTime,\n      serviceTierId: replacement.serviceTierId,\n      scheduleBracketSlotId: replacement.scheduleBracketSlotId\n    } as IGroupUserSchedule & IGroupUserScheduleStubReplacement).unwrap();\n\n    if (closeModal)\n      closeModal();\n  }, [editGroupUserScheduleStub]);\n\n  return <>\n    <Card>\n      <CardHeader title={`${shortNSweet(editGroupUserScheduleStub.slotDate, editGroupUserScheduleStub.startTime)}`} subheader={`${editGroupUserScheduleStub.serviceName} ${editGroupUserScheduleStub.tierName}`} />\n      <CardContent>\n        {originalReplacement && <>\n          <Box mb={2}>\n            <Typography>Use an existing slot at the same date and time:</Typography>\n          </Box>\n          <Box mb={4}>\n            <Button fullWidth variant=\"contained\" color=\"primary\" onClick={() => handleSubmit()}>Reassign to {originalReplacement.username}</Button>\n          </Box>\n\n          <Grid container direction=\"row\" alignItems=\"center\" spacing={2} mb={4}>\n            <Grid item flexGrow={1}>\n              <Divider />\n            </Grid>\n            <Grid item>\n              Or\n            </Grid>\n            <Grid item flexGrow={1}>\n              <Divider />\n            </Grid>\n          </Grid>\n        </>}\n\n        <Box mb={4}>\n          <Box mb={2}>\n            <Typography>Select a new date and time:</Typography>\n          </Box>\n          <Grid container spacing={2}>\n            <Grid item xs={6}>\n              <ScheduleDatePicker\n                key={editGroupUserScheduleStub.userScheduleId}\n                scheduleId={editGroupUserScheduleStub.groupScheduleId}\n                groupName={groupName}\n                firstAvailable={firstAvailable}\n                bracketSlotDate={bracketSlotDate || firstAvailable.time || null}\n                onDateChange={(date: dayjs.Dayjs | null) => setBracketSlotDate(date ? date.isBefore(firstAvailable.time) ? firstAvailable.time : date : null)}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <ScheduleTimePicker\n                key={bracketSlotDate?.format(\"YYYY-MM-DD\")}\n                scheduleId={editGroupUserScheduleStub.groupScheduleId}\n                firstAvailable={firstAvailable}\n                bracketSlotDate={bracketSlotDate || firstAvailable.time}\n                bracketSlotTime={bracketSlotTime || firstAvailable.time}\n                onTimeChange={({ time }) => setBracketSlotTime(time)}\n                onTimeAccept={({ slotDate, startTime }) => {\n                  const { userScheduleId, tierName } = editGroupUserScheduleStub;\n            \n                  getGroupUserScheduleStubReplacement({\n                    groupName,\n                    userScheduleId,\n                    slotDate,\n                    startTime,\n                    tierName\n                  }).unwrap().then(({ stubs }) => {\n                    const [replacementStub] = stubs;\n                    if (replacementStub) {\n                      setReplacement(replacementStub.replacement);\n                    }\n                  }).catch(console.error);\n                }}\n              />\n            </Grid>\n          </Grid>\n        </Box>\n\n        {replacement?.username && <Box my={2}>\n          <Button onClick={() => handleSubmit()} fullWidth variant=\"contained\" color=\"primary\">Reassign to {replacement.username}</Button>\n        </Box>}\n      </CardContent>\n      <CardActions>\n        <Grid container justifyContent=\"space-between\">\n          <Button onClick={closeModal}>Close</Button>\n        </Grid>\n      </CardActions>\n    </Card>\n  </>\n}"}
{"prompt":{"fileName":"ManageScheduleStubs.tsx","defaultExportName":"ManageSchedules","hooks":["useGrid","sh"],"childComponents":[]},"result":"export function ManageSchedules(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { data: schedules, refetch: getGroupUserScheduleStubs } = sh.useGetGroupUserScheduleStubsQuery({ groupName })\n\n  const { stubs } = schedules || {};\n\n  const [stub, setStub] = useState<IGroupUserScheduleStub>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    return length == 1 ? [\n      <Tooltip key={'view_schedule_details'} title=\"View Details\">\n        <IconButton key={'manage_schedule'} onClick={() => {\n          if (stubs?.length) {\n            setStub(stubs?.find(s => s.userScheduleId === selected[0]));\n            setDialog('manage_schedule');\n            setSelected([]);\n          }\n        }}>\n          <CreateIcon />\n        </IconButton>\n      </Tooltip>\n    ] : []\n  }, [selected, groupName]);\n\n  const ScheduleStubGrid = useGrid({\n    rows: stubs || [],\n    columns: [\n      { flex: 1, headerName: 'Date', field: 'slotDate', renderCell: ({ row }) => shortNSweet(row.slotDate, row.startTime) },\n      { flex: 1, headerName: 'Service', field: 'serviceName' },\n      { flex: 1, headerName: 'Tier', field: 'tierName' },\n      { flex: 1, headerName: 'Created', field: 'replacement', renderCell: ({ row }) => Object.keys(row.replacement || {}).length ? 'Yes' : 'No' }\n    ],\n    rowId: 'userScheduleId',\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Appointment Issues</Typography>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  })\n\n  return <>\n    <Dialog open={dialog === 'manage_schedule'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageScheduleStubModal {...props} editGroupUserScheduleStub={stub} closeModal={() => {\n          setDialog('');\n          void getGroupUserScheduleStubs();\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <ScheduleStubGrid />\n  </>\n}"}
{"prompt":{"fileName":"ScheduleDatePicker.tsx","defaultExportName":"ScheduleDatePicker","hooks":["sh"],"childComponents":[]},"result":"export function ScheduleDatePicker(props: IProps): JSX.Element {\n\n  const { groupName, scheduleId, firstAvailable, bracketSlotDate, onDateChange } = props as Required<ScheduleDatePickerType>;\n\n  const [monthSeekDate, setMonthSeekDate] = useState(dayjs().startOf(TimeUnit.MONTH));\n\n  const { data: dateSlots } = sh.useGetGroupScheduleByDateQuery({\n    groupName,\n    scheduleId,\n    date: monthSeekDate.format(\"YYYY-MM-DD\"),\n    timezone: btoa(userTimezone)\n  });\n\n  return <DesktopDatePicker\n    value={bracketSlotDate}\n    onChange={onDateChange}\n    label=\"Date\"\n    inputFormat=\"MM/DD/YYYY\"\n    minDate={firstAvailable.time}\n    onOpen={() => setMonthSeekDate(firstAvailable.time)}\n    onMonthChange={date => date && setMonthSeekDate(date)}\n    onYearChange={date => date && setMonthSeekDate(date)}\n    renderInput={(params) => <TextField fullWidth {...params} />}\n    disableHighlightToday={true}\n    shouldDisableDate={date => {\n      if (date && dateSlots?.length) {\n        return !dateSlots.filter(s => s.startDate === date.format(\"YYYY-MM-DD\")).length;\n      }\n      return true;\n    }}\n  />\n}"}
{"prompt":{"fileName":"ScheduleDisplay.tsx","defaultExportName":"ScheduleDisplay","hooks":["useSchedule"],"childComponents":[]},"result":"export default function ScheduleDisplay({ schedule, setSchedule }: IProps & Required<ScheduleDisplayProps>): JSX.Element {\n\n  const columnWidth = 150;\n  \n  const getScheduleData = useSchedule();\n  const parentRef = useRef<HTMLDivElement>(null);\n  const [selected, setSelected] = useState({} as Record<string, IScheduleBracketSlot>);\n  const [selectedBracket, setSelectedBracket] = useState<IScheduleBracket>();\n  const [buttonDown, setButtonDown] = useState(false);\n  const [width, setWidth] = useState(1);\n\n  const { scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName, slotDuration } = schedule;\n  const { divisions, durations, selections, xAxisTypeName } = useMemo(() => {\n    return getScheduleData({ scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName, slotDuration });\n  }, [scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName, slotDuration])\n\n  const scheduleBracketsValues = useMemo(() => Object.values(schedule.brackets || {}), [schedule.brackets]);\n\n  const setValue = useCallback((startTime: string) => {\n    if (selectedBracket) {\n      const bracket = schedule.brackets[selectedBracket.id];\n      if (bracket) {\n        if (!bracket.slots) bracket.slots = {};\n\n        const target = `schedule_bracket_slot_selection_${startTime}`;\n        const exists = selected[target];\n  \n        const slot = {\n          id: (new Date()).getTime().toString(),\n          startTime,\n          scheduleBracketId: selectedBracket.id\n        } as IScheduleBracketSlot;\n  \n        if (exists) {\n          delete bracket.slots[exists.id];\n          delete selected[target];\n        } else if (Object.keys(bracket.slots).length * schedule.slotDuration < getRelativeDuration(selectedBracket.duration, schedule.bracketTimeUnitName, schedule.slotTimeUnitName)) {\n          bracket.slots[slot.id] = slot;\n          selected[target] = slot;\n        } else {\n          alert('you went over your allottment');\n          setButtonDown(false);\n          return;\n        }\n  \n        setSchedule({ ...schedule, brackets: { ...schedule.brackets } });\n        setSelected({ ...selected });\n      }\n    }\n  }, [schedule, selectedBracket, scheduleBracketsValues, selected]);\n\n  const Cell = useCallback((gridCell: GridCell) => {\n    const { startTime, contextFormat } = durations[gridCell.columnIndex][gridCell.rowIndex];\n\n    const target = `schedule_bracket_slot_selection_${startTime}`;    \n    const exists = selected[target];\n\n    return <CardActionArea\n      style={gridCell.style}\n      sx={{\n        backgroundColor: '#444',\n        textAlign: 'center',\n        position: 'relative',\n        '&:hover': {\n          backgroundColor: '#aaa',\n          opacity: '1',\n          boxShadow: '2'\n        },\n        border: exists ? `1px solid ${bracketColors[scheduleBracketsValues.findIndex(b => b.id === exists.scheduleBracketId)]}` : undefined,\n        opacity: !exists ? '.33' : '1',\n        boxShadow: exists ? '2' : undefined\n      }}\n      onMouseLeave={() => buttonDown && setValue(startTime)}\n      onMouseDown={() => setButtonDown(true)}\n      onMouseUp={() => {\n        setButtonDown(false);\n        setValue(startTime);\n      }}\n    >\n      {contextFormat}\n    </CardActionArea>\n  }, [selected, buttonDown, selectedBracket, xAxisTypeName]);\n\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(([event]) => {\n      setWidth(event.contentBoxSize[0].inlineSize);\n    });\n\n    if (parentRef && parentRef.current) {\n      resizeObserver.observe(parentRef.current);\n    }\n  }, [parentRef]);\n\n  useEffect(() => {\n    if (!Object.keys(selected).length && scheduleBracketsValues.some(b => Object.keys(b.slots).length)) {\n      const newSelected = {} as Record<string, IScheduleBracketSlot>;\n      scheduleBracketsValues.forEach(b => {\n        Object.values(b.slots).forEach(s => {\n          newSelected[`schedule_bracket_slot_selection_${s.startTime}`] = s;\n        });\n      });\n      setSelected(newSelected);\n    }\n  }, [selected, scheduleBracketsValues]);\n\n  return <>\n    <Typography variant=\"caption\">Click a bracket, then use up the allotted time by clicking on the time slots. Hold down the mouse button to select multiple slots. There can be leftover slots if they're unneeded.</Typography>\n    <Box ref={parentRef}>\n      <Box sx={{ display: 'flex', alignItems: 'flex-end', flexWrap: 'wrap' }}>\n        {scheduleBracketsValues.map((bracket, i) => {\n          if (!bracket.slots) bracket.slots = {};\n          return <Box key={`bracket-chip${i + 1}new`} m={1}>\n            <Chip\n              label={`#${i + 1} ${getRelativeDuration(bracket.duration, schedule.bracketTimeUnitName, schedule.slotTimeUnitName) - (Object.keys(bracket.slots).length * schedule.slotDuration)} ${schedule.slotTimeUnitName}s (${bracket.multiplier}x)`}\n              sx={{ '&:hover': { cursor: 'pointer' }, borderWidth: '1px', borderStyle: 'solid', borderColor: bracketColors[i], boxShadow: selectedBracket?.id === bracket.id ? 2 : undefined }}\n              onDelete={() => {\n                delete schedule.brackets[bracket.id];\n                setSchedule({ ...schedule, brackets: { ...schedule.brackets } });\n              }}\n              onClick={() => {\n                setSelectedBracket(bracket);\n              }}\n            />\n          </Box>\n        })}\n      </Box>\n\n      <Box onMouseLeave={() => setButtonDown(false)}>\n        <FixedSizeGrid\n          rowCount={selections}\n          columnCount={divisions}\n          rowHeight={30}\n          columnWidth={columnWidth}\n          height={400}\n          width={Math.min(width, columnWidth * divisions)}\n        >\n          {Cell}\n        </FixedSizeGrid>\n      </Box>\n    </Box>\n  </>;\n}"}
{"prompt":{"fileName":"ScheduleHome.tsx","defaultExportName":"ScheduleHome","hooks":["useComponents"],"childComponents":[]},"result":"export function ScheduleHome(props: IProps): JSX.Element {\n  const { ManageScheduleBrackets } = useComponents();\n  return <ManageScheduleBrackets {...props} />\n}"}
{"prompt":{"fileName":"ScheduleTimePicker.tsx","defaultExportName":"ScheduleTimePicker","hooks":["sh"],"childComponents":[]},"result":"export function ScheduleTimePicker(props: IProps): JSX.Element {\n\n  const { scheduleId, bracketSlotDate, firstAvailable, bracketSlotTime, onTimeChange, onTimeAccept } = props as Required<ScheduleTimePickerType>;\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const [_, { data: dateSlots }] = sh.useLazyGetGroupScheduleByDateQuery();\n  const { data: lookups } = sh.useGetLookupsQuery();\n  const { data: groupSchedules } = sh.useGetGroupSchedulesQuery({ groupName });\n\n  const didInit = useRef(false);\n\n  const { bracketTimeUnitId, slotTimeUnitId } = groupSchedules?.find(gs => gs.id === scheduleId) || {};\n  const bracketTimeUnitName = lookups?.timeUnits.find(u => u.id === bracketTimeUnitId)?.name as ITimeUnitNames;\n  const slotTimeUnitName = lookups?.timeUnits.find(u => u.id === slotTimeUnitId)?.name as ITimeUnitNames;\n  const sessionDuration = Math.round(getRelativeDuration(1, bracketTimeUnitName, slotTimeUnitName));\n  \n  const slotFactors = [] as number[];\n  for (let factor = 1; factor < sessionDuration; factor++) {\n    if (sessionDuration % factor === 0) {\n      slotFactors.push(factor);\n    }\n  }\n\n  const bracketSlotDateDayDiff = useMemo(() => {\n    if (bracketSlotDate) {\n      const startOfDay = bracketSlotDate.startOf('day');\n      return startOfDay.diff(startOfDay.day(0), TimeUnit.DAY);\n    }\n    return 0;\n  }, [bracketSlotDate]);\n\n  function getSlot(time: dayjs.Dayjs, date: string): IGroupScheduleDateSlots | undefined {\n    const timeHour = time.hour();\n    const timeMins = time.minute();\n    const duration = dayjs.duration(0)\n      .add(bracketSlotDateDayDiff, TimeUnit.DAY)\n      .add(timeHour, TimeUnit.HOUR)\n      .add(timeMins, TimeUnit.MINUTE);\n    const [slot] = dateSlots?.filter(s => s.startDate === date && duration.hours() === s.hour && duration.minutes() === s.minute) || [];\n\n    return slot;\n  }\n\n  function getQuote(time: dayjs.Dayjs | null): IQuote | undefined {\n    let quote: IQuote | undefined = undefined;\n    if (time) {\n      const currentSlotDate = bracketSlotDate || firstAvailable.time;\n      const date = currentSlotDate.format('YYYY-MM-DD');\n      const slot = getSlot(time, date);\n      if (slot) {\n        quote = {\n          slotDate: date,\n          startTime: slot.startTime,\n          scheduleBracketSlotId: slot.scheduleBracketSlotId,\n        } as IQuote;\n      }\n    }\n    return quote;\n  }\n\n  useEffect(() => {\n    if (dateSlots?.length && firstAvailable.time && !didInit.current) {\n      didInit.current = true;\n      const quote = getQuote(firstAvailable.time);\n      quote && onTimeAccept(quote);\n    }\n  }, [dateSlots, firstAvailable, didInit.current]);\n\n  return <TimePicker\n    label=\"Time\"\n    value={bracketSlotTime}\n    onChange={time => {\n      const quote = getQuote(time)\n      onTimeChange({ time, quote });\n    }}\n    ampmInClock={true}\n    ignoreInvalidInputs={true}\n    onAccept={time => {\n      const quote = getQuote(time);\n      if (quote) onTimeAccept(quote);\n    }}\n    shouldDisableTime={(time, clockType) => {\n      if (dateSlots?.length) {\n        const currentSlotTime = bracketSlotTime;\n        const currentSlotDate = bracketSlotDate || firstAvailable.time;\n        // Ignore seconds check because final time doesn't need seconds, so this will cause invalidity\n        if ('seconds' === clockType) return false;\n\n        // Create a duration based on the current clock validation check and the days from start of current week\n        let duration: Duration = dayjs.duration(time, clockType).add(bracketSlotDateDayDiff, TimeUnit.DAY);\n\n        // Submitting a new time a two step process, an hour is selected, and then a minute. Upon hour selection, bracketSlotTime is first set, and then when the user selects a minute, that will cause this block to run, so we should add the existing hour from bracketSlotTime such that \"hour + minute\" will give us the total duration, i.e. 4:30 AM = PT4H30M\n        if ('minutes' === clockType && currentSlotTime) {\n          duration = duration.add(currentSlotTime.hour(), TimeUnit.HOUR);\n        }\n\n        // When checking hours, we need to also check the hour + next session time, because shouldDisableTime checks atomic parts of the clock, either hour or minute, but no both. So instead of keeping track of some ongoing clock, we can just check both durations here\n        const checkDurations: Duration[] = [duration];\n        if ('hours' === clockType) {\n          for (const factor of slotFactors) {\n            checkDurations.push(duration.add(factor, slotTimeUnitName as DurationUnitType));\n          }\n        }\n\n        const matches = dateSlots.filter(s => s.startDate === currentSlotDate.format(\"YYYY-MM-DD\") && checkDurations.filter(d => d.hours() === s.hour && d.minutes() === s.minute).length > 0);\n        // Checks that have no existing slots are invalid\n        return !matches.length;\n      }\n      return true;\n    }}\n    renderInput={params => <TextField fullWidth {...params} />}\n  />\n}"}
{"prompt":{"fileName":"ManageServiceModal.tsx","defaultExportName":"ManageServiceModal","hooks":["sh","useUtil"],"childComponents":[]},"result":"export function ManageServiceModal ({ editService, closeModal, ...props }: IProps): JSX.Element {\n\n  const { setSnack } = useUtil();\n\n  const [putService] = sh.usePutServiceMutation();\n  const [postService] = sh.usePostServiceMutation();\n\n  const [service, setService] = useState({\n    name: '',\n    ...editService\n  } as IService);\n  \n  const handleSubmit = useCallback(() => {\n    const { id, name } = service;\n\n    if (!name) {\n      setSnack({ snackType: 'error', snackOn: 'Services must have a name.' });\n      return;\n    }\n\n    (id ? putService : postService)(service).unwrap().then(() => {\n      if (closeModal)\n        closeModal();\n    }).catch(console.error);\n  }, [service]);\n\n  return <>\n    <Card>\n      <CardContent>\n        <Typography variant=\"button\">Manage service</Typography>\n        <Grid container direction=\"row\" spacing={2}>\n          <Grid item xs={12}>\n            <Grid container direction=\"column\" spacing={4} justifyContent=\"space-evenly\" >\n              <Grid item>\n                <Typography variant=\"h6\">Service</Typography>\n              </Grid>\n              <Grid item>\n                <TextField\n                  fullWidth\n                  autoFocus\n                  id=\"name\"\n                  label=\"Name\"\n                  name=\"name\"\n                  value={service.name}\n                  onKeyDown={e => {\n                    if ('Enter' === e.key) {\n                      handleSubmit();\n                    }\n                  }}\n                  onChange={e => setService({ ...service, name: e.target.value })} />\n              </Grid>\n            </Grid>\n          </Grid>\n        </Grid>\n      </CardContent>\n      <CardActions>\n        <Grid container justifyContent=\"space-between\">\n          <Button onClick={closeModal}>Cancel</Button>\n          <Button onClick={handleSubmit}>Submit</Button>\n        </Grid>\n      </CardActions>\n    </Card>\n  </>\n}"}
{"prompt":{"fileName":"ManageServices.tsx","defaultExportName":"ManageServices","hooks":["useGrid","sh","useUtil"],"childComponents":[]},"result":"export function ManageServices(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { openConfirm } = useUtil();\n\n  const [deleteGroupService] = sh.useDeleteGroupServiceMutation();\n\n  const { data: groupServices, refetch: getGroupServices } = sh.useGetGroupServicesQuery({ groupName });\n  \n  const navigate = useNavigate();\n  const [service, setService] = useState<IService>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <Tooltip key={'manage_service'} title=\"Edit\">\n        <Button onClick={() => {\n          setService(groupServices?.find(gs => gs.id === selected[0]));\n          setDialog('manage_service');\n          setSelected([]);\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_service'} title=\"Delete\">\n        <Button onClick={() => {\n          openConfirm({\n            isConfirming: true,\n            confirmEffect: 'Are you sure you want to delete these services? This cannot be undone.',\n            confirmAction: () => {\n              deleteGroupService({ groupName, ids: selected.join(',') }).unwrap().then(() => {\n                void getGroupServices();\n                setSelected([]);\n              }).catch(console.error);\n            }\n          });\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ]\n  }, [selected]);\n\n  const ServiceGrid = useGrid({\n    rows: groupServices || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Services:</Typography>\n      <Tooltip key={'create_service'} title=\"Create\">\n        <Button onClick={() => navigate('/service')}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\n          <DomainAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  })\n\n  return <>\n    <Dialog scroll=\"paper\" open={dialog === 'manage_service'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageServiceModal {...props} editService={service} closeModal={() => {\n          setDialog('')\n          void getGroupServices();\n        }} />\n      </Suspense>\n    </Dialog>\n    <ServiceGrid />\n  </>\n}"}
{"prompt":{"fileName":"ServiceHome.tsx","defaultExportName":"ServiceHome","hooks":["useComponents","useStyles","sh","useUtil"],"childComponents":[]},"result":"export function ServiceHome(props: IProps): JSX.Element {\n  const classes = useStyles();\n\n  const { setSnack } = useUtil();\n\n  const { SelectLookup } = useComponents();\n\n  const [postServiceAddon] = sh.usePostServiceAddonMutation();\n  const [postGroupServiceAddon] = sh.usePostGroupServiceAddonMutation();\n  const [deleteGroupServiceAddon] = sh.useDeleteGroupServiceAddonMutation();\n  const [postService] = sh.usePostServiceMutation();\n  const [postGroupService] = sh.usePostGroupServiceMutation();\n  const [getGroupFormById] = sh.useLazyGetGroupFormByIdQuery();\n  const [getGroupServices] = sh.useLazyGetGroupServicesQuery();\n  const [getPrompt] = sh.useLazyGetPromptQuery();\n\n  const { data : profile } = sh.useGetUserProfileDetailsQuery();\n\n  const [group, setGroup] = useState(Object.values(profile?.groups || {})[0]);\n\n  const { data: groupServiceAddons, refetch: getGroupServiceAddons } = sh.useGetGroupServiceAddonsQuery({ groupName: group.name });\n  const { data: groupForms } = sh.useGetGroupFormsQuery({ groupName: group.name });\n\n  const [newService, setNewService] = useState({ ...serviceSchema, tiers: {} } as IService);\n  const [newServiceTier, setNewServiceTier] = useState({ ...serviceTierSchema, addons: {} } as IServiceTier);\n  const [serviceTierAddonIds, setServiceTierAddonIds] = useState<string[]>([]);\n\n  const [serviceSuggestions, setServiceSuggestions] = useState('');\n  const [tierSuggestions, setTierSuggestions] = useState('');\n  const [featureSuggestions, setFeatureSuggestions] = useState('');\n\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\n  \n  useEffect(() => {\n    async function go() {\n      if (groupsValues.length) {\n        const gr = groupsValues[0];\n        const { promptResult } = await getPrompt({ id: IPrompts.SUGGEST_SERVICE, prompt: gr.purpose } as IAssist).unwrap();\n        if (promptResult.length) setServiceSuggestions(promptResult.join(', '));\n        setGroup(gr);\n      }\n    }\n    void go();\n  }, [groupsValues]);\n\n  return <Grid container spacing={2}>\n\n    <Grid item xs={12}>\n      <Card style={{ display: 'flex', flexDirection: 'column' }}>\n        <CardHeader\n          title=\"Create Service\"\n          subheader=\"Services are the functions of your organization. Each service has a set of tiers and features. As well, a cost may be associated with the service. If there is a cost, tiers can be used to provide a higher level of service at a higher cost, using the multiplier. Features can be added to each tier as necessary.\"\n          action={\n            <TextField\n              select\n              value={group.id}\n              label=\"Group\"\n              onChange={e => setGroup(groupsValues.filter(g => g.id === e.target.value)[0])}\n            >\n              {groupsValues.map(group => <MenuItem key={`group-select${group.id}`} value={group.id}>{group.name.replaceAll('_', ' ')}</MenuItem>)}\n            </TextField>\n          }\n        />\n        <CardContent>\n\n          <Grid container>\n            <Grid item xs={12} md={6}>\n              <Box mb={4}>\n                <TextField\n                  fullWidth\n                  label=\"Name\"\n                  value={newService.name}\n                  onChange={e => setNewService({ ...newService, name: e.target.value })}\n                  onBlur={() => {\n                    // When this service name changes, let's get a new prompt for tier name suggestions\n                    getPrompt({ id: IPrompts.SUGGEST_TIER, prompt: `${newService.name.toLowerCase()} at ${group.name.replaceAll('_', ' ')}`} as IAssist).unwrap().then(({ promptResult }) => {\n                      if (promptResult.length) setTierSuggestions(promptResult.join(', '));\n                    }).catch(console.error);\n                  }}\n                  helperText={`${serviceSuggestions ? `AI: ${serviceSuggestions}` : 'Ex: Website Hosting, Yard Maintenance, Automotive Repair'}`}\n                />\n              </Box>\n\n              <Box mb={4}>\n                <TextField fullWidth label=\"Cost\" helperText=\"Optional.\" value={newService.cost || ''} onChange={e => validCost(e.target.value) && setNewService({ ...newService, cost: /\\.\\d\\d/.test(e.target.value) ? parseFloat(e.target.value).toFixed(2) : e.target.value })} />\n              </Box>\n\n              <Box>\n                <TextField\n                  select\n                  fullWidth\n                  value={newService.formId}\n                  label=\"Form\"\n                  helperText=\"Optional.\"\n                  onChange={async e => {\n                    const form = await getGroupFormById({ groupName: group.name, formId: e.target.value }).unwrap();\n                    if (form) {\n                      setNewService({ ...newService, formId: form.id })\n                    }\n                  }}\n                >\n                  {groupForms?.map(form => <MenuItem key={`form-version-select${form.id}`} value={form.id}>{form.name}</MenuItem>)}\n                </TextField>\n              </Box>\n            </Grid>\n          </Grid>\n        </CardContent>\n      </Card>\n    </Grid>\n\n    <Grid item xs={12}>\n      <Card style={{ display: 'flex', flexDirection: 'column' }}>\n        <CardHeader title=\"Add Tier\" subheader='Some services divide their offering up into tiers. For example, a \"Basic\" tier may have some basic features, and the \"Advanced\" tier has more features. You should have at least 1 tier which describes the features offered by your service. During booking, your users will see this information.' />\n\n        <CardContent sx={{ padding: '0 15px' }}>\n          <Grid container>\n            <Grid item xs={12} md={6}>\n              <Box mb={4}>\n                {/* <Typography variant=\"body2\">Some services divide their offering up into tiers. For example, a \"Basic\" tier may some basic features, and the \"Advanced\" tier has more features. If your service has no tier, you can ignore this section and we'll create a standard tier for you.</Typography> */}\n                <TextField\n                  fullWidth\n                  label=\"Name\"\n                  value={newServiceTier.name}\n                  onBlur={() => {\n                    // When this tier name changes, let's get a new prompt for feature name suggestions\n                    getPrompt({ id: IPrompts.SUGGEST_FEATURE, prompt: `${newServiceTier.name} ${newService.name}`} as IAssist).unwrap().then(({ promptResult }) => {\n                      if (promptResult.length) setFeatureSuggestions(promptResult.join(', '));\n                    }).catch(console.error);\n                  }}\n                  onChange={e => setNewServiceTier({ ...newServiceTier, name: e.target.value })}\n                  helperText={`${tierSuggestions.length ? `AI: ${tierSuggestions}` : 'Ex: Basic, Mid-Tier, Advanced'}`}\n                />\n              </Box>\n\n              {group.name && <Box mb={4} flexDirection=\"column\" sx={{ display: 'flex', alignItems: 'baseline' }}>\n                <SelectLookup\n                  multiple\n                  lookupName='Feature'\n                  lookups={groupServiceAddons}\n                  lookupValue={serviceTierAddonIds}\n                  parentUuid={group.name}\n                  parentUuidName='groupName'\n                  lookupChange={(val: string[]) => {\n                    const gsa = groupServiceAddons?.filter(s => val.includes(s.id)).map(s => s.id);\n                    if (gsa) setServiceTierAddonIds(gsa);\n                  }}\n                  createAction={postServiceAddon}\n                  deleteAction={deleteGroupServiceAddon}\n                  deleteActionIdentifier='serviceAddonId'\n                  refetchAction={getGroupServiceAddons}\n                  attachAction={postGroupServiceAddon}\n                  attachName='serviceAddonId'\n                  {...props}\n                />\n                <Box pl={2}>\n                  <FormHelperText>{featureSuggestions.length ? `AI: ${featureSuggestions}` : 'Ex: 24-Hour Support, Premium Access, Domain Registration, 20GB Storage'}</FormHelperText>\n                </Box>\n              </Box>}\n\n              <Box mb={4}>\n                <TextField\n                  select\n                  fullWidth\n                  value={newServiceTier.formId}\n                  label=\"Form\"\n                  helperText=\"Optional.\"\n                  onChange={async e => {\n                    const form = await getGroupFormById({ groupName: group.name, formId: e.target.value }).unwrap();\n                    if (form) {\n                      setNewServiceTier({ ...newServiceTier, formId: form.id })\n                    }\n                  }}\n                >\n                  {groupForms?.map(form => <MenuItem key={`form-version-select${form.id}`} value={form.id}>{form.name}</MenuItem>)}\n                </TextField>\n              </Box>\n\n              <Box>\n                <Typography variant=\"h6\">Multiplier</Typography>\n                <Box sx={{ display: 'flex', alignItems: 'baseline' }}>\n                  <span>{newServiceTier.multiplier}x <span>&nbsp;</span> &nbsp;</span>\n                  <Slider value={parseFloat(newServiceTier.multiplier)} onChange={(e, val) => setNewServiceTier({ ...newServiceTier, multiplier: parseFloat(val.toString()).toFixed(2) })} step={.01} min={1} max={5} />\n                </Box>\n              </Box>\n            </Grid>\n          </Grid>\n        </CardContent>\n        <CardActionArea onClick={() => {\n          if (newServiceTier.name && serviceTierAddonIds.length) {\n            const created = (new Date()).getTime().toString();\n            newServiceTier.id = created;\n            newServiceTier.createdOn = created;\n            newServiceTier.order = Object.keys(newService.tiers).length + 1;\n            newServiceTier.addons = serviceTierAddonIds.reduce((m, id, i) => {\n              const addon = groupServiceAddons?.find(gs => gs.id === id) || { name: '' };\n              return {\n                ...m,\n                [id]: addon && {\n                  id,\n                  name: addon.name,\n                  order: i + 1\n                }\n              }\n            }, {});\n            newService.tiers[newServiceTier.id] = newServiceTier;\n            setNewServiceTier({ ...serviceTierSchema, addons: {} } as IServiceTier);\n            setServiceTierAddonIds([]);\n          } else {\n            void setSnack({ snackOn: 'Provide a tier name and at least 1 feature.', snackType: 'info' });\n          }\n        }}>\n          <Box m={2} sx={{ display: 'flex', alignItems: 'center' }}>\n            <Typography color=\"secondary\" variant=\"button\">Add Tier to Service</Typography>\n          </Box>\n        </CardActionArea>\n      </Card>\n    </Grid>\n\n    <Grid item xs={12}>\n      <Card>\n        <CardContent sx={{ padding: '0 15px' }}>\n          <Box>\n            <Typography variant=\"h6\">Tiers</Typography>\n            <Typography variant=\"body2\">The order that tiers appear here is the order they will be listed during booking.</Typography>\n            {Object.keys(newService.tiers).length > 0 && <Box mt={4} sx={{ display: 'flex', alignItems: 'flex-end', flexWrap: 'wrap' }}>\n              {Object.values(newService.tiers).sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime()).map((tier, i) => {\n                const addons = Object.values(tier.addons);\n                return <Box key={`service-tier-chip${i + 1}new`} m={1}><Chip classes={{ root: classes.chipRoot, label: classes.chipLabel }} label={<Typography>{`#${i + 1} ` + tier.name + ' (' + tier.multiplier + 'x): ' + (addons.length ? addons.map(a => a.name).join(', ') : 'No features.')}</Typography>} onDelete={() => {\n                  delete newService.tiers[tier.id];\n                  setNewService({ ...newService, tiers: { ...newService.tiers } });\n                }} /></Box>\n              })}\n            </Box>}\n          </Box>\n        </CardContent>\n      </Card>\n    </Grid>\n\n    <Grid item xs={12}>\n      <Card>\n        <CardActionArea onClick={async () => {\n          if (newService.name && group.name && Object.keys(newService.tiers)?.length) {\n            const postedService = await postService({ ...newService }).unwrap();\n            await postGroupService({ serviceId: postedService.id, groupName: group.name }).unwrap();\n            await getGroupServices({ groupName: group.name }).unwrap();\n            setSnack({ snackOn: `Successfully added ${newService.name} to ${group.name.replaceAll('_', ' ')}`, snackType: 'info' });\n            setNewService({ ...serviceSchema, tiers: {} } as IService);\n            setServiceTierAddonIds([]);\n          } else {\n            void setSnack({ snackOn: 'Provide the service name, cost and at least 1 tier.', snackType: 'info' });\n          }\n        }}>\n          <Box m={2} sx={{ display: 'flex' }}>\n            <Typography color=\"secondary\" variant=\"button\">Create Service</Typography>\n          </Box>\n        </CardActionArea>\n      </Card>\n    </Grid>\n  </Grid>\n}"}
{"prompt":{"fileName":"ManageUserModal.tsx","defaultExportName":"ManageUserModal","hooks":["sh"],"childComponents":[]},"result":"export function ManageUserModal({ editUser, closeModal }: IProps): JSX.Element {\r\n\r\n  const { groupName } = useParams();\r\n  if (!groupName) return <></>;\r\n\r\n  const { data: groupRoles } = sh.useGetGroupRolesQuery({ groupName });\r\n\r\n  const [getGroupUsers] = sh.useLazyGetGroupUsersQuery();\r\n  const [getGroupUserById] = sh.useLazyGetGroupUserByIdQuery();\r\n  const [putGroupUser] = sh.usePutGroupUserMutation();\r\n\r\n  const [password, setPassword] = useState('');\r\n  const [profile, setProfile] = useState({\r\n    firstName: '',\r\n    lastName: '',\r\n    email: '',\r\n    username: '',\r\n    roleId: '',\r\n    roleName: '',\r\n    ...editUser\r\n  } as IGroupUser);\r\n\r\n  useEffect(() => {\r\n    async function go() {\r\n      if (groupName && editUser?.id && !profile.roleId) {\r\n        const user = await getGroupUserById({ groupName, userId: editUser.id }).unwrap();\r\n        setProfile({ ...profile, ...user });\r\n      }\r\n    }\r\n    void go();\r\n  }, [editUser, profile]);\r\n\r\n  const handlePassword = useCallback(({ target: { value } }: React.ChangeEvent<HTMLTextAreaElement>) => setPassword(value), [])\r\n  const handleProfile = useCallback(({ target: { name, value } }: React.ChangeEvent<HTMLTextAreaElement>) => setProfile({ ...profile, [name]: value }), [profile])\r\n\r\n  const handleSubmit = useCallback(async () => {\r\n    if (editUser?.id) {\r\n      const { id, roleId } = profile;\r\n      const { name } = groupRoles?.find(gr => gr.id === roleId) || {};\r\n      if (name) {\r\n        await putGroupUser({ groupName, userId: id, roleId, roleName: name }).unwrap();\r\n        await getGroupUsers({ groupName }).unwrap();\r\n        if (closeModal)\r\n          closeModal();\r\n      }\r\n    }\r\n    // async function submitUser() {\r\n    //   let user = profile as IUserProfile;\r\n    //   const { id, sub } = user;\r\n\r\n    //   const groupRoleKeys = Object.keys(userGroupRoles);\r\n\r\n    //   if (!groupRoleKeys.length)\r\n    //     return act(SET_SNACK, { snackType: 'error', snackOn: 'Group roles must be assigned.' });\r\n\r\n    //   user.groups = groupRoleKeys // { \"g1\": [...], \"g2\": [...] } => [\"g1\", \"g2\"];\r\n    //     .reduce((memo, key) => {\r\n    //       if (userGroupRoles[key].length) { // [...].length\r\n    //         const group = { ...groups?.find(g => g.name == key) } as IGroup; // Get a copy from repository\r\n    //         if (group.roles) {\r\n    //           group.roles = group.roles.filter(r => userGroupRoles[key].includes(r.name)) // Filter roles\r\n    //           memo.push(group);\r\n    //         }\r\n    //       }\r\n    //       return memo;\r\n    //     }, [] as IGroup[]);\r\n\r\n    //   // User Update - 3 Scenarios\r\n    //   // User-Originated - A user signed up in the wild, created a cognito account, has not done anything to \r\n    //   //                  generate an application account, and now an admin is generating one\r\n    //   // Admin-Originated - A user being created by an admin in the manage area\r\n    //   // Admin-Updated - A user being updated by an admin in the manage area\r\n\r\n    //   // If there's already a sub, PUT/manage/users will update the sub in cognito;\r\n    //   // else we'll POST/manage/users/sub for a new sub\r\n    //   user = await api(sub ? PUT_MANAGE_USERS : POST_MANAGE_USERS_SUB, true, sub ? user : { ...user, password }) as IUserProfile;\r\n\r\n    //   // Add user to application db if needed no user.id\r\n    //   if (!id)\r\n    //     user = await api(sub ? POST_MANAGE_USERS_APP_ACCT : POST_MANAGE_USERS, true, user) as IUserProfile;\r\n\r\n    //   if (closeModal)\r\n    //     closeModal();\r\n    // }\r\n\r\n    // void submitUser();\r\n  }, [profile, password]);\r\n\r\n  const passwordGenerator = useCallback(() => {\r\n    setPassword(passwordGen());\r\n  }, []);\r\n\r\n  return <>\r\n    <Card>\r\n      <CardHeader\r\n        title={`Manage ${profile.username}`}\r\n        subheader={`${profile.firstName} ${profile.lastName}`}\r\n      />\r\n      <CardContent>\r\n        <Grid container direction=\"row\" spacing={2} justifyContent=\"space-evenly\">\r\n          <Grid item xs={12}>\r\n            <Grid container direction=\"column\" spacing={4} justifyContent=\"space-evenly\" >\r\n\r\n              <Grid item>\r\n                <TextField select fullWidth id=\"roleId\" label=\"Role\" value={profile.roleId} name=\"roleId\" onChange={handleProfile}>\r\n                  {groupRoles?.map(role => <MenuItem key={`${role.id}_user_profile_role_select`} value={role.id}>{role.name}</MenuItem>)}\r\n                </TextField>\r\n              </Grid>\r\n\r\n              {!editUser && (\r\n                <Grid item xs>\r\n                  <Grid container direction=\"column\" justifyContent=\"space-evenly\" spacing={4}>\r\n                    <Grid item xs={12}>\r\n                      <Typography variant=\"h6\">Account</Typography>\r\n                    </Grid>\r\n                    <Grid item xs={12}>\r\n                      <TextField fullWidth id=\"username\" label=\"Username\" value={profile.username} name=\"username\" onChange={handleProfile} />\r\n                    </Grid>\r\n                    <Grid item xs={12}>\r\n                      <FormControl fullWidth>\r\n                        <InputLabel htmlFor=\"password\">Password</InputLabel>\r\n                        <Input type=\"text\" id=\"password\" aria-describedby=\"password\" value={password} onChange={handlePassword}\r\n                          endAdornment={\r\n                            <InputAdornment position=\"end\">\r\n                              <Button onClick={passwordGenerator} style={{ backgroundColor: 'transparent' }}>Generate</Button>\r\n                            </InputAdornment>\r\n                          }\r\n                        />\r\n                        <FormHelperText>Password must be at least 8 characters and contain 1 uppercase, lowercase, number, and special (e.g. @^$!*) character. The user must change this passowrd upon logging in for the first time.</FormHelperText>\r\n                      </FormControl>\r\n                    </Grid>\r\n                  </Grid>\r\n                </Grid>\r\n              )}\r\n            </Grid>\r\n          </Grid>\r\n        </Grid>\r\n      </CardContent>\r\n      <CardActions>\r\n\r\n        <Grid container justifyContent=\"space-between\">\r\n          <Button onClick={closeModal}>Cancel</Button>\r\n          <Button onClick={handleSubmit}>{profile.sub ? 'update' : 'create'}</Button>\r\n        </Grid>\r\n      </CardActions>\r\n    </Card>\r\n  </>\r\n}"}
{"prompt":{"fileName":"ManageUsers.tsx","defaultExportName":"ManageUsers","hooks":["sh","useGrid"],"childComponents":[]},"result":"export function ManageUsers(props: IProps): JSX.Element {\r\n  \r\n  const { groupName } = useParams();\r\n  if (!groupName) return <></>;\r\n\r\n  const { data: groupUsers } = sh.useGetGroupUsersQuery({ groupName });\r\n\r\n  const [user, setUser] = useState<IGroupUser>();\r\n  const [selected, setSelected] = useState<string[]>([]);\r\n  const [dialog, setDialog] = useState('');\r\n\r\n  const actions = useMemo(() => {\r\n    const { length } = selected;\r\n    const actions = length == 1 ? [\r\n      <IconButton key={'manage_user'} onClick={() => {\r\n        setUser(groupUsers?.find(gu => gu.id === selected[0]));\r\n        setDialog('manage_user');\r\n        setSelected([]);\r\n      }}>\r\n        <CreateIcon />\r\n      </IconButton>\r\n    ] : [];\r\n\r\n    return [\r\n      ...actions,\r\n      // <IconButton key={'lock_user'} onClick={() => {\r\n      //   api(lockUsersAction, { users: selected.map(u => ({ username: u.username })) }, { load: true });\r\n      //   setToggle(!toggle);\r\n      // }}><LockIcon /></IconButton>,\r\n      // <IconButton key={'unlock_user'} onClick={() => {\r\n      //   api(unlockUsersAction, { users: selected.map(u => ({ username: u.username })) }, { load: true });\r\n      //   setToggle(!toggle);\r\n      // }}><LockOpenIcon /></IconButton>,\r\n    ];\r\n  }, [selected]);\r\n\r\n  const UserGrid = useGrid<IGroupUser>({\r\n    rows: groupUsers || [],\r\n    columns: [\r\n      { flex: 1, headerName: 'Username', field: 'username' },\r\n      { flex: 1, headerName: 'First Name', field: 'firstName' },\r\n      { flex: 1, headerName: 'Last Name', field: 'lastName' },\r\n      { flex: 1, headerName: 'Role', field: 'roleName' },\r\n      { field: 'createdOn', headerName: 'Created', flex: 1, renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\r\n    ],\r\n    selected,\r\n    onSelected: selection => setSelected(selection as string[]),\r\n    toolbar: () => <>\r\n      <Typography variant=\"button\">Users</Typography>\r\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\r\n    </>\r\n  });\r\n\r\n  return <>\r\n    <Dialog open={dialog === 'manage_user'} fullWidth maxWidth=\"xs\">\r\n      <Suspense>\r\n        <ManageUserModal {...props} editUser={user} closeModal={() => setDialog('')} />\r\n      </Suspense>\r\n    </Dialog>\r\n    \r\n    <UserGrid />\r\n  </>\r\n}"}
