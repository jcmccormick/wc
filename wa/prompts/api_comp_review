We need to create a small utility application which is able to generate a prompt/result style object like the following based on a typescript project.

{
  prompt: "a string containing important properties the api definition or react component",
  result: "the contents of a component or api"
}

You can assume the files we are using to create artifacts consist of two varieties:

Variety 1: API Definitions

An API definition creates the types, endpoints, and backend functionality that goes into creating an API for the framework. They generally cover CRUD functionality, but can be as complex as needed, and come with a set of props which allow access to props.db (general pg-promise db), props.tx (pg-promise transactions for MUTATIONs), props.event.body (shape of queryArg), props.redis (node redis client). The following is an example API definiton.


export type IPayment = {
  id: string;
  contactId: string;
  details: AnyRecord;
};

const paymentApi = {
  postPayment: {
    kind: EndpointType.MUTATION,
    url: 'payments',
    method: 'POST',
    opts: {} as ApiOptions,
    queryArg: {} as IPayment,
    resultType: {} as IPayment
  },
  putPayment: {
    kind: EndpointType.MUTATION,
    url: 'payments',
    method: 'PUT',
    opts: {} as ApiOptions,
    queryArg: {} as IPayment,
    resultType: {} as IPayment
  },
  getPayments: {
    kind: EndpointType.QUERY,
    url: 'payments',
    method: 'GET',
    opts: {} as ApiOptions,
    queryArg: {} as Void,
    resultType: [] as IPayment[]
  },
  getPaymentById: {
    kind: EndpointType.QUERY,
    url: 'payments/:id',
    method: 'GET',
    opts: {} as ApiOptions,
    queryArg: { id: '' as string },
    resultType: {} as IPayment
  },
  deletePayment: {
    kind: EndpointType.MUTATION,
    url: 'payments/:id',
    method: 'DELETE',
    opts: {} as ApiOptions,
    queryArg: { id: '' as string },
    resultType: {} as IPayment
  },
  disablePayment: {
    kind: EndpointType.MUTATION,
    url: 'payments/:id/disable',
    method: 'PUT',
    opts: {} as ApiOptions,
    queryArg: { id: '' as string },
    resultType: { id: '' as string }
  }
} as const;

const paymentApiHandlers: ApiHandler<typeof paymentApi> = {
  postPayment: async props => {
    const { contactId, details } = props.event.body;

    const payment = await props.tx.one<IPayment>(`
      INSERT INTO dbtable_schema.payments (contact_id, details, created_sub)
      VALUES ($1, $2, $3::uuid)
      RETURNING id, contact_id as "contactId", details
    `, [contactId, details, props.event.userSub]);
    
    return payment;
  },
  putPayment: async props => {
    const { id, contactId, details } = props.event.body;

    const updateProps = buildUpdate({
      id,
      contact_id: contactId,
      details: JSON.stringify(details),
      updated_sub: props.event.userSub,
      updated_on: utcNowString()
    });

    const payment = await props.tx.one<IPayment>(`
      UPDATE dbtable_schema.payments
      SET ${updateProps.string}
      WHERE id = $1
      RETURNING id, contact_id as "contactId", details
    `, updateProps.array);

    return payment;
  },
  getPayments: async props => {
    const payments = await props.db.manyOrNone<IPayment>(`
      SELECT * FROM dbview_schema.enabled_payments
    `);
    
    return payments;
  },
  getPaymentById: async props => {
    const { id } = props.event.pathParameters;

    const payment = await props.db.one<IPayment>(`
      SELECT * FROM dbview_schema.enabled_payments
      WHERE id = $1
    `, [id]);
    
    return payment;
  },
  deletePayment: async props => {
    const { id } = props.event.pathParameters;

    await props.tx.none(`
      DELETE FROM dbtable_schema.payments
      WHERE id = $1
    `, [id]);
    
    return { id };
  },
  disablePayment: async props => {
    const { id } = props.event.pathParameters;

    await props.tx.none(`
      UPDATE dbtable_schema.payments
      SET enabled = false, updated_on = $2, updated_sub = $3
      WHERE id = $1
    `, [id, utcNowString(), props.event.userSub]);

    return { id };
  }
} as const;

type PaymentApi = typeof paymentApi;

type PaymentApiHandler = typeof paymentApiHandlers;

declare module './api' {
  interface SiteApiRef extends Extend<PaymentApi> { }
  interface SiteApiHandlerRef extends Extend<PaymentApiHandler> { }
}

Object.assign(siteApiRef, paymentApi);
Object.assign(siteApiHandlerRef, paymentApiHandlers);

Variety 2: React Components

The framework utilizes react as the user interface, and with that @reduxjs/toolkit. RTK-query auto generates react hooks using the names of the api endpoints in our api definition files. For example, postPayment would auto generate a react hook called usePostPaymentMutation, and getUsers would auto generate two react hooks, useGetUsersQuery and useLazyGetUsersQuery. Hooks are imported into component files like import { sh } from 'awayto/hooks' and used like sh.useGetUsersQuery. These hooks, and the components imported by useComponents, essentially define the relationships of functionality within the framework. The following is a react component in the framework which utilizes these concepts.

export function Onboard(props: IProps): JSX.Element {

  const [joinGroup] = sh.useJoinGroupMutation();

  const { setSnack } = useUtil();

  const { ManageGroupModal } = useComponents();

  const [groupCode, setGroupCode] = useState('');
  const [dialog, setDialog] = useState('');

  const joinGroupCb = useCallback(() => {
    if (groupCode) {
      if (/^[a-zA-Z0-9]{8}$/.test(groupCode)) {
        joinGroup({ code: groupCode }).unwrap().then(() => keycloak.clearToken()).catch(console.error);
      } else {
        setSnack({ snackType: 'warning', snackOn: 'Invalid group code.' });
      }
    }
  }, [groupCode]);

  return <>

    <Dialog fullScreen open={dialog === 'create_group'} fullWidth maxWidth="sm">
      <Box sx={{ bgcolor: 'primary.dark' }}>
        <Grid container sx={{ placeContent: 'center', minHeight: '100vh', height: '100%' }}>
          <Grid item xs={6}>
            <Suspense>
              <ManageGroupModal
                {...props}
                closeModal={() => {
                  setDialog('');
                }}
              />
            </Suspense>
          </Grid>
        </Grid>
      </Box>
    </Dialog>

    <Box sx={{ bgcolor: 'primary.dark' }}>
      <Grid container sx={{ placeItems: { xs: 'start', sm: 'center' }, minHeight: '100vh', height: '100%' }}>

        <Grid item xs={12} sm={4} md={6}>
          <Grid container p={4} spacing={4}>


            <Grid item xs={12}>
              <TextField
                fullWidth
                value={groupCode}
                onChange={e => setGroupCode(e.target.value)}
                label="Group Code"
              />
            </Grid>

            <Grid item xs={12}>
              <Button fullWidth variant="contained" color="secondary" onClick={joinGroupCb}>Join a Group</Button>
            </Grid>
          </Grid>
        </Grid>
      </Grid>
    </Box>
  </>
}

export default Onboard;


Now that you understand more about the sturcture of the files we are using to prepare our artifacts, create a utility that will generate the requested prompt/response structure in the form of a JSONL file stored at the root of the utility.