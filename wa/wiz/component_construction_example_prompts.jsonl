{"prompt":"Create a react component BookingContext.tsx implementing application types IBooking. Create enum BookingContextType that uses IBooking as a member value or type. As a reminder, the application types related to this task and their purposes: IBooking.","completion":"import { IBooking } from 'awayto/core';\nimport { createContext } from 'react';\n\nexport type BookingContextType = {\n  bookingValues: IBooking[];\n  setBookingValuesChanged: (prop: boolean) => void;\n  bookingValuesChanged: boolean;\n  selectedBooking: IBooking[];\n  setSelectedBooking: (quotes: IBooking[]) => void;\n  handleSelectPendingBooking: (prop: IBooking) => void;\n  handleSelectPendingBookingAll: () => void;\n}\n\nexport const BookingContext = createContext<BookingContextType | null>(null);"}
{"prompt":"Create a react component BookingProvider.tsx implementing application types IBooking. Implement useState parts named [selectedBooking, setSelectedBooking] that uses IBooking. As a reminder, the application types related to this task and their purposes: IBooking.","completion":"import { useMemo, useState } from \"react\";\n\nimport { IBooking } from 'awayto/core';\nimport { sh } from 'awayto/hooks';\n\nimport { BookingContext, BookingContextType } from \"./BookingContext\";\n\nexport function BookingProvider ({ children }: IProps): JSX.Element {\n\n  const [bookingValuesChanged, setBookingValuesChanged] = useState(false);\n  const [selectedBooking, setSelectedBooking] = useState<IBooking[]>([]);\n\n  const { data : profile } = sh.useGetUserProfileDetailsQuery();\n\n  const bookingValues = useMemo(() => Object.values(profile?.bookings || {}), [profile]);\n\n  const bookingValuesContext = {\n    bookingValues,\n    setBookingValuesChanged,\n    bookingValuesChanged,\n    selectedBooking,\n    setSelectedBooking,\n    handleSelectPendingBooking(booking) {\n      const currentIndex = selectedBooking.indexOf(booking);\n      const newChecked = [...selectedBooking];\n\n      if (currentIndex === -1) {\n        newChecked.push(booking);\n      } else {\n        newChecked.splice(currentIndex, 1);\n      }\n\n      setSelectedBooking(newChecked);\n    },\n    handleSelectPendingBookingAll() {\n      const bookingValuesSet = selectedBooking.length === bookingValues.length ?\n        selectedBooking.filter(v => !bookingValues.includes(v)) :\n        [...selectedBooking, ...bookingValues.filter(v => !selectedBooking.includes(v))];\n      \n      setSelectedBooking(bookingValuesSet);\n    }\n  } as BookingContextType | null;\n\n  return <>\n    <BookingContext.Provider value={bookingValuesContext}>\n      {children}\n    </BookingContext.Provider>\n  </>;\n  \n}\n\nexport default BookingProvider;"}
{"prompt":"Create a react component SelectLookup.tsx implementing application types ILookup. Create interface IProps implementing ILookup as a property type, method parameter or return type. Implement useState parts named [newLookup, setNewLookup] that uses ILookup. Create a constant function named refresh that takes 0 parameter(s) and returns ILookup. Create a constant variable named firstLookup that uses ILookup. Create react component named SelectLookup implementing ILookup as a parameter or return type. As a reminder, the application types related to this task and their purposes: ILookup.","completion":"import React, { useCallback, useEffect, useState } from 'react';\nimport TextField from '@mui/material/TextField';\nimport IconButton from '@mui/material/IconButton';\nimport Box from '@mui/material/Box';\nimport MenuItem from '@mui/material/MenuItem';\nimport CircularProgress from '@mui/material/CircularProgress';\nimport InputAdornment from '@mui/material/InputAdornment';\nimport Grid from '@mui/material/Grid';\nimport ClearIcon from '@mui/icons-material/Clear';\nimport CheckIcon from '@mui/icons-material/Check';\n\nimport { ILookup } from 'awayto/core';\nimport { MutationTrigger, SiteMutation, useUtil } from 'awayto/hooks';\n\ndeclare global {\n  interface IProps {\n    multiple?: boolean;\n    disabled?: boolean;\n    noEmptyValue?: boolean;\n    lookups?: ILookup[];\n    lookupName?: string;\n    helperText?: string;\n    lookupChange?(value: string | string[]): void;\n    lookupValue?: string | string[];\n    defaultValue?: string | string[];\n    invalidValues?: string[];\n    refetchAction?: (props?: { [prop: string]: string }) => void;\n    attachAction?: MutationTrigger<SiteMutation<{ [prop: string]: string }, ILookup>>;\n    createAction?: MutationTrigger<SiteMutation<{ readonly name: string; }, ILookup>>;\n    deleteAction?: MutationTrigger<SiteMutation<{ [prop: string]: string }, ILookup[]>>;\n    parentUuidName?: string;\n    parentUuid?: string;\n    attachName?: string;\n    deleteActionIdentifier?: string\n  }\n}\n\nfunction isStringArray(str?: string | string[]): str is string[] {\n  return (str as string[]).forEach !== undefined;\n}\n\nexport function SelectLookup({ lookupChange, disabled = false, invalidValues = [], attachAction, attachName, refetchAction, parentUuidName, parentUuid, lookups, lookupName, helperText, lookupValue, multiple = false, noEmptyValue = false, createAction, deleteAction, deleteActionIdentifier }: IProps): JSX.Element {\n  \n  const { setSnack } = useUtil();\n\n  const [addingNew, setAddingNew] = useState<boolean | undefined>();\n  const [newLookup, setNewLookup] = useState({ name: '' } as ILookup);\n  const [lookupUpdater, setLookupUpdater] = useState(null as unknown as string);\n\n  if (!lookupName || !lookupChange) return <Grid container justifyContent=\"center\"><CircularProgress /></Grid>;\n\n  const refresh = () => {\n    setAddingNew(false);\n    setNewLookup({ name: '' } as ILookup)\n\n    if (refetchAction && parentUuidName && parentUuid) {\n      refetchAction({ [parentUuidName]: parentUuid });\n    }\n  }\n\n  const handleSubmit = useCallback(() => {\n    if (invalidValues.includes(newLookup.name)) {\n      setSnack({ snackType: 'warning', snackOn: 'That value cannot be used here.' })\n      return;\n    }\n\n    setLookupUpdater(newLookup.name);\n    if (createAction) {\n      createAction({ name: newLookup.name }).unwrap().then(res => {\n        const { id: lookupId } = res;\n        if (attachAction && lookupId && parentUuid && parentUuidName && attachName) {\n          attachAction({ [parentUuidName]: parentUuid, [attachName]: lookupId }).unwrap().then(() => refresh()).catch(console.error);\n        } else {\n          refresh();\n        }\n      }).catch(console.error);\n    }\n  }, [newLookup, createAction, attachAction, attachName, parentUuid, parentUuidName]);\n\n  useEffect(() => {\n    if (lookupValue && lookups?.length && isStringArray(lookupValue) && lookupUpdater) {\n      const updater = lookups.find(l => l.name === lookupUpdater);\n      if (updater?.id) {\n        lookupChange([ ...lookupValue, updater.id ]);\n        setLookupUpdater('');\n      }\n    }\n  }, [lookups, lookupValue, lookupUpdater]);\n\n  useEffect(() => {\n    if (lookupValue && lookups && lookups?.length && noEmptyValue && !lookupValue?.length) {\n      const firstLookup = lookups.at(0) as Required<ILookup>;\n      lookupChange(isStringArray(lookupValue) ? [firstLookup.id] : firstLookup.id);\n    }\n  }, [lookups, lookupValue, noEmptyValue]);\n\n  // useEffect(() => {\n  //   if (defaultValue && !lookupValue) {\n  //     lookupChange(defaultValue);\n  //   }\n  // }, [defaultValue, lookupValue]);\n\n  return (addingNew ?\n    <TextField\n      autoFocus\n      fullWidth\n      label={`New ${lookupName}`}\n      value={newLookup.name}\n      onChange={e => {\n        setNewLookup({ name: e.target.value } as ILookup)\n      }}\n      onKeyDown={(e) => {\n        ('Enter' === e.key && newLookup.name) && handleSubmit();\n      }}\n      InputProps={{\n        endAdornment: (\n          <InputAdornment position=\"end\">\n            <Box mb={2}>\n              <IconButton aria-label=\"close new record\" onClick={() => {\n                setAddingNew(false);\n                setNewLookup({ ...newLookup, name: '' });\n              }}>\n                <ClearIcon style={{ color: 'red' }} />\n              </IconButton>\n              <IconButton aria-label=\"create new record\" onClick={() => {\n                newLookup.name ? handleSubmit() : void setSnack({ snackOn: 'Provide a name for the record.', snackType: 'info' });\n              }}>\n                <CheckIcon style={{ color: 'green' }} />\n              </IconButton>\n            </Box>\n          </InputAdornment>\n        ),\n      }}\n    /> : <TextField\n      select\n      disabled={disabled}\n      autoFocus={!!lookupUpdater}\n      id={`${lookupName}-lookup-selection`}\n      fullWidth\n      helperText={helperText || ''}\n      label={`${lookupName}s`}\n      onChange={e => {\n        const { value } = e.target as { value: string | string[] };\n        if (isStringArray(value) && value.indexOf('new') > -1) {\n        } else {\n          lookupChange(value);\n        }\n      }}\n      value={lookupValue}\n      SelectProps={{\n        multiple,\n        renderValue: selected => {\n          if (isStringArray(selected as string[])) \n            return (selected as string[]).map(v => lookups?.find(r => r.id === v)?.name ).join(', ')\n          \n          return lookups?.find(r => r.id === selected)?.name as string\n        }\n      }}\n      \n    >\n      {!multiple && !noEmptyValue && <MenuItem value=\"\">No selection</MenuItem>}\n      {createAction && <MenuItem value=\"new\" onClick={e => {\n        e.preventDefault();\n        setAddingNew(true);\n      }}>Add a {lookupName} to this list</MenuItem>}\n      {!lookups?.length && <MenuItem disabled>You have no pre-defined {lookupName}s.<br /> Click the button above to add some.</MenuItem>}\n      {lookups?.length ? lookups.map((lookup, i) => (\n        <MenuItem key={i} style={{ display: 'flex' }} value={lookup.id}>\n          <span style={{ flex: '1' }}>{lookup.name}</span>\n          {refetchAction && deleteAction && <ClearIcon style={{ color: 'red', marginRight: '8px' }} onClick={e => {\n            e.stopPropagation();\n            if (isStringArray(lookupValue) && lookup.id) {\n              lookupChange([...lookupValue.filter(l => l !== lookup.id)]);\n            } else if (lookupValue === lookup.id) {\n              lookupChange('');\n            }\n\n            if (parentUuidName && parentUuid && attachName) {\n              deleteAction({ [parentUuidName]: parentUuid, [attachName]: lookup.id }).unwrap().then(() => refresh()).catch(console.error);\n            }\n\n            if (deleteActionIdentifier) {\n              deleteAction({ [deleteActionIdentifier]: lookup.id }).unwrap().then(() => refresh()).catch(console.error);\n            }\n\n          }} />}\n        </MenuItem>\n      )) : []}\n    </TextField>\n  )\n}\n\nexport default SelectLookup;\n\n"}
{"prompt":"Create a react component Transcript.tsx implementing application types ITranscriptMessage. Create interface IProps implementing ITranscriptMessage as a property type, method parameter or return type. As a reminder, the application types related to this task and their purposes: ITranscriptMessage.","completion":"import React, { useMemo } from 'react';\nimport dayjs from 'dayjs';\n\nimport { ITranscriptMessage } from 'awayto/core';\n\ndeclare global {\n  interface IProps {\n    messages?: ITranscriptMessage[];\n  }\n}\n\nfunction Transcript({ messages }: IProps): JSX.Element {\n  if (!messages) return <></>;\n  const sortedTranscript = useMemo(\n    () => messages.sort((a, b) => dayjs(a.timestamp).millisecond() - dayjs(b.timestamp).millisecond()),\n    [messages]\n  );\n\n  const groupedTranscript = useMemo(() => {\n    return sortedTranscript.reduce<Record<string, string[]>>((acc, message) => {\n      const { username, words: msg } = message;\n      if (!acc[username]) acc[username] = [] as string[];\n      acc[username].push(msg);\n      return acc;\n    }, {});\n  }, [sortedTranscript]);\n\n  const messagesLines = useMemo(() => {\n    const lines = [] as Record<string, string>[];\n    sortedTranscript.forEach(({ username, words: wrds, duration }) => {\n      const words = wrds.split(' ');\n      const wordsPerSec = words.length / duration;\n      const numLines = Math.ceil(words.length / (20 / wordsPerSec));\n      const wordsPerLine = Math.ceil(words.length / numLines);\n\n      for (let i = 0; i < numLines; i++) {\n        const lineWords = words.slice(i * wordsPerLine, (i + 1) * wordsPerLine);\n        const lineText = lineWords.join(' ');\n        lines.push({ username, text: lineText });\n      }\n    });\n    return lines;\n  }, [sortedTranscript]);\n\n  return (\n    <ul>\n      {Object.keys(groupedTranscript).map((username) => (\n        <li key={username}>\n          <h3>{username}</h3>\n          <ul>\n            {messagesLines\n              .filter((line) => line.username === username)\n              .map(({ text }, index) => (\n                <li key={index}>{text}</li>\n              ))}\n          </ul>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nexport default Transcript;"}
{"prompt":"Create a react component Field.tsx implementing application types IField. Create enum FieldProps that uses IField as a member value or type. As a reminder, the application types related to this task and their purposes: IField.","completion":"import React from 'react';\nimport { IField } from 'awayto/core';\nimport TextField, { TextFieldProps } from '@mui/material/TextField';\nimport Typography from '@mui/material/Typography';\n\ntype FieldProps = {\n  field?: IField;\n  editable?: boolean;\n};\n\ndeclare global {\n  interface IProps extends FieldProps {}\n}\n\nfunction Field ({ field, editable = false }: IProps): JSX.Element {\n  if (!field) return <></>;\n  let FieldElement: (props: TextFieldProps) => JSX.Element;\n\n  switch (field.t) {\n    case 'date':\n      FieldElement = TextField;\n      break;\n    case 'time':\n      FieldElement = TextField;\n      break;\n    case 'text':\n      FieldElement = TextField;\n      break;\n    case 'labelntext':\n      FieldElement = () => <>\n        <Typography variant=\"h6\">{field.l || 'Label'}</Typography>\n        <Typography variant=\"caption\">{field.x || 'Text'}</Typography>\n      </>\n      break;\n    default:\n      FieldElement = () => <></>;\n      break;\n  }\n\n  return <FieldElement\n    fullWidth\n    disabled={!editable}\n    label={field.l || 'Click to edit.'}\n    type={field.t}\n    helperText={`${field.r ? 'Required. ' : ''}${field.h || ''}`}\n    value={String(field.v || '')}\n  />;\n}\n\nexport default Field;"}
{"prompt":"Create a react component FormBuilder.tsx implementing application types IField, IFormVersion. Implement useState parts named [rows, setRows] that uses IField. Implement useState parts named [cell, setCell] that uses IField. Create a constant variable named makeField that uses IField. Create function named FormBuilder implementing IField as a parameter or return type. Create enum FormBuilderProps that uses IFormVersion as a member value or type. As a reminder, the application types related to this task and their purposes: IFieldIFormVersion.","completion":"import React, { useCallback, useMemo, useState, useEffect } from 'react';\nimport Grid from '@mui/material/Grid';\nimport Switch from '@mui/material/Switch';\nimport Button from '@mui/material/Button';\nimport Typography from '@mui/material/Typography';\nimport ButtonBase from '@mui/material/ButtonBase';\nimport Divider from '@mui/material/Divider';\nimport TextField from '@mui/material/TextField';\nimport MenuItem from '@mui/material/MenuItem';\n\n// text\n\n// Single line text input.\n\n// textarea\n\n// Multiple line text input.\n\n// textarea\n\n// select\n\n// Common single select input. See description how to configure options below.\n\n// select\n\n// select-radiobuttons\n\n// Single select input through group of radio buttons. See description how to configure options below.\n\n// group of input\n\n// multiselect\n\n// Common multiselect input. See description how to configure options below.\n\n// select\n\n// multiselect-checkboxes\n\n// Multiselect input through group of checkboxes. See description how to configure options below.\n\n// group of input\n\n// html5-email\n\n// Single line text input for email address based on HTML 5 spec.\n\n// html5-tel\n\n// Single line text input for phone number based on HTML 5 spec.\n\n// html5-url\n\n// Single line text input for URL based on HTML 5 spec.\n\n// html5-number\n\n// Single line input for number (integer or float depending on step) based on HTML 5 spec.\n\n// html5-range\n\n// Slider for number entering based on HTML 5 spec.\n\n// html5-datetime-local\n\n// Date Time input based on HTML 5 spec.\n\n// html5-date\n\n// Date input based on HTML 5 spec.\n\n// html5-month\n\n// Month input based on HTML 5 spec.\n\n// html5-week\n\n// Week input based on HTML 5 spec.\n\n// html5-time\n\n// Time input based on HTML 5 spec.\n\n\n\n\nimport { IField, IFormVersion } from 'awayto/core';\n\nimport Field from './Field';\n\nexport type FormBuilderProps = {\n  version?: IFormVersion;\n  setVersion?(value: IFormVersion): void;\n  editable?: boolean;\n};\n\ndeclare global {\n  interface IProps extends FormBuilderProps { }\n}\n\nexport default function FormBuilder({ version, setVersion, editable = true }: IProps & Required<FormBuilderProps>): JSX.Element {\n\n  const [rows, setRows] = useState({} as Record<string, IField[]>);\n  const [cell, setCell] = useState({} as IField);\n  const [position, setPosition] = useState({ row: '', col: 0 });\n\n  useEffect(() => {\n    if (Object.keys(rows).length) {\n      setVersion({ ...version, form: rows });\n    }\n  }, [rows]);\n\n  useEffect(() => {\n    if (Object.keys(version.form).length) {\n      setRows({ ...version.form });\n    }\n  }, [version]);\n\n  const rowKeys = useMemo(() => Object.keys(rows), [rows]);\n\n  const addRow = useCallback(() => setRows({ ...rows, [(new Date()).getTime().toString()]: [makeField()] }), [rows]);\n\n  // const delRow = useCallback((row: string) => {\n  //   delete rows[row];\n  //   setRows({ ...rows });\n  // }, [rows]);\n\n  const addCol = useCallback((row: string) => setRows({ ...rows, [row]: Array.prototype.concat(rows[row], [makeField()]) }), [rows]);\n\n  const delCol = useCallback((row: string, col: number) => {\n    rows[row].splice(col, 1);\n    if (!rows[row].length) delete rows[row];\n    setRows({ ...rows });\n  }, [rows]);\n\n  const makeField = useCallback((): IField => ({ l: '', t: 'text', h: '', r: false, v: '', x: '' }), []);\n\n  const setCellAttr = useCallback((value: string, attr: string) => {\n    rows[position.row][position.col][attr] = value;\n    setRows({ ...rows })\n  }, [rows, position]);\n\n  return <Grid container spacing={2}>\n\n    <Grid item sx={{ display: 'flex', flex: 1, alignItems: 'start' }}>\n      <Grid container spacing={2}>\n        {Object.keys(rows).length < 3 && <Grid item xs={12}>\n          <Button variant=\"outlined\" fullWidth onClick={addRow}>add row</Button>\n        </Grid>}\n        {Object.keys(rows).length > 0 && <Grid item xs={12}>\n          <Typography variant=\"subtitle1\">Start by editing the field and adding a label.</Typography>\n        </Grid>}\n        {rowKeys.map((rowId, i) => <Grid key={`form_fields_row_${i}`} item xs={12}>\n          <Grid container spacing={2}>\n            {rows[rowId].length < 3 && <Grid item xs={12} md={2}>\n              <Grid container direction=\"column\" sx={{ placeItems: 'center', height: '100%' }}>\n                <Button fullWidth variant=\"outlined\" color=\"warning\" sx={{ display: 'flex', flex: 1 }} onClick={() => addCol(rowId)}>add column</Button>\n                {/* <ButtonBase sx={{ display: 'flex', padding: '2px', backgroundColor: 'rgba(255, 0, 0, .1)' }} onClick={() => delRow(rowId)}>- row</ButtonBase> */}\n              </Grid>\n            </Grid>}\n            <Grid item xs={12} md={rows[rowId].length < 3 ? 10 : 12}>\n              <Grid container spacing={2}>\n                {rows[rowId].map((field, j) => {\n                  return <Grid item xs={12 / rows[rowId].length} key={`form_fields_cell_${i + 1}_${j}`}>\n                    <ButtonBase\n                      sx={{\n                        width: '100%',\n                        backgroundColor: position.row === rowId && position.col === j ? 'rgba(0, 150, 200, .1)' : 'rgba(0, 0, 0, .1)',\n                        cursor: 'pointer !important'\n                      }}\n                      onClick={() => {\n                        setCell(field);\n                        setPosition({ row: rowId, col: j })\n                      }}\n                    >\n                      <Field field={field} />\n                    </ButtonBase>\n                  </Grid>\n                })}\n              </Grid>\n            </Grid>\n          </Grid>\n        </Grid>)}\n      </Grid>\n    </Grid>\n\n    {editable && Object.hasOwn(cell, 'l') && <Grid item>\n      <Divider orientation=\"vertical\" />\n    </Grid>}\n\n    {editable && Object.hasOwn(cell, 'l') && <Grid item xs={4}>\n      <Grid container spacing={2} direction=\"column\">\n\n        <Grid item>\n          <Grid container alignItems=\"center\">\n            <Grid item sx={{ display: 'flex', flex: 1 }}>\n              <Typography variant=\"body2\">Field Attributes</Typography>\n            </Grid>\n            <Grid item>\n              <Button variant=\"text\" onClick={() => {\n                setPosition({ row: '', col: 0 })\n                setCell({} as IField);\n              }}>X</Button>\n            </Grid>\n          </Grid>\n        </Grid>\n\n        <Grid item>\n          <Button fullWidth color=\"error\" onClick={() => {\n            setPosition({ row: '', col: 0 })\n            delCol(position.row, position.col);\n            setCell({} as IField);\n          }}>Delete</Button>\n        </Grid>\n\n        <Grid item>\n          <TextField fullWidth label=\"Label\" type=\"text\" helperText=\"Required.\" value={cell.l} onChange={e => setCellAttr(e.target.value, 'l')} />\n        </Grid>\n\n        {'labelntext' === cell.t && <Grid item>\n          <TextField fullWidth label=\"Text\" type=\"text\" value={cell.x} onChange={e => setCellAttr(e.target.value, 'x')} />\n        </Grid>}\n\n        <Grid item>\n          <TextField\n            fullWidth\n            select\n            label=\"Field Type\"\n            value={cell.t}\n            onChange={e => setCellAttr(e.target.value, 't')}\n          >\n            <MenuItem key={1111} value={'text'}>Textfield</MenuItem>\n            <MenuItem key={23432423} value={'date'}>Date</MenuItem>\n            <MenuItem key={235325} value={'time'}>Time</MenuItem>\n            <MenuItem key={235324325} value={'labelntext'}>Label and Text</MenuItem>\n          </TextField>\n        </Grid>\n\n        <Grid item>\n          <TextField fullWidth label=\"Helper Text\" type=\"text\" value={cell.h} onChange={e => setCellAttr(e.target.value, 'h')} />\n        </Grid>\n\n        <Grid item>\n          <Typography variant=\"body1\">Required</Typography>\n          <Switch value={cell.r} checked={cell.r} onChange={() => {\n            rows[position.row][position.col].r = !cell.r;\n            setRows({ ...rows })\n          }} />\n        </Grid>\n\n      </Grid>\n    </Grid>}\n\n  </Grid>;\n}"}
{"prompt":"Create a react component FormDisplay.tsx implementing application types IFormTemplate, IForm. Implement useState parts named [rows, setRows] that uses IFormTemplate. Create enum FormDisplayProps that uses IForm as a member value or type. As a reminder, the application types related to this task and their purposes: IFormTemplateIForm.","completion":"import React, { useCallback, useMemo, useState, useEffect } from 'react';\nimport Grid from '@mui/material/Grid';\nimport TextField from '@mui/material/TextField';\n\nimport { IForm, IFormTemplate } from 'awayto/core';\n\nexport type FormDisplayProps = {\n  form?: IForm;\n  setForm?(value: IForm): void;\n};\n\ndeclare global {\n  interface IProps extends FormDisplayProps { }\n}\n\nexport default function FormDisplay({ form, setForm }: IProps & Required<FormDisplayProps>): JSX.Element {\n\n  const [rows, setRows] = useState({} as IFormTemplate);\n  const [formId, setFormId] = useState('');\n\n  useEffect(() => {\n    if (Object.keys(rows).length) {\n      setForm({\n        ...form,\n        version: {\n          ...form.version,\n          submission: Object.keys(rows).reduce((m, rowId) => {\n            return {\n              ...m,\n              [rowId]: rows[rowId].map(r => r.v)\n            }\n          }, {})\n        }\n      });\n    }\n  }, [rows]);\n\n  useEffect(() => {\n    if (form.id !== formId && Object.keys(form.version.form).length) {\n      setRows({ ...form.version.form });\n      setFormId(form.id)\n    }\n  }, [form, formId]);\n\n  const rowKeys = useMemo(() => Object.keys(rows), [rows]);\n\n  const setCellAttr = useCallback((row: string, col: number, value: string, attr: string) => {\n    rows[row][col][attr] = value;\n    setRows({ ...rows })\n  }, [rows]);\n\n  return <Grid container spacing={2}>\n\n    {rowKeys.map((rowId, i) => <Grid key={`form_fields_row_${i}`} item xs={12}>\n      <Grid container spacing={2}>\n        {rows[rowId].map((cell, j) => {\n          return <Grid key={`form_fields_cell_${i + 1}_${j}`} item xs={12 / rows[rowId].length}>\n            <TextField\n              fullWidth\n              label={cell.l}\n              type={cell.t || 'text'}\n              helperText={`${cell.r ? 'Required. ' : ''}${cell.h || ''}`}\n              onChange={e => setCellAttr(rowId, j, e.target.value, 'v')}\n            />\n          </Grid>\n        })}\n      </Grid>\n    </Grid>)}\n\n  </Grid>\n}"}
{"prompt":"Create a react component ManageFormModal.tsx implementing application types IField, IFormVersion, IForm, IGroupForm. Create a constant variable named fields that uses IField. Implement useState parts named [version, setVersion] that uses IFormVersion. Create interface IProps implementing IForm as a property type, method parameter or return type. Implement useState parts named [form, setForm] that uses IForm. Create a constant variable named formVersion that uses IForm. Create a constant variable named handleSubmit that uses IGroupForm. As a reminder, the application types related to this task and their purposes: IFieldIFormVersionIFormIGroupForm.","completion":"import React, { useEffect, useState, useCallback } from 'react';\nimport { useParams } from 'react-router';\n\nimport Grid from '@mui/material/Grid';\nimport Box from '@mui/material/Box';\nimport Card from '@mui/material/Card';\nimport CardContent from '@mui/material/CardContent';\nimport CardHeader from '@mui/material/CardHeader';\nimport CardActions from '@mui/material/CardActions';\nimport Button from '@mui/material/Button';\nimport TextField from '@mui/material/TextField';\n\nimport { IForm, IFormVersion, IField, IGroupForm } from 'awayto/core';\nimport { useComponents, sh, useUtil } from 'awayto/hooks';\n\ndeclare global {\n  interface IProps {\n    editForm?: IForm;\n  }\n}\n\nexport function ManageFormModal({ editForm, closeModal, ...props }: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const [postGroupFormVersion] = sh.usePostGroupFormVersionMutation();\n  const [postGroupForm] = sh.usePostGroupFormMutation();\n  const [getGroupFormById] = sh.useLazyGetGroupFormByIdQuery();\n\n  const { setSnack } = useUtil();\n\n  const { FormBuilder } = useComponents();\n  const [version, setVersion] = useState({ form: {} } as IFormVersion);\n  const [form, setForm] = useState({ name: '', ...editForm } as IForm);\n  const [editable, setEditable] = useState(true);\n\n  useEffect(() => {\n    if (editForm) {\n      getGroupFormById({ formId: editForm.id, groupName }).unwrap().then(res => {\n        setForm(res);\n        if (res.version) {\n          setVersion(res.version);\n        }\n      }).catch(console.error);\n    }\n  }, [editForm]);\n\n  useEffect(() => {\n    if (form.version && Object.keys(form.version).length) {\n      const vers = form.version;\n\n      Object.keys(vers.form).forEach(k => {\n        vers.form[k].forEach(f => {\n          if (!f.t) f.t = 'text';\n          if (!f.h) f.h = '';\n          if (!f.r) f.r = false;\n        });\n      });\n\n      setVersion(form.version);\n    }\n  }, [form]);\n\n  const handleSubmit = useCallback(() => {\n    setEditable(false);\n    const { id, name } = form;\n\n    if (!name || !Object.keys(version.form).length || Object.values(version.form).some(v => v.some(f => !f.l))) {\n      setSnack({ snackType: 'error', snackOn: 'Forms must have a name, and at least 1 field. All fields mus have a label.' });\n      setEditable(true);\n      return;\n    }\n\n    const newForm = Object.keys(version.form).reduce((m, k, i) => {\n      const fields = [...version.form[k]] as IField[];\n      return {\n        ...m,\n        [i]: fields.map(f => {\n          delete f.v;\n          if ('' === f.t) delete f.t;\n          if ('' === f.h) delete f.h;\n          if ('' === f.x) delete f.x;\n          if (false === f.r) delete f.r;\n          return f;\n        })\n      }\n    }, {});\n\n    const formVersion = {\n      id,\n      name,\n      version: {\n        form: newForm,\n        formId: id\n      }\n    } as IForm;\n\n    (id ? postGroupFormVersion : postGroupForm)((id ? { ...formVersion, formId: id, groupName } : { ...formVersion, groupName }) as IGroupForm).unwrap().then(() => closeModal && closeModal()).catch(console.error);\n  }, [form, version.form]);\n\n  return <Card sx={{ display: 'flex', flex: 1, flexDirection: 'column' }}>\n    <CardHeader title={editForm?.id ? 'Manage' : 'Create'} />\n    <CardContent sx={{ display: 'flex', flex: 1, flexDirection: 'column', overflow: 'auto' }}>\n      <Box mt={2} />\n\n      <Box mb={4}>\n        <TextField\n          fullWidth\n          autoFocus\n          id=\"name\"\n          label=\"Name\"\n          name=\"name\"\n          value={form.name}\n          onKeyDown={e => {\n            if ('Enter' === e.key) {\n              handleSubmit();\n            }\n          }}\n          onChange={e => setForm({ ...form, name: e.target.value })}\n        />\n      </Box>\n\n      <FormBuilder {...props} editable={editable} version={version} setVersion={setVersion} />\n\n    </CardContent>\n    <CardActions>\n      <Grid container justifyContent=\"space-between\">\n        <Button onClick={closeModal}>Cancel</Button>\n        <Button onClick={handleSubmit}>Submit</Button>\n      </Grid>\n    </CardActions>\n  </Card>\n}\n\nexport default ManageFormModal;"}
{"prompt":"Create a react component ManageForms.tsx implementing application types IGroupForm. Implement useState parts named [form, setForm] that uses IGroupForm. Create a constant variable named FormGrid that uses IGroupForm. As a reminder, the application types related to this task and their purposes: IGroupForm.","completion":"import React, { useState, useMemo, Suspense } from 'react';\nimport { useParams } from 'react-router';\nimport dayjs from 'dayjs';\n\nimport Box from '@mui/material/Box';\nimport Typography from '@mui/material/Typography';\nimport Button from '@mui/material/Button';\nimport Dialog from '@mui/material/Dialog';\nimport Tooltip from '@mui/material/Tooltip';\n\nimport CreateIcon from '@mui/icons-material/Create';\nimport NoteAddIcon from '@mui/icons-material/NoteAdd';\nimport DeleteIcon from '@mui/icons-material/Delete';\n\nimport { IGroupForm } from 'awayto/core';\nimport { sh, useGrid } from 'awayto/hooks';\n\nimport ManageFormModal from './ManageFormModal';\n\nexport function ManageForms(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n  \n  const [deleteGroupForm] = sh.useDeleteGroupFormMutation();\n  const { data: groupForms, refetch: getGroupForms } = sh.useGetGroupFormsQuery({ groupName });\n\n  const [form, setForm] = useState<IGroupForm>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <Tooltip key={'manage_form'} title=\"Edit\">\n        <Button onClick={() => {\n          setForm(groupForms?.find(gf => gf.id === selected[0]));\n          setDialog('manage_form');\n          setSelected([]);\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip> \n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_group'} title=\"Delete\">\n        <Button onClick={() => {\n          if (selected.length) {\n            deleteGroupForm({ groupName, ids: selected.join(',') }).unwrap().then(() => {\n              setSelected([]);\n              void getGroupForms();\n            }).catch(console.error);\n          }\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ]\n  }, [selected]);\n\n  const FormGrid = useGrid<IGroupForm>({\n    rows: groupForms || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Forms:</Typography>\n      <Tooltip key={'manage_form'} title=\"Create\">\n        <Button onClick={() => {\n          setForm(undefined);\n          setDialog('manage_form')\n        }}\n        >\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\n          <NoteAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  });\n\n  return <>\n    <Dialog fullScreen open={dialog === 'manage_form'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageFormModal {...props} editForm={form} closeModal={() => {\n          setDialog('')\n          void getGroupForms();\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <FormGrid />\n\n  </>\n}\n\nexport default ManageForms;"}
{"prompt":"Create a react component InviteUsersModal.tsx implementing application types IUserProfile. Implement useState parts named [users, setUsers] that uses IUserProfile. Create a constant variable named handleAdd that uses IUserProfile. As a reminder, the application types related to this task and their purposes: IUserProfile.","completion":"import React, { useState, useCallback } from 'react';\nimport Grid from '@mui/material/Grid';\nimport Typography from '@mui/material/Typography';\nimport Button from '@mui/material/Button';\nimport Card from '@mui/material/Card';\nimport CardContent from '@mui/material/CardContent';\nimport CardActions from '@mui/material/CardActions';\n\nimport { IUserProfile } from 'awayto/core';\nimport { sh, useUtil } from 'awayto/hooks';\nimport { TextField } from '@mui/material';\n\nexport function InviteUsersModal({ closeModal }: IProps): JSX.Element {\n\n  const { setSnack } = useUtil();\n  const [inviteGroupUser] = sh.useInviteGroupUserMutation();\n\n  const [email, setEmail] = useState('');\n  const [users, setUsers] = useState<IUserProfile[]>([]);\n\n  const handleAdd = useCallback(() => {\n    setUsers([...users, { email } as IUserProfile]);\n    setEmail('');\n  }, [users, email]);\n\n  const handleSubmit = useCallback(() => {\n    if (!users.length) {\n      setSnack({ snackType: 'error', snackOn: 'Please provide at least 1 email.' });\n      return;\n    }\n\n    inviteGroupUser({ users }).unwrap().then(() => {\n      if (closeModal)\n        closeModal();\n    }).catch(console.error);\n  }, [users]);\n\n  return <>\n    <Card>\n      <CardContent>\n        <Typography variant=\"button\">Invite Users</Typography>\n      </CardContent>\n      <CardContent>\n        <Grid container>\n          <Grid item xs={12}>\n            <Grid container>\n              <Grid item xs={12}>\n                <TextField\n                  label=\"Email\"\n                  type=\"email\"\n                  placeholder=\"Type an email and press enter...\"\n                  fullWidth\n                  value={email}\n                  onChange={e => {\n                    setEmail(e.currentTarget.value)\n                  }}\n                  InputProps={{\n                    onKeyDown: e => {\n                      if ('Enter' === e.key && e.currentTarget.validity.valid) {\n                        handleAdd();\n                      }\n                    }\n                  }}\n                />\n              </Grid>\n              <Grid item xs={12}>\n                <ul>\n                  {users.map(({ email }, i) => <li key={`group_invite_email_${i}`}>{email}</li>)}\n                </ul>\n              </Grid>\n            </Grid>\n          </Grid>\n        </Grid>\n      </CardContent>\n      <CardActions>\n        <Grid container justifyContent=\"flex-end\">\n          <Button onClick={closeModal}>Cancel</Button>\n          <Button onClick={handleSubmit}>Submit</Button>\n        </Grid>\n      </CardActions>\n    </Card>\n  </>\n}\n\nexport default InviteUsersModal;"}
{"prompt":"Create a react component ManageGroupModal.tsx implementing application types IGroup, IRole. Create interface IProps implementing IGroup as a property type, method parameter or return type. Implement useState parts named [group, setGroup] that uses IGroup. Create a constant variable named handleSubmit that uses IRole. As a reminder, the application types related to this task and their purposes: IGroupIRole.","completion":"import React, { useEffect, useState, useCallback, ChangeEvent, useMemo } from 'react';\r\n\r\nimport Box from '@mui/material/Box';\r\nimport Grid from '@mui/material/Grid';\r\nimport Typography from '@mui/material/Typography';\r\nimport Chip from '@mui/material/Chip';\r\nimport Card from '@mui/material/Card';\r\nimport CardContent from '@mui/material/CardContent';\r\nimport CardHeader from '@mui/material/CardHeader';\r\nimport CardActions from '@mui/material/CardActions';\r\nimport Button from '@mui/material/Button';\r\nimport Alert from '@mui/material/Alert';\r\nimport Link from '@mui/material/Link';\r\nimport TextField from '@mui/material/TextField';\r\nimport MenuItem from '@mui/material/MenuItem';\r\nimport CircularProgress from '@mui/material/CircularProgress';\r\nimport InputAdornment from '@mui/material/InputAdornment';\r\n\r\nimport ArrowRightAlt from '@mui/icons-material/ArrowRightAlt';\r\nimport NotInterestedIcon from '@mui/icons-material/NotInterested';\r\n\r\nimport { IGroup, IPrompts, IRole } from 'awayto/core';\r\nimport { useComponents, sh, useUtil } from 'awayto/hooks';\r\n\r\nimport keycloak from '../../keycloak';\r\n\r\ndeclare global {\r\n  interface IProps {\r\n    editGroup?: IGroup;\r\n  }\r\n}\r\n\r\nexport function ManageGroupModal({ editGroup, closeModal, ...props }: IProps): JSX.Element {\r\n\r\n  const { setSnack } = useUtil();\r\n\r\n  const { SelectLookup } = useComponents();\r\n\r\n  const { data : profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const [putGroup] = sh.usePutGroupMutation();\r\n  const [postGroup] = sh.usePostGroupMutation();\r\n  const [getPrompt] = sh.useLazyGetPromptQuery();\r\n  const [postRole] = sh.usePostRoleMutation();\r\n  const [deleteRole] = sh.useDeleteRoleMutation();\r\n  const [checkGroupName, { data: nameCheck }] = sh.useLazyCheckGroupNameQuery();\r\n  const { isValid: groupNameValid } = nameCheck || {};\r\n\r\n  const [defaultRoleId, setDefaultRoleId] = useState(editGroup?.defaultRoleId || '');\r\n  const [roleIds, setRoleIds] = useState<string[]>([]);\r\n  const [group, setGroup] = useState({ name: '', purpose: '', allowedDomains: '', ...editGroup } as IGroup);\r\n  const [viewStep, setViewStep] = useState(1);\r\n  const [editedPurpose, setEditedPurpose] = useState(false);\r\n  const [roleSuggestions, setRoleSuggestions] = useState([] as string[]);\r\n  const [allowedDomains, setAllowedDomains] = useState([profile?.username?.split('@')[1]] as string[]);\r\n  const [allowedDomain, setAllowedDomain] = useState('');\r\n\r\n  const [{ isValid, needCheckName, checkedName, checkingName }, setChecker] = useState<Partial<{\r\n    isValid: boolean,\r\n    needCheckName: boolean,\r\n    checkedName: string,\r\n    checkingName: boolean\r\n  }>>({\r\n    isValid: !!groupNameValid,\r\n    needCheckName: false,\r\n    checkedName: '',\r\n    checkingName: false\r\n  });\r\n\r\n  const progressMemo = useMemo(() => <CircularProgress size=\"20px\" />, []);\r\n  const roleValues = useMemo(() => Object.values(profile?.roles || {}), [profile]);\r\n\r\n  const formatName = useCallback((name: string) => name\r\n    .replaceAll(/__+/g, '_')\r\n    .replaceAll(/\\s/g, '_')\r\n    .replaceAll(/[\\W]+/g, '_')\r\n    .replaceAll(/__+/g, '_')\r\n    .replaceAll(/__+/g, '').toLowerCase() // Enforce a name like this_is_a_name\r\n    , []);\r\n\r\n  const badName = !checkingName && !isValid && !!group?.name && formatName(group.name) == checkedName;\r\n\r\n  const handleSubmit = useCallback(() => {\r\n    const { id, name, purpose } = group;\r\n\r\n    if (!name || !roleIds.length || !defaultRoleId) {\r\n      setSnack({ snackType: 'error', snackOn: 'All fields are required.' });\r\n      return;\r\n    }\r\n   \r\n    (id ? putGroup : postGroup)({\r\n      id,\r\n      name: formatName(name),\r\n      purpose,\r\n      allowedDomains: allowedDomains.join(','),\r\n      roles: Object.fromEntries(roleIds.map(id => [id, roleValues.find(r => r.id === id)] as [string, IRole])),\r\n      defaultRoleId\r\n    }).unwrap().then(() => {\r\n      id && setSnack({ snackType: 'success', snackOn: 'Group updated! Please allow up to a minute for any related permissions changes to persist.' })\r\n      !id && keycloak.clearToken();\r\n    }).catch(console.error);\r\n  }, [group, profile, roleIds, defaultRoleId]);\r\n\r\n\r\n  const handleName = useCallback((event: ChangeEvent<HTMLTextAreaElement>) => {\r\n    setChecker({ checkingName: true });\r\n    const name = event.target.value;\r\n    if (name.length <= 50) {\r\n      setGroup({ ...group, name });\r\n      setChecker({ checkedName: formatName(name), needCheckName: name != editGroup?.name });\r\n    } else if (isValid) {\r\n      setChecker({ checkingName: false });\r\n    }\r\n  }, [group, editGroup]);\r\n\r\n  const handleContinue = useCallback(() => {\r\n    getPrompt({ id: IPrompts.SUGGEST_ROLE, prompt: `${group.name}|||${group.purpose}` }).unwrap().then(res => {\r\n      setRoleSuggestions(res.promptResult);\r\n      setViewStep(2);\r\n    }).catch(console.error);\r\n  }, [group]);\r\n\r\n  if (!roleIds.length && roleValues?.length && group.roles && !defaultRoleId) {\r\n    setRoleIds(Object.keys(group.roles))\r\n  }\r\n\r\n  if (roleIds.length && !defaultRoleId) {\r\n    setDefaultRoleId(roleIds[0]);\r\n  }\r\n\r\n  useEffect(() => {\r\n    if (needCheckName && checkedName?.length) {\r\n      setChecker({ checkingName: true, needCheckName: false, isValid: false });\r\n      checkGroupName({ name: checkedName }).catch(console.error);\r\n    }\r\n  }, [needCheckName, checkedName]);\r\n\r\n  const roleSuggestionLinks = <>\r\n    AI: {roleSuggestions.filter(s => s.toLowerCase() !== 'admin').map((s, i) => {\r\n      return <span key={`role-selection-${i}`}>\r\n        <Link sx={{ cursor: 'pointer' }} onClick={() => {\r\n          // The currently suggested role in the user detail's role list\r\n          const existingId = roleValues.find(r => r.name === s)?.id;\r\n\r\n          // If the role is not in the user detail roles list, or it is, but it doesn't exist in the current list, continue\r\n          if (!existingId || (existingId && !roleIds.includes(existingId))) {\r\n\r\n            // If the role is in the user details roles list\r\n            if (existingId) {\r\n              setRoleIds([...roleIds, existingId])\r\n            } else {\r\n              postRole({ name: s }).unwrap().then(async newRole => {\r\n                await getUserProfileDetails();\r\n                !roleIds.includes(newRole.id) && setRoleIds([...roleIds, newRole.id]);\r\n              }).catch(console.error);\r\n            }\r\n          }\r\n        }}>{s}</Link>{i !== roleSuggestions.length - 1 ? ',' : ''}&nbsp;\r\n      </span>\r\n    })}\r\n  </>\r\n\r\n  return <>\r\n    <Card>\r\n      <CardHeader title={(editGroup ? 'Manage' : 'Create') + ' Group'}></CardHeader>\r\n      <CardContent>\r\n        {1 === viewStep ? <Grid container spacing={4}>\r\n          <Grid item xs={12}>\r\n            <TextField\r\n              fullWidth\r\n              id=\"name\"\r\n              label=\"Name\"\r\n              value={group.name}\r\n              name=\"name\"\r\n              onChange={handleName}\r\n              multiline\r\n              helperText=\"Group names can only contain letters, numbers, and underscores. Max 50 characters.\"\r\n              error={badName}\r\n              InputProps={{\r\n                endAdornment: group.name && (\r\n                  <InputAdornment\r\n                    component={({ children }) =>\r\n                      <Grid container style={{ width: 'calc(100% + 5em)', maxWidth: 'calc(100% + 5em)' }}>\r\n                        {children}\r\n                      </Grid>\r\n                    }\r\n                    position=\"start\"\r\n                  >\r\n                    <Grid item style={{ alignSelf: 'center' }}>\r\n                      {checkingName ? progressMemo :\r\n                        badName ? <NotInterestedIcon color=\"error\" /> : <ArrowRightAlt />}\r\n                    </Grid>\r\n                    <Grid item xs style={{ wordBreak: 'break-all' }}>\r\n                      <Typography style={{\r\n                        padding: '2px 4px',\r\n                        border: `1px solid #666`,\r\n                        lineHeight: '1.15em'\r\n                      }}>\r\n                        {formatName(group.name)}\r\n                      </Typography>\r\n                    </Grid>\r\n                  </InputAdornment>\r\n                ),\r\n              }}\r\n            />\r\n          </Grid>\r\n          <Grid item xs={12}>\r\n            <TextField\r\n              id={`group-purpose-entry`}\r\n              fullWidth\r\n              inputProps={{ minLength: 25, maxLength: 100 }}\r\n              helperText={'Enter a short phrase about the function of your group (25 to 100 characters).'}\r\n              label={`Group Purpose`}\r\n              error={editedPurpose && !!group.purpose && group.purpose.length < 25}\r\n              onBlur={() => setEditedPurpose(true)}\r\n              onFocus={() => setEditedPurpose(false)}\r\n              onChange={e => setGroup({ ...group, purpose: e.target.value })}\r\n              value={group.purpose}\r\n            />\r\n          </Grid>\r\n          <Grid item xs={12}>\r\n            <TextField\r\n              id={`group-allowed-domains-entry`}\r\n              fullWidth\r\n              helperText={`These domains will be allowed to join the group. Remove all for unrestricted access.`}\r\n              label={`Allowed Domains`}\r\n              onChange={e => setAllowedDomain(e.target.value)}\r\n              value={allowedDomain}\r\n              InputProps={{\r\n                endAdornment: <Button\r\n                  variant=\"text\"\r\n                  color=\"secondary\"\r\n                  onClick={() => {\r\n                    if (!/[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*/.test(allowedDomain)) {\r\n                      setSnack({ snackType: 'info', snackOn: 'Must be an email domain, like DOMAIN.COM'})\r\n                    } else {\r\n                      setAllowedDomains([ ...allowedDomains, allowedDomain ])\r\n                      setAllowedDomain('');\r\n                    }\r\n                  }}\r\n                >Add</Button>\r\n              }}\r\n            />\r\n            <Grid container>\r\n              {allowedDomains.map((ad, i) => <Box key={`allowed-domain-selection-${i}`} mt={2} mr={2}>\r\n                <Chip\r\n                  label={ad}\r\n                  color=\"secondary\"\r\n                  onDelete={() => {\r\n                    setAllowedDomains(allowedDomains.filter(da => da !== ad))\r\n                  }}\r\n                />\r\n              </Box>)}\r\n            </Grid>\r\n          </Grid>\r\n        </Grid> :\r\n          <Grid container spacing={4}>\r\n            <Grid item>\r\n              <Typography variant=\"h6\">Roles</Typography>\r\n              <Typography variant=\"body2\">Each group needs a set of roles to assign to its users. After creating this group, visit the Matrix page to assign site functionality to your roles.</Typography>\r\n            </Grid>\r\n            <Grid item xs={12}>\r\n              <SelectLookup\r\n                multiple\r\n                helperText={!roleSuggestions.length ? 'Ex: Consultant, Project Manager, Advisor, Business Analyst' : roleSuggestionLinks}\r\n                lookupName='Group Role'\r\n                lookups={roleValues}\r\n                lookupChange={setRoleIds}\r\n                lookupValue={roleIds}\r\n                invalidValues={['admin']}\r\n                refetchAction={getUserProfileDetails}\r\n                createAction={postRole}\r\n                deleteAction={deleteRole}\r\n                deleteActionIdentifier='ids'\r\n                {...props}\r\n              />\r\n            </Grid>\r\n            {defaultRoleId && <Grid item xs={12}>\r\n              <TextField\r\n                select\r\n                id={`group-default-role-selection`}\r\n                fullWidth\r\n                helperText={'Set the group default role. When members join the group, this role will be assigned.'}\r\n                label={`Default Role`}\r\n                onChange={e => setDefaultRoleId(e.target.value)}\r\n                value={defaultRoleId}\r\n              >\r\n                {roleIds.map(roleId => <MenuItem key={`${roleId}_primary_role_select`} value={roleId}>{roleValues.find(role => role.id === roleId)?.name || ''}</MenuItem>)}\r\n              </TextField>\r\n            </Grid>}\r\n            <Grid item>\r\n              <Alert severity=\"info\">An Admin group is created automatically. Only create groups for your members.</Alert>\r\n            </Grid>\r\n          </Grid>}\r\n      </CardContent>\r\n      <CardActions>\r\n        <Grid container justifyContent=\"space-between\">\r\n          {1 === viewStep ? <Grid container justifyContent=\"space-between\">\r\n            <Button onClick={closeModal}>Cancel</Button>\r\n            <Button\r\n              disabled={group.purpose.length < 25 || !isValid || checkingName || badName}\r\n              onClick={handleContinue}\r\n            >\r\n              Continue\r\n            </Button>\r\n          </Grid> : <Grid container justifyContent=\"space-between\">\r\n            <Button onClick={() => { setViewStep(1); }}>Back</Button>\r\n            <Button onClick={handleSubmit}>Submit</Button>\r\n          </Grid>}        </Grid>\r\n      </CardActions>\r\n    </Card>\r\n  </>\r\n}\r\n\r\nexport default ManageGroupModal;"}
{"prompt":"Create a react component ManageGroups.tsx implementing application types IGroup, IUserProfile. Implement useState parts named [group, setGroup] that uses IGroup. As a reminder, the application types related to this task and their purposes: IGroupIUserProfile.","completion":"import React, { useEffect, useState, useMemo, Suspense } from 'react';\r\nimport dayjs from 'dayjs';\r\nimport { useNavigate } from 'react-router';\r\n\r\nimport IconButton from '@mui/material/IconButton';\r\nimport Typography from '@mui/material/Typography';\r\nimport Box from '@mui/material/Box';\r\nimport Dialog from '@mui/material/Dialog';\r\nimport Button from '@mui/material/Button';\r\nimport Tooltip from '@mui/material/Tooltip';\r\n\r\nimport ManageAccountsIcon from '@mui/icons-material/ManageAccounts';\r\nimport DomainAddIcon from '@mui/icons-material/DomainAdd';\r\nimport GroupAddIcon from '@mui/icons-material/GroupAdd';\r\nimport CreateIcon from '@mui/icons-material/Create';\r\nimport DeleteIcon from '@mui/icons-material/Delete';\r\nimport Logout from '@mui/icons-material/Logout';\r\n\r\nimport { IGroup, IUserProfile, SiteRoles } from 'awayto/core';\r\nimport { useAppSelector, useSecure, useGrid, sh, useUtil } from 'awayto/hooks';\r\n\r\nimport ManageGroupModal from './ManageGroupModal';\r\nimport JoinGroupModal from './JoinGroupModal';\r\n\r\nimport keycloak from '../../keycloak';\r\n\r\nexport function ManageGroups(props: IProps): JSX.Element {\r\n  const [deleteGroup] = sh.useDeleteGroupMutation();\r\n  const [leaveGroup] = sh.useLeaveGroupMutation();\r\n\r\n  const { openConfirm, setLoading } = useUtil();\r\n\r\n  const hasRole = useSecure();\r\n  const navigate = useNavigate();\r\n  const util = useAppSelector(state => state.util);\r\n\r\n  const [group, setGroup] = useState<IGroup>();\r\n  const [dialog, setDialog] = useState('');\r\n  const [selected, setSelected] = useState<string[]>([]);\r\n\r\n  const { data: profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const { groups } = profile || {};\r\n\r\n  const actions = useMemo(() => {\r\n    if (!groups) return [];\r\n    const { length } = selected;\r\n    const gr = groups[selected[0]];\r\n    const isOwner = gr?.createdSub === profile?.sub;\r\n    const acts = length == 1 ? [\r\n      gr && !isOwner && <Tooltip key={'leave_group'} title=\"Leave\">\r\n        <Button onClick={() => {\r\n          openConfirm({\r\n            isConfirming: true,\r\n            confirmEffect: 'Leave the group ' + gr.name + ' and refresh the session.',\r\n            confirmAction: () => {\r\n              leaveGroup({ code: gr.code }).unwrap().then(() => keycloak.clearToken()).catch(console.error);\r\n            }\r\n          });\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Leave</Typography>\r\n          <Logout sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>,\r\n      gr && isOwner && hasRole([SiteRoles.APP_GROUP_ADMIN]) && <Tooltip key={'view_group_details'} title=\"Details\">\r\n        <Button onClick={() => {\r\n          navigate(`/group/${gr.name}/manage/users`)\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Details</Typography>\r\n          <ManageAccountsIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>,\r\n      isOwner && <Tooltip key={'manage_group'} title=\"Edit\">\r\n        <Button onClick={() => {\r\n          setGroup(groups[selected[0]]);\r\n          setDialog('manage_group');\r\n          setSelected([]);\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\r\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ] : [];\r\n\r\n    return [\r\n      ...acts,\r\n      isOwner && <Tooltip key={'delete_group'} title=\"Delete\">\r\n        <Button onClick={() => {\r\n          openConfirm({\r\n            isConfirming: true,\r\n            confirmEffect: 'Delete the group ' + gr.name + ' and refresh the session.',\r\n            confirmAction: () => {\r\n              deleteGroup({ ids: selected.join(',') }).unwrap().then(() => keycloak.clearToken()).catch(console.error);\r\n            }\r\n          });\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\r\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ];\r\n  }, [selected, groups]);\r\n\r\n  const GroupsGrid = useGrid({\r\n    rows: Object.values(groups || {}),\r\n    columns: [\r\n      { flex: 1, headerName: 'Name', field: 'name' },\r\n      { flex: 1, headerName: 'Code', field: 'code' },\r\n      { flex: 1, headerName: 'Users', field: 'usersCount', renderCell: ({ row }) => row.usersCount || 0 },\r\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\r\n    ],\r\n    selected,\r\n    onSelected: p => setSelected(p as string[]),\r\n    toolbar: () => <>\r\n      <Typography variant=\"button\">Groups:</Typography>\r\n      <Tooltip key={'join_group'} title=\"Join\">\r\n        <Button key={'join_group_button'} onClick={() => {\r\n          setGroup(undefined);\r\n          setDialog('join_group');\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Join</Typography>\r\n          <DomainAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n      <Tooltip key={'create_group'} title=\"Create\">\r\n        <Button key={'create_group_button'} onClick={() => {\r\n          setGroup(undefined);\r\n          setDialog('create_group');\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\r\n          <GroupAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\r\n    </>\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (groups && Object.keys(groups).length === 1 && Object.keys(profile?.availableUserGroupRoles || {}).length && util.isLoading) {\r\n      setLoading({ isLoading: false, loadingMessage: '' });\r\n    }\r\n  }, [groups, profile?.availableUserGroupRoles, util.isLoading]);\r\n\r\n  return <>\r\n    <Dialog open={dialog === 'create_group'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <ManageGroupModal {...props} editGroup={group} closeModal={() => {\r\n          setDialog('');\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <Dialog open={dialog === 'join_group'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <JoinGroupModal {...props} editGroup={group} closeModal={() => {\r\n          setDialog('');\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <Dialog open={dialog === 'manage_group'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <ManageGroupModal {...props} editGroup={group} closeModal={() => {\r\n          setDialog('');\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <GroupsGrid />\r\n\r\n  </>\r\n}\r\n\r\nexport default ManageGroups;"}
{"prompt":"Create a react component Profile.tsx implementing application types IUserProfile. Implement useState parts named [profile, setProfile] that uses IUserProfile. As a reminder, the application types related to this task and their purposes: IUserProfile.","completion":"import React, { useState, useEffect } from 'react';\r\nimport { useDropzone } from 'react-dropzone';\r\n\r\nimport Grid from '@mui/material/Grid';\r\nimport Typography from '@mui/material/Typography';\r\nimport Avatar from '@mui/material/Avatar';\r\nimport CardActionArea from '@mui/material/CardActionArea';\r\nimport Button from '@mui/material/Button';\r\nimport TextField from '@mui/material/TextField';\r\nimport PersonIcon from '@mui/icons-material/Person';\r\n\r\nimport { IUserProfile, IPreviewFile } from 'awayto/core';\r\nimport { sh, useComponents, useFileStore, useStyles, useUtil } from 'awayto/hooks';\r\n\r\nexport function Profile(props: IProps): JSX.Element {\r\n  const classes = useStyles();\r\n\r\n  const { setSnack } = useUtil();\r\n  const [putUserProfile] = sh.usePutUserProfileMutation();\r\n\r\n  const fileStore = useFileStore();\r\n  const { PickTheme, ManageGroups } = useComponents();\r\n\r\n  const { data : user } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const [displayImage, setDisplayImage] = useState('');\r\n  const [file, setFile] = useState<IPreviewFile>();\r\n  const [profile, setProfile] = useState({\r\n    firstName: '',\r\n    lastName: '',\r\n    email: '',\r\n    image: ''\r\n  } as IUserProfile);\r\n\r\n  const { getRootProps, getInputProps } = useDropzone({\r\n    maxSize: 1000000,\r\n    maxFiles: 1,\r\n    accept: {\r\n      'image/*': []\r\n    },\r\n    onDrop: (acceptedFiles: File[]) => {\r\n      const acceptedFile = acceptedFiles.pop()\r\n      if (acceptedFile) {\r\n        setFile(acceptedFile);\r\n        setDisplayImage(URL.createObjectURL(acceptedFile));\r\n      }\r\n    }\r\n  });\r\n\r\n  useEffect(() => {\r\n    if (file?.preview) URL.revokeObjectURL(file.preview);\r\n  }, [file]);\r\n\r\n  useEffect(() => {\r\n    async function go() {\r\n      if (fileStore && profile.image) {\r\n        setDisplayImage(await fileStore.get(profile.image));\r\n      }\r\n    }\r\n    void go();\r\n  }, [fileStore, profile.image]);\r\n\r\n  useEffect(() => {\r\n    if (user) {\r\n      setProfile({ ...profile, ...user });\r\n    }\r\n  }, [user]);\r\n\r\n  const deleteFile = () => {\r\n    setProfile({ ...profile, ...{ image: '' } });\r\n    setDisplayImage('');\r\n  }\r\n\r\n  const handleSubmit = async () => {\r\n    if (file) {\r\n      profile.image = await fileStore?.put(file);\r\n    }\r\n\r\n    putUserProfile(profile).unwrap().then(() => {\r\n      setSnack({ snackType: 'success', snackOn: 'Profile updated!' });\r\n      setFile(undefined);\r\n    }).catch(console.error);\r\n  }\r\n\r\n  return <>\r\n    <Grid container spacing={6}>\r\n      <Grid item sm={12} md={4}>\r\n        <Grid container direction=\"column\" spacing={2}>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Profile</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <TextField fullWidth id=\"firstName\" label=\"First Name\" autoComplete=\"on\" value={profile.firstName} name=\"firstName\" onChange={e => setProfile({ ...profile, firstName: e.target.value })} />\r\n          </Grid>\r\n          <Grid item>\r\n            <TextField fullWidth id=\"lastName\" label=\"Last Name\" autoComplete=\"on\" value={profile.lastName} name=\"lastName\" onChange={e => setProfile({ ...profile, lastName: e.target.value })} />\r\n          </Grid>\r\n          <Grid item>\r\n            <TextField fullWidth id=\"email\" label=\"Email\" autoComplete=\"on\" value={profile.email} name=\"email\" onChange={e => setProfile({ ...profile, email: e.target.value })} />\r\n          </Grid>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Image</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <CardActionArea style={{ padding: '12px' }}>\r\n              {!displayImage ?\r\n                <Grid {...getRootProps()} container alignItems=\"center\" direction=\"column\">\r\n                  <input {...getInputProps()} />\r\n                  <Grid item>\r\n                    <Avatar>\r\n                      <PersonIcon />\r\n                    </Avatar>\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"subtitle1\">Click or drag and drop to add a profile pic.</Typography>\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"caption\">Max size: 1MB</Typography>\r\n                  </Grid>\r\n                </Grid> :\r\n                <Grid onClick={deleteFile} container alignItems=\"center\" direction=\"column\">\r\n                  <Grid item>\r\n                    <Avatar src={displayImage} /> {/*<AsyncAvatar image={profile.image || ''} {...props} /> */}\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"h6\" style={{ wordBreak: 'break-all' }}>{user?.image ? \"Current profile image.\" : file ? `${file.name || ''} added.` : ''}</Typography>\r\n                  </Grid>\r\n                  <Grid item>\r\n                    <Typography variant=\"subtitle1\">To remove, click here then submit.</Typography>\r\n                  </Grid>\r\n                </Grid>\r\n              }\r\n            </CardActionArea>\r\n          </Grid>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Settings</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <PickTheme {...props} />\r\n          </Grid>\r\n        </Grid>\r\n      </Grid>\r\n      <Grid item sm={12} md={8}>\r\n        <Grid container direction=\"column\" spacing={2}>\r\n          <Grid item>\r\n            <Typography variant=\"h6\">Group</Typography>\r\n          </Grid>\r\n          <Grid item>\r\n            <ManageGroups {...props} />\r\n          </Grid>\r\n        </Grid>\r\n      </Grid>\r\n      <Grid item xs={12}>\r\n        <Button className={classes.red} onClick={handleSubmit}>Submit</Button>\r\n      </Grid>\r\n    </Grid>\r\n  </>\r\n}\r\n\r\nexport default Profile;"}
{"prompt":"Create a react component PendingQuotesContext.tsx implementing application types IQuote. Create enum PendingQuotesContextType that uses IQuote as a member value or type. As a reminder, the application types related to this task and their purposes: IQuote.","completion":"import { IQuote } from 'awayto/core';\nimport { createContext } from 'react';\n\nexport type PendingQuotesContextType = {\n  pendingQuotes: IQuote[];\n  pendingQuotesChanged: boolean;\n  selectedPendingQuotes: string[];\n  setSelectedPendingQuotes: (quotes: string[]) => void;\n  handleSelectPendingQuote: (prop: string) => void;\n  handleSelectPendingQuoteAll: () => void;\n  approvePendingQuotes: () => void | Promise<void>;\n  denyPendingQuotes: () => void | Promise<void>;\n}\n\nexport const PendingQuotesContext = createContext<PendingQuotesContextType | null>(null);"}
{"prompt":"Create a react component PendingQuotesProvider.tsx implementing application types IBooking. Create a constant variable named newBookings that uses IBooking. As a reminder, the application types related to this task and their purposes: IBooking.","completion":"import { useMemo, useState } from 'react';\n\nimport { plural, shortNSweet, IBooking } from 'awayto/core';\nimport { sh, useUtil } from 'awayto/hooks';\n\nimport { PendingQuotesContext, PendingQuotesContextType } from './PendingQuotesContext';\n\nexport function PendingQuotesProvider ({ children }: IProps): JSX.Element {\n\n  const { setSnack, openConfirm } = useUtil();\n  const [disableQuote] = sh.useDisableQuoteMutation();\n  const [postBooking] = sh.usePostBookingMutation();\n\n  const [pendingQuotesChanged, setPendingQuotesChanged] = useState(false);\n  const [selectedPendingQuotes, setSelectedPendingQuotes] = useState<string[]>([]);\n\n  const { data : profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\n\n  const pendingQuotes = useMemo(() => Object.values(profile?.quotes || {}), [profile]);\n\n  const pendingQuotesContext = {\n    pendingQuotes,\n    pendingQuotesChanged,\n    selectedPendingQuotes,\n    setSelectedPendingQuotes,\n    handleSelectPendingQuote(quote) {\n      const currentIndex = selectedPendingQuotes.indexOf(quote);\n      const newChecked = [...selectedPendingQuotes];\n\n      if (currentIndex === -1) {\n        newChecked.push(quote);\n      } else {\n        newChecked.splice(currentIndex, 1);\n      }\n\n      setSelectedPendingQuotes(newChecked);\n    },\n    handleSelectPendingQuoteAll() {\n      const pendingQuotesSet = selectedPendingQuotes.length === pendingQuotes.length ?\n        selectedPendingQuotes.filter(v => !pendingQuotes.map(pq => pq.id).includes(v)) :\n        [...selectedPendingQuotes, ...pendingQuotes.filter(v => !selectedPendingQuotes.includes(v.id)).map(pq => pq.id)];\n      \n      setSelectedPendingQuotes(pendingQuotesSet);\n    },\n    approvePendingQuotes() {\n      const selectedValues = pendingQuotes.filter(pq => selectedPendingQuotes.includes(pq.id));\n      if (!selectedValues.every(s => s.slotDate === selectedValues[0].slotDate && s.scheduleBracketSlotId === selectedValues[0].scheduleBracketSlotId)) {\n        setSnack({ snackType: 'error', snackOn: 'Only appointments of the same date and time can be mass approved.' });\n        return;\n      }\n\n      const { slotDate, startTime, scheduleBracketSlotId } = selectedValues[0];\n\n      const copies = pendingQuotes.filter(q => !selectedValues.some(s => s.id === q.id)).filter(q => q.slotDate === slotDate && q.scheduleBracketSlotId === scheduleBracketSlotId);\n\n      openConfirm({\n        isConfirming: true,\n        confirmEffect: `Approve ${plural(selectedValues.length, 'request', 'requests')}, creating ${plural(selectedValues.length, 'booking', 'bookings')}, for ${shortNSweet(slotDate, startTime)}.`,\n        confirmSideEffect: !copies.length ? undefined : {\n          approvalAction: 'Auto-Deny Remaining',\n          approvalEffect: `Automatically deny all other requests for ${shortNSweet(slotDate, startTime)} (this cannot be undone).`,\n          rejectionAction: 'Confirm Quote/Booking Only',\n          rejectionEffect: 'Just submit the approvals.',\n        },\n        confirmAction: approval => {\n          const newBookings = selectedValues.map(s => ({\n            quoteId: s.id,\n            slotDate: s.slotDate,\n            scheduleBracketSlotId: s.scheduleBracketSlotId\n          }) as IBooking);\n\n          postBooking({ bookings: newBookings }).unwrap().then(() => {\n            const disableQuoteIds = selectedValues.concat(approval ? copies : []).map(s => s.id).join(',');\n            \n            disableQuote({ ids: disableQuoteIds }).unwrap().then(() => {\n              setSelectedPendingQuotes([]);\n              setPendingQuotesChanged(!pendingQuotesChanged);\n              void getUserProfileDetails();\n            }).catch(console.error);\n          }).catch(console.error);\n        }\n      });\n    },\n    denyPendingQuotes() {\n      disableQuote({ ids: selectedPendingQuotes.join(',') }).unwrap().then(() => {\n        setSelectedPendingQuotes([]);\n        setPendingQuotesChanged(!pendingQuotesChanged);\n        void getUserProfileDetails();\n      }).catch(console.error);\n    }\n  } as PendingQuotesContextType | null;\n\n  return <PendingQuotesContext.Provider value={pendingQuotesContext}>\n    {children}\n  </PendingQuotesContext.Provider>;\n}\n\nexport default PendingQuotesProvider;"}
{"prompt":"Create a react component QuoteHome.tsx implementing application types IQuote. Create a constant variable named QuoteGrid that uses IQuote. As a reminder, the application types related to this task and their purposes: IQuote.","completion":"import React, { useMemo, useContext } from 'react';\n\nimport Box from '@mui/material/Box';\nimport Typography from '@mui/material/Typography';\nimport IconButton from '@mui/material/IconButton';\nimport Tooltip from '@mui/material/Tooltip';\n\nimport ApprovalIcon from '@mui/icons-material/Approval';\nimport DoNotDisturbIcon from '@mui/icons-material/DoNotDisturb';\n\nimport { IQuote, utcDTLocal, shortNSweet } from 'awayto/core';\nimport { useGrid } from 'awayto/hooks';\nimport { PendingQuotesContext, PendingQuotesContextType } from './PendingQuotesContext';\n\nfunction QuoteHome(): JSX.Element {\n\n  const {\n    pendingQuotes,\n    selectedPendingQuotes,\n    setSelectedPendingQuotes,\n    approvePendingQuotes,\n    denyPendingQuotes\n  } = useContext(PendingQuotesContext) as PendingQuotesContextType;\n\n  const actions = useMemo(() => {\n    const { length } = selectedPendingQuotes;\n    const acts = length == 1 ? [\n      // Extra actions\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'approve_quote'} title=\"Approve\">\n        <IconButton onClick={approvePendingQuotes}>\n          <ApprovalIcon />\n        </IconButton>\n      </Tooltip>,\n      <Tooltip key={'deny_quote'} title=\"Deny\">\n        <IconButton onClick={denyPendingQuotes}>\n          <DoNotDisturbIcon />\n        </IconButton>\n      </Tooltip>\n    ]\n  }, [selectedPendingQuotes]);\n\n  const QuoteGrid = useGrid<IQuote>({\n    rows: pendingQuotes,\n    columns: [\n      { flex: 1, headerName: 'Booking Slot', field: 'slotDate', renderCell: ({ row }) => shortNSweet(row.slotDate, row.startTime) },\n      { flex: 1, headerName: 'Service', field: 'serviceName' },\n      { flex: 1, headerName: 'Tier', field: 'serviceTierName' },\n      { flex: 1, headerName: 'Requested On', field: 'createdOn', renderCell: ({ row }) => utcDTLocal(row.createdOn) }\n    ],\n    selected: selectedPendingQuotes,\n    onSelected: selection => setSelectedPendingQuotes(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Pending Requests</Typography>\n      {!!selectedPendingQuotes.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  });\n  return <QuoteGrid />\n}\n\nexport default QuoteHome;"}
{"prompt":"Create a react component RequestQuote.tsx implementing application types IForm, IGroupScheduleDateSlots, IGroup, IQuote, ISchedule, IServiceTier, IService, ITimeUnitNames. Implement useState parts named [serviceForm, setServiceForm] that uses IForm. Implement useState parts named [tierForm, setTierForm] that uses IForm. Implement useState parts named [firstAvailable, setFirstAvailable] that uses IGroupScheduleDateSlots. Implement useState parts named [group, setGroup] that uses IGroup. Implement useState parts named [quote, setQuote] that uses IQuote. Implement useState parts named [schedule, setSchedule] that uses ISchedule. Implement useState parts named [tier, setTier] that uses IServiceTier. Create react component named RequestQuote implementing IServiceTier as a parameter or return type. Implement useState parts named [services, setServices] that uses IService. Implement useState parts named [service, setService] that uses IService. Create a constant variable named newServices that uses IService. Create a constant variable named loadSchedule that uses ITimeUnitNames. As a reminder, the application types related to this task and their purposes: IFormIGroupScheduleDateSlotsIGroupIQuoteIScheduleIServiceTierIServiceITimeUnitNames.","completion":"import React, { useEffect, useState, useMemo, useCallback } from 'react';\nimport { GridColDef } from '@mui/x-data-grid';\nimport { useNavigate } from 'react-router';\nimport dayjs from 'dayjs';\n\nimport Accordion from '@mui/material/Accordion';\nimport AccordionSummary from '@mui/material/AccordionSummary';\nimport AccordionDetails from '@mui/material/AccordionDetails';\nimport Avatar from '@mui/material/Avatar';\nimport Grid from '@mui/material/Grid';\nimport Typography from '@mui/material/Typography';\nimport Box from '@mui/material/Box';\nimport Card from '@mui/material/Card';\nimport CardHeader from '@mui/material/CardHeader';\nimport CardContent from '@mui/material/CardContent';\nimport CardActionArea from '@mui/material/CardActionArea';\nimport TextField from '@mui/material/TextField';\nimport MenuItem from '@mui/material/MenuItem';\n\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport CheckIcon from '@mui/icons-material/Check';\n\nimport { ISchedule, IService, IServiceTier, IForm, IGroup, IQuote, ITimeUnitNames, TimeUnit, timeUnitOrder, IGroupScheduleDateSlots, quotedDT } from 'awayto/core';\nimport { useComponents, useStyles, useGrid, sh, useUtil } from 'awayto/hooks';\n\nexport function RequestQuote(props: IProps): JSX.Element {\n  const classes = useStyles();\n\n  const { setSnack } = useUtil();\n  const [getGroupFormById] = sh.useLazyGetGroupFormByIdQuery();\n  const [postQuote] = sh.usePostQuoteMutation();\n  const [getGroupSchedules, { data: groupSchedules }] = sh.useLazyGetGroupSchedulesQuery();\n  const [getGroupScheduleMasterById] = sh.useLazyGetGroupScheduleMasterByIdQuery();\n  const [getGroupUserSchedules, { data: groupUserSchedules }] = sh.useLazyGetGroupUserSchedulesQuery();\n\n  const navigate = useNavigate();\n  const { FileManager, FormDisplay, ScheduleDatePicker, ScheduleTimePicker } = useComponents();\n\n  const [_, { data: dateSlots }] = sh.useLazyGetGroupScheduleByDateQuery();\n\n  const { data: lookups } = sh.useGetLookupsQuery();\n\n  const { data: profile } = sh.useGetUserProfileDetailsQuery();\n\n  const [services, setServices] = useState({} as Record<string, IService>);\n  const [schedule, setSchedule] = useState({ id: '' } as ISchedule);\n  const [service, setService] = useState({ id: '', tiers: {} } as IService);\n  const [tier, setTier] = useState({ id: '' } as IServiceTier);\n  const [serviceForm, setServiceForm] = useState({} as IForm);\n  const [tierForm, setTierForm] = useState({} as IForm);\n  const [group, setGroup] = useState({ id: '' } as IGroup);\n  const [quote, setQuote] = useState({} as IQuote);\n  \n  const [bracketSlotDate, setBracketSlotDate] = useState<dayjs.Dayjs | null>();\n  const [bracketSlotTime, setBracketSlotTime] = useState<dayjs.Dayjs | null>();\n  \n  const [activeSchedule, setActiveSchedule] = useState('');\n  const [firstAvailable, setFirstAvailable] = useState({ time: dayjs().startOf('day') } as IGroupScheduleDateSlots);\n\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\n  const servicesValues = useMemo(() => Object.values(services || {}), [services]);\n\n  const loadSchedule = useCallback((sched: ISchedule) => {\n    sched.scheduleTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.scheduleTimeUnitId)?.name as ITimeUnitNames;\n    sched.bracketTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.bracketTimeUnitId)?.name as ITimeUnitNames;\n    sched.slotTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.slotTimeUnitId)?.name as ITimeUnitNames;    \n    setSchedule(sched);\n  }, [lookups]);\n\n  if (groupsValues.length && !group.id) {\n    setGroup(groupsValues[0]);\n  }\n\n  if (schedule.id && activeSchedule !== schedule.id && dateSlots?.length && !firstAvailable.scheduleBracketSlotId) {\n    const [slot] = dateSlots;\n    setFirstAvailable({ ...slot, time: quotedDT(slot.weekStart, slot.startTime) });\n    setActiveSchedule(schedule.id);\n  }\n\n  const serviceTiers = useMemo(() => Object.values(service.tiers || {}).sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime()), [service.tiers]);\n\n  if (serviceTiers.length && (!tier.id || !serviceTiers.map(t => t.id).includes(tier.id))) {\n    setTier(serviceTiers[0]);\n  }\n\n  if (groupSchedules?.length && !schedule.id) {\n    loadSchedule(groupSchedules[0]);\n  }\n\n  const serviceTierAddons = useMemo(() => {\n    return serviceTiers\n      .sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime())\n      .reduce<string[]>((memo, { addons }) => {\n        const serviceAddons = Object.values(addons);\n        if (serviceAddons) {\n          for (let i = 0, v = serviceAddons.length; i < v; i++) {\n            const { name } = serviceAddons[i];\n            if (memo.indexOf(name) < 0) memo.push(name);\n          }\n        }\n        return memo;\n      }, []);\n  }, [serviceTiers]);\n\n  const TierGrid = useGrid({\n    rows: serviceTierAddons.map(name => ({ name })),\n    columns: [\n      { type: 'string', field: 'name', headerName: '' },\n      ...serviceTiers.reduce((memo, { name, addons }) => {\n        memo.push({\n          headerName: name,\n          field: '',\n          renderCell: ({ row }) => {\n            return Object.values(addons).map(ad => ad.name).indexOf(row.name) > -1 ? <Avatar sx={{ width: 24, height: 24, backgroundColor: 'white' }}><CheckIcon className={classes.green} /></Avatar> : '--';\n          }\n        });\n        return memo;\n      }, [] as GridColDef<{ name: string }>[])\n    ]\n  });\n\n  useEffect(() => {\n    async function go() {\n      const [firstGroupSchedule] = await getGroupSchedules({ groupName: group.name }).unwrap();\n      if (firstGroupSchedule) {\n        const masterSchedule = await getGroupScheduleMasterById({ groupName: group.name, scheduleId: firstGroupSchedule.id }).unwrap();\n        loadSchedule(masterSchedule);\n      }\n    }\n    if (group.name) {\n      void go();\n    }\n  }, [group]);\n\n  useEffect(() => {\n    if (group.name && schedule.id) {\n      getGroupUserSchedules({ groupName: group.name, groupScheduleId: schedule.id }).catch(console.error);\n    }\n  }, [group, schedule]);\n\n  useEffect(() => {\n    if (groupUserSchedules?.length && (!tier.id && !Object.keys(services).length && !service.id)) {\n      let newServices = {} as Record<string, IService>;\n\n      for (const sched of groupUserSchedules) {\n        newServices = { ...newServices, ...sched.services };\n      }\n\n      setServices(newServices);\n  \n      const someService = Object.values(newServices)[0] || {};\n      setService(someService);\n\n      setTier(Object.values(someService.tiers).sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime())[0]);\n    }\n  }, [groupUserSchedules, tier, services, service]);\n\n  useEffect(() => {\n    if (group.name && service.formId && service.formId != serviceForm.id) {\n      getGroupFormById({ groupName: group.name, formId: service.formId }).unwrap().then(groupServiceForm => {\n        setServiceForm(groupServiceForm);\n      }).catch(console.error);\n    }\n  }, [service, serviceForm, group]);\n\n  useEffect(() => {\n    if (group.name && tier.formId && tier.formId != tierForm.id) {\n      getGroupFormById({ groupName: group.name, formId: tier.formId }).unwrap().then(groupTierForm => {\n        setTierForm(groupTierForm);\n      }).catch(console.error);\n    }\n  }, [tier, tierForm, group]);\n\n  return <>\n    <Grid container spacing={2}>\n\n      <Grid item xs={12}>\n        <Card>\n          <CardHeader\n            title=\"Create Request\"\n            subheader=\"Request services from a group. Some fields may be required depending on the service.\"\n            action={\n              <TextField\n                select\n                value={group.id}\n                label=\"Group\"\n                onChange={e => setGroup(groupsValues.filter(g => g.id === e.target.value)[0])}\n              >\n                {groupsValues.map(group => <MenuItem key={`group-select${group.id}`} value={group.id}>{group.name}</MenuItem>)}\n              </TextField>\n            }\n          />\n          <CardContent>\n\n            <Grid container spacing={2}>\n              <Grid item xs={4}>\n                <TextField\n                  select\n                  label=\"Schedules\"\n                  fullWidth\n                  value={schedule.id}\n                  onChange={e => {\n                    if (e.target.value !== schedule.id) {\n                      const sched = groupSchedules?.find(gs => gs.id === e.target.value);\n                      if (sched) {\n                        loadSchedule(sched);\n                      }\n                    }\n                  }}\n                >\n                  {groupSchedules?.map((sched, i) => <MenuItem key={i} value={sched.id}>{sched.name}</MenuItem>)}\n                </TextField>\n              </Grid>\n              <Grid item xs={4}>\n                <TextField\n                  select\n                  label=\"Service\"\n                  fullWidth\n                  value={service.id}\n                  onChange={e => {\n                    const serv = services[e.target.value];\n                    if (serv) {\n                      setService(serv);\n                    }\n                  }}\n                >\n                  {servicesValues.map((service, i) => <MenuItem key={`service_request_selection_${i}`} value={service.id}>{service.name}</MenuItem>)}\n                </TextField>\n              </Grid>\n              <Grid item xs={4}>\n                <TextField\n                  select\n                  label=\"Level\"\n                  fullWidth\n                  value={tier.id}\n                  onChange={e => {\n                    setTier(serviceTiers.find(t => t.id === e.target.value) as IServiceTier);\n                  }}\n                >\n                  {serviceTiers.sort((a, b) => new Date(b.createdOn).getTime() - new Date(a.createdOn).getTime()).map((tier, i) => {\n                    return <MenuItem key={i} value={tier.id}>{tier.name}</MenuItem>\n                  })}\n                </TextField>\n              </Grid>\n            </Grid>\n\n          </CardContent>\n        </Card>\n\n        <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"tiers-and-features-content\"\n            id=\"tiers-and-features-header\"\n          >\n            <Typography>Features</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <TierGrid />\n          </AccordionDetails>\n        </Accordion>\n\n        {serviceForm.version && <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"service-request-section-service-questionnaire-content\"\n            id=\"service-request-section-service-questionnaire-header\"\n          >\n            <Typography>{service.name} Questionnaire</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <FormDisplay form={serviceForm} setForm={setServiceForm} />\n          </AccordionDetails>\n        </Accordion>}\n\n        {tierForm.version && <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"service-request-section-tier-questionnaire-content\"\n            id=\"service-request-section-tier-questionnaire-header\"\n          >\n            <Typography>{tier.name} Questionnaire</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <FormDisplay form={tierForm} setForm={setTierForm} />\n          </AccordionDetails>\n        </Accordion>}\n\n        <Accordion defaultExpanded={true}>\n          <AccordionSummary\n            expandIcon={<ExpandMoreIcon />}\n            aria-controls=\"service-request-section-time-selection-content\"\n            id=\"service-request-section-time-selection-header\"\n          >\n            <Typography>Schedule</Typography>\n          </AccordionSummary>\n          <AccordionDetails>\n            <Grid container spacing={2}>\n              <Grid item xs={4}>\n                <ScheduleDatePicker\n                  key={schedule.id}\n                  scheduleId={schedule.id}\n                  groupName={group.name}\n                  firstAvailable={firstAvailable}\n                  value={bracketSlotDate || firstAvailable.time || null}\n                  onDateChange={(date: dayjs.Dayjs | null) => setBracketSlotDate(date ? date.isBefore(firstAvailable.time) ? firstAvailable.time : date  : null)}\n                />\n              </Grid>\n              {timeUnitOrder.indexOf(schedule.slotTimeUnitName) <= timeUnitOrder.indexOf(TimeUnit.HOUR) && <Grid item xs={4}>\n                <ScheduleTimePicker\n                  key={schedule.id}\n                  firstAvailable={firstAvailable}\n                  bracketSlotDate={bracketSlotDate}\n                  bracketTimeUnitName={schedule.bracketTimeUnitName}\n                  slotTimeUnitName={schedule.slotTimeUnitName}\n                  value={bracketSlotTime || firstAvailable.time}\n                  onTimeChange={({ time, quote: newQuote }: { time: dayjs.Dayjs | null, quote?: IQuote }) => {\n                    setBracketSlotTime(time);\n                    if (newQuote) {\n                      setQuote({\n                        ...quote,\n                        ...newQuote\n                      })\n                    }\n                  }}\n                  onTimeAccept={(newQuote: IQuote) => {\n                    setQuote({\n                      ...quote,\n                      ...newQuote\n                    })\n                  }}\n                />\n              </Grid>}\n\n              {/*\n              TODO LATER SHOULD ONLY SHOW USER SELECTION BASED ON AUTO/ROUND-ROBIN/DIRECT-SELECT\n              {quote.scheduleBracketSlotId && <Grid item xs={4}>\n                <TextField\n                  select\n                  fullWidth\n                  label=\"User\"\n                  value={quote.scheduleBracketSlotId}\n                  onChange={e => {\n                    setQuote({ ...quote, scheduleBracketSlotId: e.target.value })\n                  }}\n                >\n                  {bracketsValues\n                    .filter(bv => Object.values(bv.slots).findIndex(s => s.startTime === quote.slotTime) === -1)\n                    .map((bv, i) => {\n                      const { name } = Object.values(groupUserSchedules).find(gus => gus.userScheduleId === bv.scheduleId) || {};\n                      return <MenuItem key={`schedule-slot-selection-${i}`} value={bv.id}>{name}</MenuItem>\n                    })}\n                </TextField>\n              </Grid>} */}\n            </Grid>\n          </AccordionDetails>\n        </Accordion>\n\n        <FileManager {...props} />\n      </Grid>\n\n      <Grid item xs={12}>\n        <Card>\n          <CardActionArea onClick={async () => {\n            quote.serviceTierId = tier.id;\n\n            if (!quote.scheduleBracketSlotId) {\n              const { scheduleBracketSlotId, startDate } = firstAvailable;\n              quote.scheduleBracketSlotId = scheduleBracketSlotId;\n              quote.slotDate = startDate;\n            }\n\n            if (Object.keys(serviceForm).length) {\n              const missingValues = Object.keys(serviceForm.version.form).some(rowId => serviceForm.version.form[rowId].some((field, i) => field.r && [undefined, ''].includes(serviceForm.version.submission[rowId][i])));\n              if (missingValues) {\n                setSnack({ snackType: 'error', snackOn: 'The Service Questionnaire is missing required fields!' });\n                return;\n              }\n              quote.serviceForm = {\n                formVersionId: serviceForm.version.id,\n                submission: serviceForm.version.submission\n              }\n            }\n\n            if (Object.keys(tierForm).length) {\n              const missingValues = Object.keys(tierForm.version.form).some(rowId => tierForm.version.form[rowId].some((field, i) => field.r && [undefined, ''].includes(tierForm.version.submission[rowId][i])));\n              if (missingValues) {\n                setSnack({ snackType: 'error', snackOn: 'The Tier Questionnaire is missing required fields!' });\n                return;\n              }\n              quote.tierForm = {\n                formVersionId: tierForm.version.id,\n                submission: tierForm.version.submission\n              }\n            }\n\n            await postQuote(quote).unwrap();\n            setSnack({ snackOn: 'Your request has been made successfully!' });\n            navigate('/');\n            \n          }}>\n            <Box m={2} sx={{ display: 'flex' }}>\n              <Typography color=\"secondary\" variant=\"button\">Submit Request</Typography>\n            </Box>\n          </CardActionArea>\n        </Card>\n      </Grid>\n\n    </Grid>\n  </>\n\n}\n\nexport default RequestQuote;"}
{"prompt":"Create a react component ManageRoleActions.tsx implementing application types IGroupRoleAuthActions. As a reminder, the application types related to this task and their purposes: IGroupRoleAuthActions.","completion":"import React, { useCallback, useMemo, useState } from 'react';\r\n\r\nimport Card from '@mui/material/Card';\r\nimport Box from '@mui/material/Box';\r\nimport Typography from '@mui/material/Typography';\r\nimport Grid from '@mui/material/Grid';\r\nimport CardActionArea from '@mui/material/CardActionArea';\r\nimport Checkbox from '@mui/material/Checkbox';\r\n\r\nimport { GridColDef } from '@mui/x-data-grid';\r\n\r\nimport { SiteRoles, IGroupRoleAuthActions } from 'awayto/core';\r\nimport { useGrid, useAppSelector, sh, useUtil } from 'awayto/hooks';\r\nimport { useParams } from 'react-router';\r\n\r\nexport function ManageRoleActions(): JSX.Element {\r\n  const { groupName } = useParams();\r\n  if (!groupName) return <></>;\r\n\r\n  const { setSnack, setUpdateAssignments } = useUtil();\r\n  const [putAssignments] = sh.usePutGroupAssignmentsMutation();\r\n\r\n  const { data: availableGroupAssignments } = sh.useGetGroupAssignmentsQuery({ groupName })\r\n\r\n  const { data: profile } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const { canSubmitAssignments } = useAppSelector(state => state.util);\r\n  \r\n  const [assignments, setAssignments] = useState(availableGroupAssignments || {});\r\n\r\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\r\n\r\n  const handleCheck = useCallback((subgroup: string, action: string, add: boolean) => {\r\n    const newAssignments = { ...assignments };\r\n    newAssignments[subgroup] = { actions: add ? [...(newAssignments[subgroup]?.actions || []), { name: action }] : newAssignments[subgroup]?.actions.filter(a => a.name !== action) };\r\n    setAssignments(newAssignments);\r\n  }, [assignments]);\r\n\r\n  const handleSubmit = useCallback(() => {\r\n    try {\r\n      setUpdateAssignments({ canSubmitAssignments: false });\r\n      putAssignments({ groupName, assignments }).unwrap().then(() => {\r\n        setSnack({ snackType: 'success', snackOn: 'Assignments can be updated again in 1 minute.' });\r\n        setTimeout(() => setUpdateAssignments({ canSubmitAssignments: true }), 58 * 1000);\r\n      }).catch(console.error);\r\n    } catch (error) {\r\n      setUpdateAssignments({ canSubmitAssignments: true });\r\n    }\r\n  }, [groupName, assignments]);\r\n\r\n  const columns = useMemo(() => {\r\n    if (groupsValues.length && groupName) {\r\n      const group = groupsValues.find(g => g.name === groupName);\r\n      if (group && Object.keys(group.roles).length) {\r\n\r\n        const cols: GridColDef<{ name: string }>[] = [{ width: 200, field: 'id', headerName: '', renderCell: ({ row }) => row.name } as GridColDef<{ name: string }>];\r\n        \r\n        for (const roleId in group.roles) {\r\n          const { name } = group.roles[roleId];\r\n          const subgroup = `/${groupName}/${name}`;\r\n          cols.push({\r\n            flex: 1,\r\n            minWidth: 75,\r\n            headerName: name,\r\n            field: name,\r\n            renderCell: ({ row }) => <Checkbox\r\n              checked={assignments[subgroup] ? assignments[subgroup].actions.some(a => a.name === row.name) : false}\r\n              onChange={e => handleCheck(subgroup, row.name, e.target.checked)}\r\n            />\r\n          });\r\n        }\r\n        \r\n        return cols;\r\n      }\r\n    }\r\n    return [];\r\n  }, [groupsValues, assignments, groupName]);\r\n\r\n  const options = useMemo(() => Object.values(SiteRoles).filter(r => ![SiteRoles.APP_ROLE_CALL, SiteRoles.APP_GROUP_ADMIN].includes(r)).map((name, id) => ({ id, name })), []);\r\n\r\n  const RoleActionGrid = useGrid({\r\n    rows: options,\r\n    columns,\r\n    noPagination: true\r\n  });\r\n\r\n  return <>\r\n\r\n    <Grid container>\r\n      <Grid item mb={2} xs={12}>\r\n        <Card>\r\n          <CardActionArea disabled={!canSubmitAssignments} onClick={handleSubmit}>\r\n            <Grid container direction=\"row\" justifyContent=\"space-between\">\r\n              <Grid item>\r\n                <Box m={2}>\r\n                  <Typography color=\"secondary\" variant=\"button\">Update Assignments </Typography>\r\n                </Box>\r\n              </Grid>\r\n              <Grid item>\r\n                <Box m={2}>\r\n                  <Typography color=\"GrayText\" variant=\"button\">Changes will persist within 1 minute</Typography>\r\n                </Box>\r\n              </Grid>\r\n            </Grid>\r\n          </CardActionArea>\r\n        </Card>\r\n      </Grid>\r\n    </Grid>\r\n\r\n    <RoleActionGrid />\r\n\r\n  </>\r\n}\r\n\r\nexport default ManageRoleActions;"}
{"prompt":"Create a react component ManageRoleModal.tsx implementing application types IRole. Create interface IProps implementing IRole as a property type, method parameter or return type. Implement useState parts named [role, setRole] that uses IRole. Create a constant variable named handleSubmit that uses IRole. As a reminder, the application types related to this task and their purposes: IRole.","completion":"import React, { useState } from \"react\";\r\n\r\nimport Grid from '@mui/material/Grid';\r\nimport Typography from '@mui/material/Typography';\r\nimport Card from '@mui/material/Card';\r\nimport CardContent from '@mui/material/CardContent';\r\nimport CardActions from '@mui/material/CardActions';\r\nimport Button from '@mui/material/Button';\r\nimport TextField from '@mui/material/TextField';\r\n\r\nimport { IRole } from 'awayto/core';\r\nimport { useUtil, sh } from 'awayto/hooks';\r\nimport { useCallback } from 'react';\r\n\r\ndeclare global {\r\n  interface IProps {\r\n    editRole?: IRole;\r\n  }\r\n}\r\n\r\nexport function ManageRoleModal ({ editRole, closeModal }: IProps): JSX.Element {\r\n\r\n  const { setSnack } = useUtil();\r\n  const [putRole] = sh.usePutRoleMutation();\r\n  const [postRole] = sh.usePostRoleMutation();\r\n\r\n  const [role, setRole] = useState<Partial<IRole>>({\r\n    name: '',\r\n    ...editRole\r\n  });\r\n  \r\n  const handleSubmit = useCallback(() => {\r\n    const { id, name } = role;\r\n\r\n    if (!name) {\r\n      setSnack({snackType: 'error', snackOn: 'Roles must have a name.' });\r\n      return;\r\n    }\r\n\r\n    (id ? putRole : postRole)(role as IRole).unwrap().then(() => {\r\n      if (closeModal)\r\n        closeModal();\r\n    }).catch(console.error);\r\n  }, [role]);\r\n\r\n  return <>\r\n    <Card>\r\n      <CardContent>\r\n        <Typography variant=\"button\">Manage role</Typography>\r\n        <Grid container direction=\"row\" spacing={2}>\r\n          <Grid item xs={12}>\r\n            <Grid container direction=\"column\" spacing={4} justifyContent=\"space-evenly\" >\r\n              <Grid item>\r\n                <Typography variant=\"h6\">Role</Typography>\r\n              </Grid>\r\n              <Grid item>\r\n                <TextField\r\n                  fullWidth\r\n                  autoFocus\r\n                  id=\"name\"\r\n                  label=\"Name\"\r\n                  name=\"name\"\r\n                  value={role.name}\r\n                  onKeyDown={e => {\r\n                    if ('Enter' === e.key) {\r\n                      handleSubmit();\r\n                    }\r\n                  }}\r\n                  onChange={e => setRole({ ...role, name: e.target.value })} />\r\n              </Grid>\r\n            </Grid>\r\n          </Grid>\r\n        </Grid>\r\n      </CardContent>\r\n      <CardActions>\r\n        <Grid container justifyContent=\"space-between\">\r\n          <Button onClick={closeModal}>Cancel</Button>\r\n          <Button onClick={handleSubmit}>Submit</Button>\r\n        </Grid>\r\n      </CardActions>\r\n    </Card>\r\n  </>\r\n}\r\n\r\nexport default ManageRoleModal;"}
{"prompt":"Create a react component ManageRoles.tsx implementing application types IRole. Implement useState parts named [role, setRole] that uses IRole. As a reminder, the application types related to this task and their purposes: IRole.","completion":"import React, { useEffect, useState, useMemo, Suspense } from 'react';\r\nimport dayjs from 'dayjs';\r\n\r\nimport Box from '@mui/material/Box';\r\nimport Typography from '@mui/material/Typography';\r\nimport Button from '@mui/material/Button';\r\nimport Dialog from '@mui/material/Dialog';\r\nimport Tooltip from '@mui/material/Tooltip';\r\n\r\nimport CreateIcon from '@mui/icons-material/Create';\r\nimport GroupAddIcon from '@mui/icons-material/GroupAdd';\r\nimport DeleteIcon from '@mui/icons-material/Delete';\r\n\r\nimport { IRole } from 'awayto/core';\r\nimport { sh, useGrid } from 'awayto/hooks';\r\n\r\nimport ManageRoleModal from './ManageRoleModal';\r\n\r\nexport function ManageRoles(props: IProps): JSX.Element {\r\n\r\n  const { data: profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\r\n\r\n  const [deleteRole] = sh.useDeleteRoleMutation();\r\n\r\n  const [role, setRole] = useState<IRole>();\r\n  const [selected, setSelected] = useState<string[]>([]);\r\n  const [dialog, setDialog] = useState('');\r\n\r\n  const actions = useMemo(() => {\r\n    const { length } = selected;\r\n    const acts = length == 1 ? [\r\n      <Tooltip key={'manage_role'} title=\"Edit\">\r\n        <Button onClick={() => {\r\n          if (profile?.roles) {\r\n            setRole(profile?.roles[selected[0]]);\r\n            setDialog('manage_role');\r\n            setSelected([]);\r\n          }\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\r\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ] : [];\r\n\r\n    return [\r\n      ...acts,\r\n      <Tooltip key={'delete_role'} title=\"Delete\">\r\n        <Button onClick={async () => {\r\n          await deleteRole({ ids: selected.join(',') }).unwrap();\r\n          void getUserProfileDetails();\r\n          setSelected([]);\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\r\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n    ]\r\n  }, [selected]);\r\n\r\n  const RoleGrid = useGrid({\r\n    rows: Object.values(profile?.roles || {}),\r\n    columns: [\r\n      { flex: 1, headerName: 'Name', field: 'name' },\r\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\r\n    ],\r\n    selected,\r\n    onSelected: selection => setSelected(selection as string[]),\r\n    toolbar: () => <>\r\n      <Typography variant=\"button\">Roles:</Typography>\r\n      <Tooltip key={'manage_role'} title=\"Create\">\r\n        <Button onClick={() => {\r\n          setRole(undefined);\r\n          setDialog('manage_role')\r\n        }}>\r\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\r\n          <GroupAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\r\n        </Button>\r\n      </Tooltip>\r\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\r\n    </>\r\n  })\r\n\r\n  return <>\r\n    <Dialog open={dialog === 'manage_role'} fullWidth maxWidth=\"sm\">\r\n      <Suspense>\r\n        <ManageRoleModal {...props} editRole={role} closeModal={() => {\r\n          setDialog('')\r\n          void getUserProfileDetails();\r\n        }} />\r\n      </Suspense>\r\n    </Dialog>\r\n\r\n    <RoleGrid />\r\n  </>\r\n}\r\n\r\nexport default ManageRoles;"}
{"prompt":"Create a react component ManageScheduleBrackets.tsx implementing application types IGroup, ISchedule. Implement useState parts named [group, setGroup] that uses IGroup. Implement useState parts named [schedule, setSchedule] that uses ISchedule. As a reminder, the application types related to this task and their purposes: IGroupISchedule.","completion":"import React, { useState, useMemo, Suspense } from 'react';\nimport dayjs from 'dayjs';\n\nimport IconButton from '@mui/material/IconButton';\nimport Button from '@mui/material/Button';\nimport Dialog from '@mui/material/Dialog';\nimport Tooltip from '@mui/material/Tooltip';\nimport Typography from '@mui/material/Typography';\nimport Box from '@mui/material/Box';\nimport TextField from '@mui/material/TextField';\nimport MenuItem from '@mui/material/MenuItem';\n\nimport CreateIcon from '@mui/icons-material/Create';\nimport DeleteIcon from '@mui/icons-material/Delete';\n\nimport { ISchedule, IGroup, plural } from 'awayto/core';\nimport { useGrid, useUtil, sh } from 'awayto/hooks';\n\nimport ManageScheduleBracketsModal from './ManageScheduleBracketsModal';\n\n// This is how group users interact with the schedule\n\nexport function ManageScheduleBrackets(props: IProps): JSX.Element {\n\n  const { setSnack, openConfirm } = useUtil();\n\n  const [deleteGroupUserScheduleByUserScheduleId] = sh.useDeleteGroupUserScheduleByUserScheduleIdMutation();\n  const [deleteSchedule] = sh.useDeleteScheduleMutation()\n\n  const [schedule, setSchedule] = useState<ISchedule>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n  const [group, setGroup] = useState({ id: '' } as IGroup);\n\n  const { data: schedules } = sh.useGetSchedulesQuery();\n  const { data: profile, refetch: getUserProfileDetails } = sh.useGetUserProfileDetailsQuery();\n\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\n\n  if (groupsValues.length && !group.id) {\n    setGroup(groupsValues[0]);\n  }\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <IconButton key={'manage_schedule'} onClick={() => {\n        setSchedule(schedules?.find(s => s.id === selected[0]));\n        setDialog('manage_schedule');\n        setSelected([]);\n      }}>\n        <CreateIcon />\n      </IconButton>\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_schedule'} title=\"Delete\"><IconButton onClick={() => {\n        if (group.name) {\n          openConfirm({\n            isConfirming: true,\n            confirmEffect: `Remove ${plural(selected.length, 'schedule', 'schedules')}. This cannot be undone.`,\n            confirmAction: async () => {\n              const ids = selected.join(',');\n              await deleteGroupUserScheduleByUserScheduleId({ groupName: group.name, ids }).unwrap();\n              await deleteSchedule({ ids }).unwrap();\n              void getUserProfileDetails();\n              setSnack({ snackType: 'success', snackOn: 'Successfully removed schedule records.' });\n            }\n          });\n        }\n      }}>\n        <DeleteIcon />\n      </IconButton></Tooltip>\n    ]\n  }, [selected, group]);\n\n  const ScheduleBracketGrid = useGrid({\n    rows: schedules || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <TextField\n        select\n        value={group.id}\n        label=\"Group\"\n        variant=\"standard\"\n        onChange={e => {\n          if (profile?.groups) {\n            const gr = profile?.groups[e.target.value];\n            if (gr) setGroup(gr);\n          }\n        }}\n      >\n        {groupsValues.map(group => <MenuItem key={`group-select${group.id}`} value={group.id}>{group.name}</MenuItem>)}\n      </TextField>\n      <Box pt={2} sx={{ width: '100%' }}>\n        <Typography variant=\"button\">Schedules:</Typography>\n        <Button key={'create_schedule_button'} onClick={() => {\n          if (schedules?.length) {\n            setSchedule(undefined);\n            setDialog('manage_schedule');\n          } else {\n            setSnack({ snackType: 'warning', snackOn: 'There are no active group schedules.' })\n          }\n        }}>Create</Button>\n        {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n      </Box>\n    </>\n  })\n\n  return <>\n    <Dialog open={dialog === 'manage_schedule'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageScheduleBracketsModal {...props} group={group} editSchedule={schedule} closeModal={() => {\n          setDialog('');\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <ScheduleBracketGrid />\n  </>\n}\n\nexport default ManageScheduleBrackets;"}
{"prompt":"Create a react component ManageScheduleBracketsModal.tsx implementing application types IGroup, IScheduleBracketSlot, IScheduleBracket, ISchedule, IService, ITimeUnitNames. Create interface IProps implementing IGroup as a property type, method parameter or return type. Create a constant variable named newBrackets that uses IScheduleBracketSlot. Implement useState parts named [bracket, setBracket] that uses IScheduleBracket. Create a constant variable named handleSubmit that uses IScheduleBracket. Create react component named ManageScheduleBracketsModal implementing IScheduleBracket as a parameter or return type. Create interface IProps implementing ISchedule as a property type, method parameter or return type. Implement useState parts named [schedule, setSchedule] that uses ISchedule. Create a constant variable named newBrackets that uses IService. Create a constant variable named attachScheduleUnits that uses ITimeUnitNames. As a reminder, the application types related to this task and their purposes: IGroupIScheduleBracketSlotIScheduleBracketIScheduleIServiceITimeUnitNames.","completion":"import React, { useMemo, useState, useRef, useCallback, Suspense, useEffect } from 'react';\n\nimport Grid from '@mui/material/Grid';\nimport Typography from '@mui/material/Typography';\nimport Box from '@mui/material/Box';\nimport Slider from '@mui/material/Slider';\nimport Switch from '@mui/material/Switch';\nimport Chip from '@mui/material/Chip';\nimport CircularProgress from '@mui/material/CircularProgress';\nimport Button from '@mui/material/Button';\nimport MenuItem from '@mui/material/MenuItem';\nimport TextField from '@mui/material/TextField';\nimport DialogContent from '@mui/material/DialogContent';\nimport DialogTitle from '@mui/material/DialogTitle';\nimport DialogActions from '@mui/material/DialogActions';\n\nimport { getRelativeDuration, IGroup, ISchedule, IScheduleBracket, IScheduleBracketSlot, IService, ITimeUnitNames, timeUnitOrder } from 'awayto/core';\nimport { useComponents, sh, useUtil } from 'awayto/hooks';\n\nimport { scheduleSchema } from './ScheduleHome';\n\nconst bracketSchema = {\n  duration: 1,\n  automatic: false,\n  multiplier: '1.00'\n};\n\ndeclare global {\n  interface IProps {\n    group?: IGroup;\n    editSchedule?: ISchedule;\n  }\n}\n\nexport function ManageScheduleBracketsModal({ group, editSchedule, closeModal, ...props }: IProps): JSX.Element {\n\n  if (!group?.name) return <></>;\n\n  const { setSnack } = useUtil();\n\n  const { data: lookups } = sh.useGetLookupsQuery();\n  const { data: schedules } = sh.useGetSchedulesQuery();\n  const { data: groupServices } = sh.useGetGroupServicesQuery({ groupName: group.name });\n  const { data: groupSchedules } = sh.useGetGroupSchedulesQuery({ groupName: group.name });\n\n  const [getUserProfileDetails] = sh.useLazyGetUserProfileDetailsQuery();\n  const [getScheduleById] = sh.useLazyGetScheduleByIdQuery();\n  const [postSchedule] = sh.usePostScheduleMutation();\n  const [postScheduleBrackets] = sh.usePostScheduleBracketsMutation();\n  const [postGroupUserSchedule] = sh.usePostGroupUserScheduleMutation()\n  \n  const { ScheduleDisplay } = useComponents();\n\n  const scheduleParent = useRef<HTMLDivElement>(null);\n  const [viewStep, setViewStep] = useState(1);\n  const [schedule, setSchedule] = useState({ ...scheduleSchema, brackets: {} } as ISchedule);\n  const [bracket, setBracket] = useState({ ...bracketSchema, services: {}, slots: {} } as IScheduleBracket);\n\n  const attachScheduleUnits = useCallback((sched: ISchedule) => {\n    sched.scheduleTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.scheduleTimeUnitId)?.name as ITimeUnitNames;\n    sched.bracketTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.bracketTimeUnitId)?.name as ITimeUnitNames;\n    sched.slotTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.slotTimeUnitId)?.name as ITimeUnitNames;\n  }, [lookups]);\n\n  useEffect(() => {\n    if (groupSchedules?.length) {\n      if (editSchedule) {\n        getScheduleById({ id: editSchedule.id }).catch(console.error);\n      } else {\n        const sched = groupSchedules[0];\n        attachScheduleUnits(sched);\n        setSchedule({ ...sched, brackets: {} });\n      }\n    }\n  }, [editSchedule, groupSchedules]);\n\n  useEffect(() => {\n    if (editSchedule) {\n      const sched = schedules?.find(s => s.id === editSchedule.id);\n      if (sched) {\n        attachScheduleUnits(sched);\n        setSchedule({ ...sched });\n        if (Object.keys(sched.brackets).length) {\n          setViewStep(2);\n        }\n      }\n    }\n  }, [editSchedule, schedules]);\n\n  const scheduleBracketsValues = useMemo(() => Object.values(schedule.brackets || {}), [schedule.brackets]);\n  const bracketServicesValues = useMemo(() => Object.values(bracket.services || {}), [bracket.services]);\n\n  const remainingBracketTime = useMemo(() => {\n    if (schedule.scheduleTimeUnitName) {\n      // Complex time adjustment example - this gets the remaining time that can be scheduled based on the schedule context, which always selects its first child as the subcontext (Week > Day), multiply this by the schedule duration in that context (1 week is 7 days), then convert the result to whatever the bracket type is. So if the schedule is for 40 hours per week, the schedule duration is 1 week, which is 7 days. The bracket, in hours, gives 24 hrs per day * 7 days, resulting in 168 total hours. Finally, subtract the time used by selected slots in the schedule display.\n      const scheduleUnitChildUnit = timeUnitOrder[timeUnitOrder.indexOf(schedule.scheduleTimeUnitName) - 1];\n      const scheduleChildDuration = getRelativeDuration(1, schedule.scheduleTimeUnitName, scheduleUnitChildUnit); // 7\n      const usedDuration = scheduleBracketsValues.reduce((m, d) => m + d.duration, 0);\n      const totalDuration = getRelativeDuration(Math.floor(scheduleChildDuration), scheduleUnitChildUnit, schedule.bracketTimeUnitName);\n      return Math.floor(totalDuration - usedDuration);\n    }\n    return 0;\n  }, [schedule, scheduleBracketsValues]);\n\n  const handleSubmit = useCallback(async () => {\n    if (schedule) {\n      const { name, scheduleTimeUnitName } = schedule;\n      if (name && scheduleTimeUnitName && scheduleBracketsValues.length) {\n        const userSchedule = { ...schedule };\n        if (!editSchedule) {\n          const newSchedule = await postSchedule(schedule).unwrap();\n          userSchedule.id = newSchedule.id;\n        }\n        \n        const newBrackets = scheduleBracketsValues.map(\n          ({ id, duration, automatic, multiplier, slots, services }) => [\n            id,\n            {\n              id,\n              duration,\n              automatic,\n              multiplier,\n              slots: Object.values(slots).map(({ startTime }, i) => [String(i), { startTime } as IScheduleBracketSlot]),\n              services: Object.values(services).map(({ id }, i) => [String(i), { id } as IService])\n            }\n          ]\n        );\n\n        await postScheduleBrackets({\n          scheduleId: userSchedule.id,\n          brackets: Object.fromEntries(newBrackets) as Record<string, IScheduleBracket>\n        }).catch(console.error);\n\n        if (!editSchedule) {\n          await postGroupUserSchedule({\n            groupName: group?.name,\n            userScheduleId: userSchedule.id,\n            groupScheduleId: schedule.id\n          }).catch(console.error);\n        }\n\n        await getUserProfileDetails().catch(console.error);\n        setSnack({ snackOn: 'Successfully added ' + name, snackType: 'info' });\n        if (closeModal) closeModal();\n      } else {\n        setSnack({ snackOn: 'A schedule should have a name, a duration, and at least 1 bracket.', snackType: 'info' });\n      }\n    }\n  }, [group, schedule, scheduleBracketsValues]);\n\n  return <>\n    <DialogTitle>{!editSchedule?.id ? 'Create' : 'Manage'} Schedule Bracket</DialogTitle>\n    <DialogContent>\n\n      {1 === viewStep ? <>\n        <Box mt={2} />\n\n        <Box mb={4}>\n          <TextField\n            select\n            fullWidth\n            disabled={!!editSchedule?.id}\n            label=\"Group Schedules\"\n            helperText=\"Select a group schedule to add to.\"\n            value={schedule.id}\n            onChange={e => {\n              if (!editSchedule) {\n                const sched = groupSchedules?.find(gs => gs.id === e.target.value);\n                if (sched) {\n                  attachScheduleUnits(sched);\n                  setSchedule({ ...sched, brackets: {} });\n                }\n              }\n            }}\n          >\n            {groupSchedules?.map(s => {\n              return <MenuItem\n                key={`schedule-select${s.id}`}\n                value={s.id}\n                sx={{ alignItems: 'baseline' }}\n              >\n                {s.name}&nbsp;&nbsp;&nbsp;\n                <Typography variant=\"caption\" fontSize={10}>Timezone: {s.timezone}</Typography>\n              </MenuItem>\n            })}\n          </TextField>\n        </Box>\n\n        <Box mb={4}>\n          <Typography variant=\"body1\"></Typography>\n          <TextField\n            fullWidth\n            type=\"number\"\n            helperText={`Number of ${schedule.bracketTimeUnitName}s for this schedule. (Remaining: ${remainingBracketTime})`}\n            label={`# of ${schedule.bracketTimeUnitName}s`}\n            value={bracket.duration || ''}\n            onChange={e => setBracket({ ...bracket, duration: Math.min(Math.max(0, parseInt(e.target.value || '', 10)), remainingBracketTime) })}\n          />\n        </Box>\n\n        <Box sx={{ display: 'none' }}>\n          <Typography variant=\"h6\">Multiplier</Typography>\n          <Typography variant=\"body2\">Affects the cost of all services in this bracket.</Typography>\n          <Box sx={{ display: 'flex', alignItems: 'baseline' }}>\n            <Box>{bracket.multiplier}x <span>&nbsp;</span> &nbsp;</Box>\n            <Slider value={parseFloat(bracket.multiplier || '')} onChange={(_, val) => setBracket({ ...bracket, multiplier: parseFloat(val.toString()).toFixed(2) })} step={.01} min={1} max={5} />\n          </Box>\n        </Box>\n\n        <Box sx={{ display: 'none' }}>\n          <Typography variant=\"h6\">Automatic</Typography>\n          <Typography variant=\"body2\">Bracket will automatically accept new bookings.</Typography>\n          <Switch color=\"primary\" value={bracket.automatic} onChange={e => setBracket({ ...bracket, automatic: e.target.checked })} />\n        </Box>\n\n        <Box mb={4}>\n          <TextField\n            select\n            fullWidth\n            label=\"Services\"\n            helperText=\"Select the services available to be scheduled.\"\n            value={''}\n            onChange={e => {\n              const serv = groupServices?.find(gs => gs.id === e.target.value);\n              if (serv) {\n                bracket.services[e.target.value] = serv;\n                setBracket({ ...bracket, services: { ...bracket.services } });\n              }\n            }}\n          >\n            {groupServices?.filter(s => !Object.keys(bracket.services).includes(s.id)).map(service => <MenuItem key={`service-select${service.id}`} value={service.id}>{service.name}</MenuItem>)}\n          </TextField>\n\n          <Box sx={{ display: 'flex', alignItems: 'flex-end', flexWrap: 'wrap' }}>\n            {bracketServicesValues.map((service, i) => {\n              return <Box key={`service-chip${i + 1}new`} m={1}><Chip label={`${service.name} ${service.cost ? `Cost: ${service.cost}` : ''}`} onDelete={() => {\n                delete bracket.services[service.id];\n                setBracket({ ...bracket, services: { ...bracket.services } });\n              }} /></Box>\n            })}\n          </Box>\n        </Box>\n      </> : <>\n        <Suspense fallback={<CircularProgress />}>\n          <ScheduleDisplay {...props} parentRef={scheduleParent} schedule={schedule} setSchedule={setSchedule} />\n        </Suspense>\n      </>}\n    </DialogContent>\n    <DialogActions>\n      <Grid container justifyContent=\"space-between\">\n        <Button onClick={closeModal}>Cancel</Button>\n        {1 === viewStep ? <Grid item>\n          {!!scheduleBracketsValues.length && <Button\n            onClick={() => {\n              setViewStep(2);\n              setBracket({ ...bracketSchema, services: {}, slots: {} } as IScheduleBracket);\n            }}\n          >\n            Cancel Add\n          </Button>}\n          <Button\n            disabled={!bracket.duration || !bracketServicesValues.length}\n            onClick={() => {\n              if (bracket.duration && Object.keys(bracket.services).length) {\n                bracket.id = (new Date()).getTime().toString();\n                bracket.scheduleId = schedule.id;\n                schedule.brackets[bracket.id] = bracket;\n                setSchedule({ ...schedule, brackets: schedule.brackets })\n                setBracket({ ...bracketSchema, services: {}, slots: {} } as IScheduleBracket);\n                setViewStep(2);\n              } else {\n                void setSnack({ snackOn: 'Provide a duration, and at least 1 service.', snackType: 'info' });\n              }\n            }}\n          >\n            Continue\n          </Button>\n        </Grid> : <Grid item>\n          <Button onClick={() => { setViewStep(1); }}>Add another</Button>\n          <Button onClick={handleSubmit}>Submit</Button>\n        </Grid>}\n      </Grid>\n    </DialogActions>\n  </>\n}\n\nexport default ManageScheduleBracketsModal;"}
{"prompt":"Create a react component ManageSchedules.tsx implementing application types ISchedule. Implement useState parts named [schedule, setSchedule] that uses ISchedule. As a reminder, the application types related to this task and their purposes: ISchedule.","completion":"import React, { useState, useMemo, Suspense } from 'react';\nimport dayjs from 'dayjs';\n\nimport Typography from '@mui/material/Typography';\nimport Box from '@mui/material/Box';\nimport Button from '@mui/material/Button';\nimport Dialog from '@mui/material/Dialog';\nimport Tooltip from '@mui/material/Tooltip';\n\nimport CreateIcon from '@mui/icons-material/Create';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport MoreTimeIcon from '@mui/icons-material/MoreTime';\n\nimport { ISchedule } from 'awayto/core';\nimport { useComponents, useGrid, sh, useUtil } from 'awayto/hooks';\n\nimport ManageSchedulesModal from './ManageSchedulesModal';\nimport { useParams } from 'react-router';\n\n// This is how group owners interact with the schedule\nexport function ManageSchedules(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { openConfirm } = useUtil();\n  const { ManageScheduleStubs } = useComponents();\n\n  const [deleteGroupSchedule] = sh.useDeleteGroupScheduleMutation();\n  \n  const { data: groupSchedules, refetch: getGroupSchedules } = sh.useGetGroupSchedulesQuery({ groupName: groupName });\n\n  const [schedule, setSchedule] = useState<ISchedule>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <Tooltip key={'manage_schedule'} title=\"Edit\">\n        <Button onClick={() => {\n          setSchedule(groupSchedules?.find(gs => gs.id === selected[0]));\n          setDialog('manage_schedule');\n          setSelected([]);\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_schedule'} title=\"Delete\">\n        <Button onClick={() => {\n          openConfirm({\n            isConfirming: true,\n            confirmEffect: 'Are you sure you want to delete these schedules? This cannot be undone.',\n            confirmAction: async () => {\n              await deleteGroupSchedule({ groupName, ids: selected.join(',') }).unwrap();\n              void getGroupSchedules();\n              setSelected([]);\n            }\n          });\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ]\n  }, [selected, groupName]);\n\n  const ScheduleGrid = useGrid({\n    rows: groupSchedules || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Master Schedules:</Typography>\n      <Tooltip key={'manage_role'} title=\"Create\">\n        <Button onClick={() => {\n          setSchedule(undefined);\n          setDialog('manage_schedule')\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\n          <MoreTimeIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  });\n\n  return <>\n    <Dialog open={dialog === 'manage_schedule'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageSchedulesModal {...props} editSchedule={schedule} closeModal={() => {\n          setDialog('');\n          void getGroupSchedules();\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <Box mb={2}>\n      <ScheduleGrid />\n    </Box>\n\n    <Box mb={2}>\n      <ManageScheduleStubs {...props} />\n    </Box>\n  </>\n}\n\nexport default ManageSchedules;"}
{"prompt":"Create a react component ManageSchedulesModal.tsx implementing application types IGroupSchedule, ISchedule, ITimeUnitNames, ITimeUnit. Create a constant variable named handleSubmit that uses IGroupSchedule. Create interface IProps implementing ISchedule as a property type, method parameter or return type. Implement useState parts named [schedule, setSchedule] that uses ISchedule. Create a constant variable named attachScheduleUnits that uses ISchedule. Create a constant variable named attachScheduleUnits that uses ITimeUnitNames. Create a constant variable named { name, id } that uses ITimeUnit. As a reminder, the application types related to this task and their purposes: IGroupScheduleIScheduleITimeUnitNamesITimeUnit.","completion":"import React, { useState, useCallback, useMemo, useEffect } from 'react';\nimport { useParams } from 'react-router';\n\nimport Alert from '@mui/material/Alert';\nimport Box from '@mui/material/Box';\nimport Grid from '@mui/material/Grid';\nimport Typography from '@mui/material/Typography';\nimport DialogContent from '@mui/material/DialogContent';\nimport DialogTitle from '@mui/material/DialogTitle';\nimport DialogActions from '@mui/material/DialogActions';\nimport Slider from '@mui/material/Slider';\nimport Button from '@mui/material/Button';\nimport TextField from '@mui/material/TextField';\nimport { Mark } from '@mui/base';\n\nimport { ISchedule, ITimeUnit, TimeUnit, timeUnitOrder, getRelativeDuration, ITimeUnitNames, IGroupSchedule } from 'awayto/core';\nimport { useComponents, useUtil, sh } from 'awayto/hooks';\n\nimport { scheduleSchema } from './ScheduleHome';\n\ndeclare global {\n  interface IProps {\n    editSchedule?: ISchedule;\n  }\n}\n\nexport function ManageScheduleModal({ editSchedule, closeModal, ...props }: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { setSnack } = useUtil();\n\n  const [postGroupSchedule] = sh.usePostGroupScheduleMutation();\n  const [putGroupSchedule] = sh.usePutGroupScheduleMutation();\n  const [getGroupSchedules] = sh.useLazyGetGroupSchedulesQuery();\n  const [getGroupScheduleMasterById] = sh.useLazyGetGroupScheduleMasterByIdQuery();\n\n  const { data: lookups } = sh.useGetLookupsQuery();\n  \n  const { SelectLookup } = useComponents();\n  \n  const [schedule, setSchedule] = useState({ ...scheduleSchema, ...editSchedule } as ISchedule);\n\n  const attachScheduleUnits = useCallback((sched: ISchedule): ISchedule => {\n    sched.scheduleTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.scheduleTimeUnitId)?.name as ITimeUnitNames;\n    sched.bracketTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.bracketTimeUnitId)?.name as ITimeUnitNames;\n    sched.slotTimeUnitName = lookups?.timeUnits?.find(u => u.id === sched.slotTimeUnitId)?.name as ITimeUnitNames;\n    return sched;\n  }, [lookups]);\n\n  const setDefault = useCallback((type: string) => {\n    const weekId = lookups?.timeUnits?.find(s => s.name === TimeUnit.WEEK)?.id;\n    const hourId = lookups?.timeUnits?.find(s => s.name === TimeUnit.HOUR)?.id;\n    const dayId = lookups?.timeUnits?.find(s => s.name === TimeUnit.DAY)?.id;\n    const minuteId = lookups?.timeUnits?.find(s => s.name === TimeUnit.MINUTE)?.id;\n    const monthId = lookups?.timeUnits?.find(s => s.name === TimeUnit.MONTH)?.id;\n    if ('40hoursweekly30minsessions' === type) {\n      setSchedule(attachScheduleUnits({\n        ...schedule,\n        scheduleTimeUnitId: weekId as string,\n        bracketTimeUnitId: hourId as string,\n        slotTimeUnitId: minuteId as string,\n        slotDuration: 30\n      }));\n    } else if ('dailybookingpermonth') {\n      setSchedule(attachScheduleUnits({\n        ...schedule,\n        scheduleTimeUnitId: monthId as string,\n        bracketTimeUnitId: weekId as string,\n        slotTimeUnitId: dayId as string,\n        slotDuration: 1\n      }));\n    }\n  }, [lookups, schedule]);\n\n  const slotDurationMarks = useMemo(() => {\n    const { scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName } = schedule;\n    const factors = [] as Mark[];\n    if (!bracketTimeUnitName || !slotTimeUnitName || !scheduleTimeUnitName) return factors;\n    // const subdivided = bracketTimeUnitName !== slotTimeUnitName;\n    // const finalDuration = !subdivided ? \n    //   Math.round(getRelativeDuration(duration, scheduleTimeUnitName, bracketTimeUnitName)) : \n    const finalDuration = Math.round(getRelativeDuration(1, bracketTimeUnitName, slotTimeUnitName));\n    for (let value = 1; value <= finalDuration; value++) {\n      if (finalDuration % value === 0) {\n        factors.push({ value, label: value });\n      }\n    }\n    return factors;\n  }, [schedule]);\n\n  const handleSubmit = useCallback(async () => {\n\n    const { id, name, startTime, endTime } = schedule;\n    if (!id) {\n      if (name && startTime) {\n        schedule.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        await postGroupSchedule({ ...schedule, groupName } as IGroupSchedule).unwrap();\n        await getGroupSchedules({ groupName }).unwrap();\n        setSnack({ snackOn: 'Successfully added ' + name + ' as a master schedule!', snackType: 'info' });\n      } else {\n        setSnack({ snackOn: 'A schedule should have a name, a start time.', snackType: 'info' });\n      }\n    } else {\n      await putGroupSchedule({ id, startTime, endTime, groupName } as IGroupSchedule).unwrap();\n      setSnack({ snackOn: 'Schedule updated!', snackType: 'info' });\n    }\n\n    if (closeModal)\n      closeModal();\n  }, [schedule]);\n\n  useEffect(() => {\n    async function go() {\n      if (groupName && editSchedule) {\n        const masterSchedule = await getGroupScheduleMasterById({ groupName, scheduleId: editSchedule.id }).unwrap();\n        attachScheduleUnits(masterSchedule);\n        setSchedule(masterSchedule);\n      } else {\n        setDefault('40hoursweekly30minsessions');\n      }\n    }\n    void go();\n  }, []);\n\n  return <>\n    <DialogTitle>{schedule.id ? 'Manage' : 'Create'} Schedule</DialogTitle>\n    <DialogContent>\n      <Box mt={2} />\n\n      <Box mb={4}>\n        <TextField\n          fullWidth\n          disabled={!!schedule.id}\n          label=\"Name\"\n          helperText=\"Ex: Spring 2022 Campaign, Q1 Offering\"\n          value={schedule.name || ''}\n          onChange={e => setSchedule({ ...schedule, name: e.target.value })}\n        />\n      </Box>\n\n      <Box mb={4}>\n        <Grid container spacing={2} direction=\"row\">\n          <Grid item xs={6}>\n            \n            <TextField\n              fullWidth\n              label=\"Start Date\"\n              type=\"date\"\n              value={schedule.startTime || ''}\n              helperText=\"Schedule is active after this date. Clear this date to deactivate the schedule. Deactivated schedules do not allow new bookings to be made.\"\n              onChange={e => setSchedule({ ...schedule, startTime: e.target.value })}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n            {/* <DesktopDatePicker\n              label=\"Start Date\"\n              value={schedule.startTime ? schedule.startTime : null}\n              onChange={e => {\n                // if (e) {\n                //   console.log({ schedule, e, str: e ? nativeJs(new Date(e.toString())) : null })\n                //   setSchedule({ ...schedule, startTime: nativeJs(new Date(e.toString())).toString() })\n                //   // setSchedule({ ...schedule, startTime: e ? e.format(DateTimeFormatter.ofPattern(\"yyyy-mm-dd\")) : '' });\n                // }\n              }}\n              renderInput={(params) => <TextField helperText=\"Bookings can be scheduled any time after this date. Removing this value and saving the schedule will deactivate it, preventing it from being seen during booking.\" {...params} />}\n            /> */}\n          </Grid>\n          <Grid item xs={6}>\n            <TextField\n              fullWidth\n              label=\"End Date\"\n              type=\"date\"\n              value={schedule.endTime || ''}\n              helperText=\"Optional. No bookings will be allowed after this date.\"\n              onChange={e => setSchedule({ ...schedule, endTime: e.target.value })}\n              InputLabelProps={{\n                shrink: true,\n              }}\n            />\n          </Grid>\n        </Grid>\n      </Box>\n\n      <Box mb={4}>\n        {!schedule.id ? <>\n          <Typography variant=\"body2\">Use premade selections for this schedule.</Typography>\n          <Button color=\"secondary\" onClick={() => setDefault('40hoursweekly30minsessions')}>40 hours per week, 30 minute slot</Button>\n          <Button color=\"secondary\" onClick={() => setDefault('dailybookingpermonth')}>daily booking per month</Button>\n        </> : <>\n          <Alert color=\"info\">Schedule template durations are read-only after creation.</Alert>\n        </>}\n      </Box>\n\n      <Box mb={4}>\n        <SelectLookup\n          noEmptyValue\n          disabled={!!schedule.id}\n          lookupName=\"Schedule Duration\"\n          helperText=\"The length of time the schedule will run over. This determines the overall context of the schedule and how time will be divided and managed within. For example, a 40 hour per week schedule would require configuring a 1 week Schedule Duration.\"\n          lookupValue={schedule.scheduleTimeUnitId}\n          lookups={lookups?.timeUnits?.filter(sc => ![TimeUnit.MINUTE, TimeUnit.HOUR, TimeUnit.YEAR].includes(sc.name as TimeUnit))}\n          lookupChange={(val: string) => {\n            const { id, name } = lookups?.timeUnits?.find(c => c.id === val) || {};\n            if (!id || !name) return;\n            setSchedule({ ...schedule, scheduleTimeUnitName: name, scheduleTimeUnitId: id, bracketTimeUnitId: lookups?.timeUnits?.find(s => s.name === timeUnitOrder[timeUnitOrder.indexOf(name) - 1])?.id as string })\n          }}\n          {...props}\n        />\n      </Box>\n\n      {/* <Box mb={4}>\n        <TextField\n          fullWidth\n          type=\"number\"\n          disabled={!!schedule.id}\n          label={`# of ${schedule.scheduleTimeUnitName}s`}\n          helperText=\"Provide a duration. After this duration, the schedule will reset, and all bookings will be available again.\"\n          value={schedule.duration}\n          onChange={e => {\n            setSchedule({ ...schedule, duration: Math.min(Math.max(0, parseInt(e.target.value || '', 10)), 999) })\n          }}\n        />\n      </Box> */}\n\n      <Box mb={4}>\n        <SelectLookup\n          noEmptyValue\n          disabled={!!schedule.id}\n          lookupName=\"Bracket Duration Type\"\n          helperText=\"How to measure blocks of time within the Schedule Duration. For example, in a 40 hour per week situation, blocks of time are divided in hours. Multiple brackets can be used on a single schedule, and all of them share the same Bracket Duration Type.\"\n          lookupValue={schedule.bracketTimeUnitId}\n          lookups={lookups?.timeUnits?.filter(sc => sc.name !== schedule.scheduleTimeUnitName && timeUnitOrder.indexOf(sc.name) <= timeUnitOrder.indexOf(schedule.scheduleTimeUnitName))}\n          lookupChange={(val: string) => {\n            const { name, id } = lookups?.timeUnits?.find(c => c.id === val) as ITimeUnit;\n            setSchedule({ ...schedule, bracketTimeUnitName: name, bracketTimeUnitId: id, slotTimeUnitName: name, slotTimeUnitId: id, slotDuration: 1 });\n          }}\n          {...props}\n        />\n      </Box>\n\n      <Box mb={4}>\n        <SelectLookup\n          noEmptyValue\n          disabled={!!schedule.id}\n          lookupName=\"Booking Slot Length\"\n          helperText={`The # of ${schedule.slotTimeUnitName}s to deduct from the bracket upon accepting a booking. Alternatively, if you meet with clients, this is the length of time per session.`}\n          lookupValue={schedule.slotTimeUnitId}\n          lookups={lookups?.timeUnits?.filter(sc => [timeUnitOrder.indexOf(schedule.bracketTimeUnitName), Math.max(timeUnitOrder.indexOf(schedule.bracketTimeUnitName) - 1, 0)].includes(timeUnitOrder.indexOf(sc.name)))}\n          lookupChange={(val: string) => {\n            const { name, id } = lookups?.timeUnits?.find(c => c.id === val) || {};\n            if (!name || !id) return;\n            setSchedule({ ...schedule, slotTimeUnitName: name, slotTimeUnitId: id, slotDuration: 1 })\n          }}\n          {...props}\n        />\n\n        <Box mt={2} sx={{ display: 'flex', alignItems: 'baseline' }}>\n          <Box>{schedule.slotDuration} <span>&nbsp;</span> &nbsp;</Box>\n          <Slider\n            disabled={!!schedule.id}\n            value={schedule.slotDuration}\n            step={null}\n            marks={slotDurationMarks}\n            max={Math.max(...slotDurationMarks.map(m => m.value))}\n            onChange={(_, val) => {\n              setSchedule({ ...schedule, slotDuration: parseFloat(val.toString()) });\n            }}\n          />\n        </Box>\n      </Box>\n\n    </DialogContent>\n    <DialogActions>\n      <Grid container justifyContent=\"space-between\">\n        <Button onClick={closeModal}>{schedule.id ? 'Close' : 'Cancel'}</Button>\n        <Button onClick={handleSubmit}>Submit</Button>\n      </Grid>\n    </DialogActions>\n  </>\n}\n\nexport default ManageScheduleModal;"}
{"prompt":"Create a react component ManageScheduleStubModal.tsx implementing application types IGroupScheduleDateSlots, IGroupUserScheduleStubReplacement, IGroupUserScheduleStub, IGroupUserSchedule. Implement useState parts named [firstAvailable, setFirstAvailable] that uses IGroupScheduleDateSlots. Create a constant variable named handleSubmit that uses IGroupUserScheduleStubReplacement. Create interface IProps implementing IGroupUserScheduleStub as a property type, method parameter or return type. Create a constant variable named handleSubmit that uses IGroupUserSchedule. As a reminder, the application types related to this task and their purposes: IGroupScheduleDateSlotsIGroupUserScheduleStubReplacementIGroupUserScheduleStubIGroupUserSchedule.","completion":"import React, { useState, useCallback } from 'react';\nimport { useParams } from 'react-router';\nimport dayjs from 'dayjs';\n\nimport Box from '@mui/material/Box';\nimport Grid from '@mui/material/Grid';\nimport Typography from '@mui/material/Typography';\nimport Divider from '@mui/material/Divider';\nimport Card from '@mui/material/Card';\nimport CardHeader from '@mui/material/CardHeader';\nimport CardContent from '@mui/material/CardContent';\nimport CardActions from '@mui/material/CardActions';\nimport Button from '@mui/material/Button';\n\nimport { IGroupScheduleDateSlots, IGroupUserScheduleStub, quotedDT, shortNSweet, IGroupUserSchedule, IGroupUserScheduleStubReplacement } from 'awayto/core';\nimport { sh } from 'awayto/hooks';\n\nimport ScheduleDatePicker from './ScheduleDatePicker';\nimport ScheduleTimePicker from './ScheduleTimePicker';\n\ndeclare global {\n  interface IProps {\n    editGroupUserScheduleStub?: IGroupUserScheduleStub;\n  }\n}\n\nexport function ManageScheduleStubModal({ editGroupUserScheduleStub, closeModal }: IProps): JSX.Element {\n  if (!editGroupUserScheduleStub) return <></>;\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const [putGroupUserScheduleStubReplacement] = sh.usePutGroupUserScheduleStubReplacementMutation();\n  const [getGroupUserScheduleStubReplacement] = sh.useLazyGetGroupUserScheduleStubReplacementQuery(); \n\n  const [_, { data: dateSlots }] = sh.useLazyGetGroupScheduleByDateQuery();\n\n  const [firstAvailable, setFirstAvailable] = useState({ time: dayjs() } as IGroupScheduleDateSlots);\n  const [activeSchedule, setActiveSchedule] = useState('');\n\n  const [bracketSlotDate, setBracketSlotDate] = useState<dayjs.Dayjs | null>();\n  const [bracketSlotTime, setBracketSlotTime] = useState<dayjs.Dayjs | null>();\n\n  const [replacement, setReplacement] = useState(editGroupUserScheduleStub.replacement);\n\n  const originalReplacement = editGroupUserScheduleStub?.replacement && { ...editGroupUserScheduleStub.replacement };\n\n  if (editGroupUserScheduleStub.userScheduleId && activeSchedule !== editGroupUserScheduleStub.userScheduleId && dateSlots?.length && !firstAvailable.scheduleBracketSlotId) {\n    const [slot] = dateSlots;\n    setFirstAvailable({ ...slot, time: quotedDT(slot.weekStart, slot.startTime) });\n    setActiveSchedule(editGroupUserScheduleStub.userScheduleId);\n  }\n\n  const handleSubmit = useCallback(async () => {\n    await putGroupUserScheduleStubReplacement({\n      groupName,\n      userScheduleId: editGroupUserScheduleStub.userScheduleId,\n      quoteId: editGroupUserScheduleStub.quoteId,\n      slotDate: (bracketSlotDate || firstAvailable.time).format(\"YYYY-MM-DD\"),\n      startTime: replacement.startTime,\n      serviceTierId: replacement.serviceTierId,\n      scheduleBracketSlotId: replacement.scheduleBracketSlotId\n    } as IGroupUserSchedule & IGroupUserScheduleStubReplacement).unwrap();\n\n    if (closeModal)\n      closeModal();\n  }, [editGroupUserScheduleStub]);\n\n  return <>\n    <Card>\n      <CardHeader title={`${shortNSweet(editGroupUserScheduleStub.slotDate, editGroupUserScheduleStub.startTime)}`} subheader={`${editGroupUserScheduleStub.serviceName} ${editGroupUserScheduleStub.tierName}`} />\n      <CardContent>\n        {originalReplacement && <>\n          <Box mb={2}>\n            <Typography>Use an existing slot at the same date and time:</Typography>\n          </Box>\n          <Box mb={4}>\n            <Button fullWidth variant=\"contained\" color=\"primary\" onClick={() => handleSubmit()}>Reassign to {originalReplacement.username}</Button>\n          </Box>\n\n          <Grid container direction=\"row\" alignItems=\"center\" spacing={2} mb={4}>\n            <Grid item flexGrow={1}>\n              <Divider />\n            </Grid>\n            <Grid item>\n              Or\n            </Grid>\n            <Grid item flexGrow={1}>\n              <Divider />\n            </Grid>\n          </Grid>\n        </>}\n\n        <Box mb={4}>\n          <Box mb={2}>\n            <Typography>Select a new date and time:</Typography>\n          </Box>\n          <Grid container spacing={2}>\n            <Grid item xs={6}>\n              <ScheduleDatePicker\n                key={editGroupUserScheduleStub.userScheduleId}\n                scheduleId={editGroupUserScheduleStub.groupScheduleId}\n                groupName={groupName}\n                firstAvailable={firstAvailable}\n                bracketSlotDate={bracketSlotDate || firstAvailable.time || null}\n                onDateChange={(date: dayjs.Dayjs | null) => setBracketSlotDate(date ? date.isBefore(firstAvailable.time) ? firstAvailable.time : date : null)}\n              />\n            </Grid>\n            <Grid item xs={6}>\n              <ScheduleTimePicker\n                key={bracketSlotDate?.format(\"YYYY-MM-DD\")}\n                scheduleId={editGroupUserScheduleStub.groupScheduleId}\n                firstAvailable={firstAvailable}\n                bracketSlotDate={bracketSlotDate || firstAvailable.time}\n                bracketSlotTime={bracketSlotTime || firstAvailable.time}\n                onTimeChange={({ time }) => setBracketSlotTime(time)}\n                onTimeAccept={({ slotDate, startTime }) => {\n                  const { userScheduleId, tierName } = editGroupUserScheduleStub;\n            \n                  getGroupUserScheduleStubReplacement({\n                    groupName,\n                    userScheduleId,\n                    slotDate,\n                    startTime,\n                    tierName\n                  }).unwrap().then(({ stubs }) => {\n                    const [replacementStub] = stubs;\n                    if (replacementStub) {\n                      setReplacement(replacementStub.replacement);\n                    }\n                  }).catch(console.error);\n                }}\n              />\n            </Grid>\n          </Grid>\n        </Box>\n\n        {replacement?.username && <Box my={2}>\n          <Button onClick={() => handleSubmit()} fullWidth variant=\"contained\" color=\"primary\">Reassign to {replacement.username}</Button>\n        </Box>}\n      </CardContent>\n      <CardActions>\n        <Grid container justifyContent=\"space-between\">\n          <Button onClick={closeModal}>Close</Button>\n        </Grid>\n      </CardActions>\n    </Card>\n  </>\n}\n\nexport default ManageScheduleStubModal;"}
{"prompt":"Create a react component ManageScheduleStubs.tsx implementing application types IGroupUserScheduleStub. Implement useState parts named [stub, setStub] that uses IGroupUserScheduleStub. As a reminder, the application types related to this task and their purposes: IGroupUserScheduleStub.","completion":"import React, { useEffect, useState, useMemo, Suspense } from 'react';\nimport { useParams } from 'react-router';\n\nimport IconButton from '@mui/material/IconButton';\nimport Dialog from '@mui/material/Dialog';\nimport Box from '@mui/material/Box';\nimport Typography from '@mui/material/Typography';\nimport Tooltip from '@mui/material/Tooltip';\n\nimport CreateIcon from '@mui/icons-material/Create';\n\nimport { IGroupUserScheduleStub, shortNSweet } from 'awayto/core';\nimport { useGrid, sh } from 'awayto/hooks';\n\nimport ManageScheduleStubModal from './ManageScheduleStubModal';\n\nexport function ManageSchedules(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { data: schedules, refetch: getGroupUserScheduleStubs } = sh.useGetGroupUserScheduleStubsQuery({ groupName })\n\n  const { stubs } = schedules || {};\n\n  const [stub, setStub] = useState<IGroupUserScheduleStub>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    return length == 1 ? [\n      <Tooltip key={'view_schedule_details'} title=\"View Details\">\n        <IconButton key={'manage_schedule'} onClick={() => {\n          if (stubs?.length) {\n            setStub(stubs?.find(s => s.userScheduleId === selected[0]));\n            setDialog('manage_schedule');\n            setSelected([]);\n          }\n        }}>\n          <CreateIcon />\n        </IconButton>\n      </Tooltip>\n    ] : []\n  }, [selected, groupName]);\n\n  const ScheduleStubGrid = useGrid({\n    rows: stubs || [],\n    columns: [\n      { flex: 1, headerName: 'Date', field: 'slotDate', renderCell: ({ row }) => shortNSweet(row.slotDate, row.startTime) },\n      { flex: 1, headerName: 'Service', field: 'serviceName' },\n      { flex: 1, headerName: 'Tier', field: 'tierName' },\n      { flex: 1, headerName: 'Created', field: 'replacement', renderCell: ({ row }) => Object.keys(row.replacement || {}).length ? 'Yes' : 'No' }\n    ],\n    rowId: 'userScheduleId',\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Appointment Issues</Typography>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  })\n\n  return <>\n    <Dialog open={dialog === 'manage_schedule'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageScheduleStubModal {...props} editGroupUserScheduleStub={stub} closeModal={() => {\n          setDialog('');\n          void getGroupUserScheduleStubs();\n        }} />\n      </Suspense>\n    </Dialog>\n\n    <ScheduleStubGrid />\n  </>\n}\n\nexport default ManageSchedules;"}
{"prompt":"Create a react component ScheduleDatePicker.tsx implementing application types IGroupScheduleDateSlots. Create type ScheduleDatePickerType which implements IGroupScheduleDateSlots. As a reminder, the application types related to this task and their purposes: IGroupScheduleDateSlots.","completion":"import React, { useState } from 'react';\nimport dayjs from 'dayjs';\n\nimport TextField from '@mui/material/TextField';\nimport { DesktopDatePicker } from '@mui/x-date-pickers/DesktopDatePicker';\n\nimport { IGroupScheduleDateSlots, TimeUnit, userTimezone } from 'awayto/core';\nimport { sh } from 'awayto/hooks';\n\ntype ScheduleDatePickerType = {  \n  groupName?: string;\n  scheduleId?: string;\n  firstAvailable?: IGroupScheduleDateSlots & { time: dayjs.Dayjs };\n  bracketSlotDate?: dayjs.Dayjs | null;\n  onDateChange?(value: dayjs.Dayjs | null, keyboardInputValue?: string | undefined): void;\n}\n\ndeclare global {\n  interface IProps extends ScheduleDatePickerType {}\n}\n\nexport function ScheduleDatePicker(props: IProps): JSX.Element {\n\n  const { groupName, scheduleId, firstAvailable, bracketSlotDate, onDateChange } = props as Required<ScheduleDatePickerType>;\n\n  const [monthSeekDate, setMonthSeekDate] = useState(dayjs().startOf(TimeUnit.MONTH));\n\n  const { data: dateSlots } = sh.useGetGroupScheduleByDateQuery({\n    groupName,\n    scheduleId,\n    date: monthSeekDate.format(\"YYYY-MM-DD\"),\n    timezone: btoa(userTimezone)\n  });\n\n  return <DesktopDatePicker\n    value={bracketSlotDate}\n    onChange={onDateChange}\n    label=\"Date\"\n    inputFormat=\"MM/DD/YYYY\"\n    minDate={firstAvailable.time}\n    onOpen={() => setMonthSeekDate(firstAvailable.time)}\n    onMonthChange={date => date && setMonthSeekDate(date)}\n    onYearChange={date => date && setMonthSeekDate(date)}\n    renderInput={(params) => <TextField fullWidth {...params} />}\n    disableHighlightToday={true}\n    shouldDisableDate={date => {\n      if (date && dateSlots?.length) {\n        return !dateSlots.filter(s => s.startDate === date.format(\"YYYY-MM-DD\")).length;\n      }\n      return true;\n    }}\n  />\n}\n\nexport default ScheduleDatePicker;"}
{"prompt":"Create a react component ScheduleDisplay.tsx implementing application types IScheduleBracketSlot, IScheduleBracket, ISchedule. Implement useState parts named [selected, setSelected] that uses IScheduleBracketSlot. Create a constant variable named slot that uses IScheduleBracketSlot. Create a constant variable named newSelected that uses IScheduleBracketSlot. Implement useState parts named [selectedBracket, setSelectedBracket] that uses IScheduleBracket. Create enum ScheduleDisplayProps that uses ISchedule as a member value or type. As a reminder, the application types related to this task and their purposes: IScheduleBracketSlotIScheduleBracketISchedule.","completion":"import React, { CSSProperties, useCallback, useMemo, useState, useEffect, useRef } from 'react';\nimport { FixedSizeGrid } from 'react-window';\n\nimport Box from '@mui/material/Box';\nimport Chip from '@mui/material/Chip';\nimport CardActionArea from '@mui/material/CardActionArea';\nimport Typography from '@mui/material/Typography';\n\nimport { getRelativeDuration, ISchedule, IScheduleBracket, IScheduleBracketSlot } from 'awayto/core';\nimport { useSchedule } from 'awayto/hooks';\n\nexport type ScheduleDisplayProps = {\n  schedule?: ISchedule;\n  setSchedule?(value: ISchedule): void;\n};\n\ntype GridCell = {\n  columnIndex: number, rowIndex: number, style: CSSProperties\n}\n\ndeclare global {\n  interface IProps extends ScheduleDisplayProps { }\n}\n\nconst bracketColors = ['cadetblue', 'brown', 'chocolate', 'forestgreen', 'darkslateblue', 'goldenrod', 'indianred', 'teal'];\n\nexport default function ScheduleDisplay({ schedule, setSchedule }: IProps & Required<ScheduleDisplayProps>): JSX.Element {\n\n  const columnWidth = 150;\n  \n  const getScheduleData = useSchedule();\n  const parentRef = useRef<HTMLDivElement>(null);\n  const [selected, setSelected] = useState({} as Record<string, IScheduleBracketSlot>);\n  const [selectedBracket, setSelectedBracket] = useState<IScheduleBracket>();\n  const [buttonDown, setButtonDown] = useState(false);\n  const [width, setWidth] = useState(1);\n\n  const { scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName, slotDuration } = schedule;\n  const { divisions, durations, selections, xAxisTypeName } = useMemo(() => {\n    return getScheduleData({ scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName, slotDuration });\n  }, [scheduleTimeUnitName, bracketTimeUnitName, slotTimeUnitName, slotDuration])\n\n  const scheduleBracketsValues = useMemo(() => Object.values(schedule.brackets || {}), [schedule.brackets]);\n\n  const setValue = useCallback((startTime: string) => {\n    if (selectedBracket) {\n      const bracket = schedule.brackets[selectedBracket.id];\n      if (bracket) {\n        if (!bracket.slots) bracket.slots = {};\n\n        const target = `schedule_bracket_slot_selection_${startTime}`;\n        const exists = selected[target];\n  \n        const slot = {\n          id: (new Date()).getTime().toString(),\n          startTime,\n          scheduleBracketId: selectedBracket.id\n        } as IScheduleBracketSlot;\n  \n        if (exists) {\n          delete bracket.slots[exists.id];\n          delete selected[target];\n        } else if (Object.keys(bracket.slots).length * schedule.slotDuration < getRelativeDuration(selectedBracket.duration, schedule.bracketTimeUnitName, schedule.slotTimeUnitName)) {\n          bracket.slots[slot.id] = slot;\n          selected[target] = slot;\n        } else {\n          alert('you went over your allottment');\n          setButtonDown(false);\n          return;\n        }\n  \n        setSchedule({ ...schedule, brackets: { ...schedule.brackets } });\n        setSelected({ ...selected });\n      }\n    }\n  }, [schedule, selectedBracket, scheduleBracketsValues, selected]);\n\n  const Cell = useCallback((gridCell: GridCell) => {\n    const { startTime, contextFormat } = durations[gridCell.columnIndex][gridCell.rowIndex];\n\n    const target = `schedule_bracket_slot_selection_${startTime}`;    \n    const exists = selected[target];\n\n    return <CardActionArea\n      style={gridCell.style}\n      sx={{\n        backgroundColor: '#444',\n        textAlign: 'center',\n        position: 'relative',\n        '&:hover': {\n          backgroundColor: '#aaa',\n          opacity: '1',\n          boxShadow: '2'\n        },\n        border: exists ? `1px solid ${bracketColors[scheduleBracketsValues.findIndex(b => b.id === exists.scheduleBracketId)]}` : undefined,\n        opacity: !exists ? '.33' : '1',\n        boxShadow: exists ? '2' : undefined\n      }}\n      onMouseLeave={() => buttonDown && setValue(startTime)}\n      onMouseDown={() => setButtonDown(true)}\n      onMouseUp={() => {\n        setButtonDown(false);\n        setValue(startTime);\n      }}\n    >\n      {contextFormat}\n    </CardActionArea>\n  }, [selected, buttonDown, selectedBracket, xAxisTypeName]);\n\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(([event]) => {\n      setWidth(event.contentBoxSize[0].inlineSize);\n    });\n\n    if (parentRef && parentRef.current) {\n      resizeObserver.observe(parentRef.current);\n    }\n  }, [parentRef]);\n\n  useEffect(() => {\n    if (!Object.keys(selected).length && scheduleBracketsValues.some(b => Object.keys(b.slots).length)) {\n      const newSelected = {} as Record<string, IScheduleBracketSlot>;\n      scheduleBracketsValues.forEach(b => {\n        Object.values(b.slots).forEach(s => {\n          newSelected[`schedule_bracket_slot_selection_${s.startTime}`] = s;\n        });\n      });\n      setSelected(newSelected);\n    }\n  }, [selected, scheduleBracketsValues]);\n\n  return <>\n    <Typography variant=\"caption\">Click a bracket, then use up the allotted time by clicking on the time slots. Hold down the mouse button to select multiple slots. There can be leftover slots if they're unneeded.</Typography>\n    <Box ref={parentRef}>\n      <Box sx={{ display: 'flex', alignItems: 'flex-end', flexWrap: 'wrap' }}>\n        {scheduleBracketsValues.map((bracket, i) => {\n          if (!bracket.slots) bracket.slots = {};\n          return <Box key={`bracket-chip${i + 1}new`} m={1}>\n            <Chip\n              label={`#${i + 1} ${getRelativeDuration(bracket.duration, schedule.bracketTimeUnitName, schedule.slotTimeUnitName) - (Object.keys(bracket.slots).length * schedule.slotDuration)} ${schedule.slotTimeUnitName}s (${bracket.multiplier}x)`}\n              sx={{ '&:hover': { cursor: 'pointer' }, borderWidth: '1px', borderStyle: 'solid', borderColor: bracketColors[i], boxShadow: selectedBracket?.id === bracket.id ? 2 : undefined }}\n              onDelete={() => {\n                delete schedule.brackets[bracket.id];\n                setSchedule({ ...schedule, brackets: { ...schedule.brackets } });\n              }}\n              onClick={() => {\n                setSelectedBracket(bracket);\n              }}\n            />\n          </Box>\n        })}\n      </Box>\n\n      <Box onMouseLeave={() => setButtonDown(false)}>\n        <FixedSizeGrid\n          rowCount={selections}\n          columnCount={divisions}\n          rowHeight={30}\n          columnWidth={columnWidth}\n          height={400}\n          width={Math.min(width, columnWidth * divisions)}\n        >\n          {Cell}\n        </FixedSizeGrid>\n      </Box>\n    </Box>\n  </>;\n}"}
{"prompt":"Create a react component ScheduleTimePicker.tsx implementing application types IGroupScheduleDateSlots, IQuote, ITimeUnitNames. Create type ScheduleTimePickerType which implements IGroupScheduleDateSlots. Create function named getSlot implementing IGroupScheduleDateSlots as a parameter or return type. Create function named getQuote implementing IQuote as a parameter or return type. Create a constant variable named quote that uses IQuote. Create a constant variable named bracketTimeUnitName that uses ITimeUnitNames. Create a constant variable named slotTimeUnitName that uses ITimeUnitNames. As a reminder, the application types related to this task and their purposes: IGroupScheduleDateSlotsIQuoteITimeUnitNames.","completion":"import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useParams } from 'react-router';\nimport dayjs from 'dayjs';\nimport { Duration, DurationUnitType } from 'dayjs/plugin/duration';\n\nimport TextField from '@mui/material/TextField';\nimport { TimePicker } from '@mui/x-date-pickers/TimePicker';\n\nimport { getRelativeDuration, IGroupScheduleDateSlots, IQuote, ITimeUnitNames, TimeUnit } from 'awayto/core';\nimport { sh } from 'awayto/hooks';\n\ntype ScheduleTimePickerType = {\n  scheduleId?: string;\n  bracketSlotDate?: dayjs.Dayjs | null;\n  bracketSlotTime?: dayjs.Dayjs | null;\n  firstAvailable?: IGroupScheduleDateSlots & { time: dayjs.Dayjs };\n  onTimeChange?(props: { time: dayjs.Dayjs | null, quote?: IQuote }): void;\n  onTimeAccept?(value: IQuote): void;\n}\n\ndeclare global {\n  interface IProps extends ScheduleTimePickerType {}\n}\n\nexport function ScheduleTimePicker(props: IProps): JSX.Element {\n\n  const { scheduleId, bracketSlotDate, firstAvailable, bracketSlotTime, onTimeChange, onTimeAccept } = props as Required<ScheduleTimePickerType>;\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const [_, { data: dateSlots }] = sh.useLazyGetGroupScheduleByDateQuery();\n  const { data: lookups } = sh.useGetLookupsQuery();\n  const { data: groupSchedules } = sh.useGetGroupSchedulesQuery({ groupName });\n\n  const didInit = useRef(false);\n\n  const { bracketTimeUnitId, slotTimeUnitId } = groupSchedules?.find(gs => gs.id === scheduleId) || {};\n  const bracketTimeUnitName = lookups?.timeUnits.find(u => u.id === bracketTimeUnitId)?.name as ITimeUnitNames;\n  const slotTimeUnitName = lookups?.timeUnits.find(u => u.id === slotTimeUnitId)?.name as ITimeUnitNames;\n  const sessionDuration = Math.round(getRelativeDuration(1, bracketTimeUnitName, slotTimeUnitName));\n  \n  const slotFactors = [] as number[];\n  for (let factor = 1; factor < sessionDuration; factor++) {\n    if (sessionDuration % factor === 0) {\n      slotFactors.push(factor);\n    }\n  }\n\n  const bracketSlotDateDayDiff = useMemo(() => {\n    if (bracketSlotDate) {\n      const startOfDay = bracketSlotDate.startOf('day');\n      return startOfDay.diff(startOfDay.day(0), TimeUnit.DAY);\n    }\n    return 0;\n  }, [bracketSlotDate]);\n\n  function getSlot(time: dayjs.Dayjs, date: string): IGroupScheduleDateSlots | undefined {\n    const timeHour = time.hour();\n    const timeMins = time.minute();\n    const duration = dayjs.duration(0)\n      .add(bracketSlotDateDayDiff, TimeUnit.DAY)\n      .add(timeHour, TimeUnit.HOUR)\n      .add(timeMins, TimeUnit.MINUTE);\n    const [slot] = dateSlots?.filter(s => s.startDate === date && duration.hours() === s.hour && duration.minutes() === s.minute) || [];\n\n    return slot;\n  }\n\n  function getQuote(time: dayjs.Dayjs | null): IQuote | undefined {\n    let quote: IQuote | undefined = undefined;\n    if (time) {\n      const currentSlotDate = bracketSlotDate || firstAvailable.time;\n      const date = currentSlotDate.format('YYYY-MM-DD');\n      const slot = getSlot(time, date);\n      if (slot) {\n        quote = {\n          slotDate: date,\n          startTime: slot.startTime,\n          scheduleBracketSlotId: slot.scheduleBracketSlotId,\n        } as IQuote;\n      }\n    }\n    return quote;\n  }\n\n  useEffect(() => {\n    if (dateSlots?.length && firstAvailable.time && !didInit.current) {\n      didInit.current = true;\n      const quote = getQuote(firstAvailable.time);\n      quote && onTimeAccept(quote);\n    }\n  }, [dateSlots, firstAvailable, didInit.current]);\n\n  return <TimePicker\n    label=\"Time\"\n    value={bracketSlotTime}\n    onChange={time => {\n      const quote = getQuote(time)\n      onTimeChange({ time, quote });\n    }}\n    ampmInClock={true}\n    ignoreInvalidInputs={true}\n    onAccept={time => {\n      const quote = getQuote(time);\n      if (quote) onTimeAccept(quote);\n    }}\n    shouldDisableTime={(time, clockType) => {\n      if (dateSlots?.length) {\n        const currentSlotTime = bracketSlotTime;\n        const currentSlotDate = bracketSlotDate || firstAvailable.time;\n        // Ignore seconds check because final time doesn't need seconds, so this will cause invalidity\n        if ('seconds' === clockType) return false;\n\n        // Create a duration based on the current clock validation check and the days from start of current week\n        let duration: Duration = dayjs.duration(time, clockType).add(bracketSlotDateDayDiff, TimeUnit.DAY);\n\n        // Submitting a new time a two step process, an hour is selected, and then a minute. Upon hour selection, bracketSlotTime is first set, and then when the user selects a minute, that will cause this block to run, so we should add the existing hour from bracketSlotTime such that \"hour + minute\" will give us the total duration, i.e. 4:30 AM = PT4H30M\n        if ('minutes' === clockType && currentSlotTime) {\n          duration = duration.add(currentSlotTime.hour(), TimeUnit.HOUR);\n        }\n\n        // When checking hours, we need to also check the hour + next session time, because shouldDisableTime checks atomic parts of the clock, either hour or minute, but no both. So instead of keeping track of some ongoing clock, we can just check both durations here\n        const checkDurations: Duration[] = [duration];\n        if ('hours' === clockType) {\n          for (const factor of slotFactors) {\n            checkDurations.push(duration.add(factor, slotTimeUnitName as DurationUnitType));\n          }\n        }\n\n        const matches = dateSlots.filter(s => s.startDate === currentSlotDate.format(\"YYYY-MM-DD\") && checkDurations.filter(d => d.hours() === s.hour && d.minutes() === s.minute).length > 0);\n        // Checks that have no existing slots are invalid\n        return !matches.length;\n      }\n      return true;\n    }}\n    renderInput={params => <TextField fullWidth {...params} />}\n  />\n}\n\nexport default ScheduleTimePicker;"}
{"prompt":"Create a react component ManageServiceModal.tsx implementing application types IService. Create interface IProps implementing IService as a property type, method parameter or return type. Implement useState parts named [service, setService] that uses IService. As a reminder, the application types related to this task and their purposes: IService.","completion":"import React, { useState, useCallback } from 'react';\n\nimport Grid from '@mui/material/Grid';\nimport Typography from '@mui/material/Typography';\nimport Card from '@mui/material/Card';\nimport CardContent from '@mui/material/CardContent';\nimport CardActions from '@mui/material/CardActions';\nimport Button from '@mui/material/Button';\nimport TextField from '@mui/material/TextField';\n\nimport { IService } from 'awayto/core';\nimport { sh, useUtil } from 'awayto/hooks';\n\ndeclare global {\n  interface IProps {\n    editService?: IService;\n  }\n}\n\nexport function ManageServiceModal ({ editService, closeModal, ...props }: IProps): JSX.Element {\n\n  const { setSnack } = useUtil();\n\n  const [putService] = sh.usePutServiceMutation();\n  const [postService] = sh.usePostServiceMutation();\n\n  const [service, setService] = useState({\n    name: '',\n    ...editService\n  } as IService);\n  \n  const handleSubmit = useCallback(() => {\n    const { id, name } = service;\n\n    if (!name) {\n      setSnack({ snackType: 'error', snackOn: 'Services must have a name.' });\n      return;\n    }\n\n    (id ? putService : postService)(service).unwrap().then(() => {\n      if (closeModal)\n        closeModal();\n    }).catch(console.error);\n  }, [service]);\n\n  return <>\n    <Card>\n      <CardContent>\n        <Typography variant=\"button\">Manage service</Typography>\n        <Grid container direction=\"row\" spacing={2}>\n          <Grid item xs={12}>\n            <Grid container direction=\"column\" spacing={4} justifyContent=\"space-evenly\" >\n              <Grid item>\n                <Typography variant=\"h6\">Service</Typography>\n              </Grid>\n              <Grid item>\n                <TextField\n                  fullWidth\n                  autoFocus\n                  id=\"name\"\n                  label=\"Name\"\n                  name=\"name\"\n                  value={service.name}\n                  onKeyDown={e => {\n                    if ('Enter' === e.key) {\n                      handleSubmit();\n                    }\n                  }}\n                  onChange={e => setService({ ...service, name: e.target.value })} />\n              </Grid>\n            </Grid>\n          </Grid>\n        </Grid>\n      </CardContent>\n      <CardActions>\n        <Grid container justifyContent=\"space-between\">\n          <Button onClick={closeModal}>Cancel</Button>\n          <Button onClick={handleSubmit}>Submit</Button>\n        </Grid>\n      </CardActions>\n    </Card>\n  </>\n}\n\nexport default ManageServiceModal;"}
{"prompt":"Create a react component ManageServices.tsx implementing application types IService. Implement useState parts named [service, setService] that uses IService. As a reminder, the application types related to this task and their purposes: IService.","completion":"import React, { useState, useMemo, Suspense } from 'react';\nimport dayjs from 'dayjs';\nimport { useNavigate, useParams } from 'react-router';\n\nimport Box from '@mui/material/Box';\nimport Typography from '@mui/material/Typography';\nimport Button from '@mui/material/Button';\nimport Dialog from '@mui/material/Dialog';\nimport Tooltip from '@mui/material/Tooltip';\n\nimport DomainAddIcon from '@mui/icons-material/DomainAdd';\nimport CreateIcon from '@mui/icons-material/Create';\nimport DeleteIcon from '@mui/icons-material/Delete';\n\nimport { IService } from 'awayto/core';\nimport { useGrid, sh, useUtil } from 'awayto/hooks';\n\nimport ManageServiceModal from './ManageServiceModal';\n\nexport function ManageServices(props: IProps): JSX.Element {\n\n  const { groupName } = useParams();\n  if (!groupName) return <></>;\n\n  const { openConfirm } = useUtil();\n\n  const [deleteGroupService] = sh.useDeleteGroupServiceMutation();\n\n  const { data: groupServices, refetch: getGroupServices } = sh.useGetGroupServicesQuery({ groupName });\n  \n  const navigate = useNavigate();\n  const [service, setService] = useState<IService>();\n  const [selected, setSelected] = useState<string[]>([]);\n  const [dialog, setDialog] = useState('');\n\n  const actions = useMemo(() => {\n    const { length } = selected;\n    const acts = length == 1 ? [\n      <Tooltip key={'manage_service'} title=\"Edit\">\n        <Button onClick={() => {\n          setService(groupServices?.find(gs => gs.id === selected[0]));\n          setDialog('manage_service');\n          setSelected([]);\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Edit</Typography>\n          <CreateIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ] : [];\n\n    return [\n      ...acts,\n      <Tooltip key={'delete_service'} title=\"Delete\">\n        <Button onClick={() => {\n          openConfirm({\n            isConfirming: true,\n            confirmEffect: 'Are you sure you want to delete these services? This cannot be undone.',\n            confirmAction: () => {\n              deleteGroupService({ groupName, ids: selected.join(',') }).unwrap().then(() => {\n                void getGroupServices();\n                setSelected([]);\n              }).catch(console.error);\n            }\n          });\n        }}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Delete</Typography>\n          <DeleteIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n    ]\n  }, [selected]);\n\n  const ServiceGrid = useGrid({\n    rows: groupServices || [],\n    columns: [\n      { flex: 1, headerName: 'Name', field: 'name' },\n      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\n    ],\n    selected,\n    onSelected: selection => setSelected(selection as string[]),\n    toolbar: () => <>\n      <Typography variant=\"button\">Services:</Typography>\n      <Tooltip key={'create_service'} title=\"Create\">\n        <Button onClick={() => navigate('/service')}>\n          <Typography variant=\"button\" sx={{ display: { xs: 'none', md: 'flex' } }}>Create</Typography>\n          <DomainAddIcon sx={{ fontSize: { xs: '24px', md: '12px' } }} />\n        </Button>\n      </Tooltip>\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\n    </>\n  })\n\n  return <>\n    <Dialog scroll=\"paper\" open={dialog === 'manage_service'} fullWidth maxWidth=\"sm\">\n      <Suspense>\n        <ManageServiceModal {...props} editService={service} closeModal={() => {\n          setDialog('')\n          void getGroupServices();\n        }} />\n      </Suspense>\n    </Dialog>\n    <ServiceGrid />\n  </>\n}\n\nexport default ManageServices;"}
{"prompt":"Create a react component ServiceHome.tsx implementing application types IAssist, IServiceTier, IService. Create a constant variable named { promptResult } that uses IAssist. Create react component named ServiceHome implementing IAssist as a parameter or return type. Implement useState parts named [newServiceTier, setNewServiceTier] that uses IServiceTier. Create react component named ServiceHome implementing IServiceTier as a parameter or return type. Implement useState parts named [newService, setNewService] that uses IService. Create react component named ServiceHome implementing IService as a parameter or return type. As a reminder, the application types related to this task and their purposes: IAssistIServiceTierIService.","completion":"import React, { useEffect, useMemo, useState } from 'react';\n\nimport FormHelperText from '@mui/material/FormHelperText';\nimport TextField from '@mui/material/TextField';\nimport Slider from '@mui/material/Slider';\nimport Box from '@mui/material/Box';\nimport Typography from '@mui/material/Typography';\nimport MenuItem from '@mui/material/MenuItem';\nimport Card from '@mui/material/Card';\nimport CardContent from '@mui/material/CardContent';\nimport CardActionArea from '@mui/material/CardActionArea';\nimport CardHeader from '@mui/material/CardHeader';\nimport Grid from '@mui/material/Grid';\nimport Chip from '@mui/material/Chip';\n\nimport { IService, IServiceTier, IPrompts, IAssist } from 'awayto/core';\nimport { useComponents, useStyles, sh, useUtil } from 'awayto/hooks';\n\nconst serviceSchema = {\n  name: '',\n  cost: '',\n  formId: ''\n};\n\nconst serviceTierSchema = {\n  name: '',\n  multiplier: '1.00',\n  formId: ''\n};\n\nconst validCost = function (cost: string): boolean {\n  return /(^$|^\\$?\\d+(,\\d{3})*(\\.\\d*)?$)/.test(cost);\n}\n\n// In theory there's no difference between theory and practice, but in practice there is.\n\nexport function ServiceHome(props: IProps): JSX.Element {\n  const classes = useStyles();\n\n  const { setSnack } = useUtil();\n\n  const { SelectLookup } = useComponents();\n\n  const [postServiceAddon] = sh.usePostServiceAddonMutation();\n  const [postGroupServiceAddon] = sh.usePostGroupServiceAddonMutation();\n  const [deleteGroupServiceAddon] = sh.useDeleteGroupServiceAddonMutation();\n  const [postService] = sh.usePostServiceMutation();\n  const [postGroupService] = sh.usePostGroupServiceMutation();\n  const [getGroupFormById] = sh.useLazyGetGroupFormByIdQuery();\n  const [getGroupServices] = sh.useLazyGetGroupServicesQuery();\n  const [getPrompt] = sh.useLazyGetPromptQuery();\n\n  const { data : profile } = sh.useGetUserProfileDetailsQuery();\n\n  const [group, setGroup] = useState(Object.values(profile?.groups || {})[0]);\n\n  const { data: groupServiceAddons, refetch: getGroupServiceAddons } = sh.useGetGroupServiceAddonsQuery({ groupName: group.name });\n  const { data: groupForms } = sh.useGetGroupFormsQuery({ groupName: group.name });\n\n  const [newService, setNewService] = useState({ ...serviceSchema, tiers: {} } as IService);\n  const [newServiceTier, setNewServiceTier] = useState({ ...serviceTierSchema, addons: {} } as IServiceTier);\n  const [serviceTierAddonIds, setServiceTierAddonIds] = useState<string[]>([]);\n\n  const [serviceSuggestions, setServiceSuggestions] = useState('');\n  const [tierSuggestions, setTierSuggestions] = useState('');\n  const [featureSuggestions, setFeatureSuggestions] = useState('');\n\n  const groupsValues = useMemo(() => Object.values(profile?.groups || {}), [profile]);\n  \n  useEffect(() => {\n    async function go() {\n      if (groupsValues.length) {\n        const gr = groupsValues[0];\n        const { promptResult } = await getPrompt({ id: IPrompts.SUGGEST_SERVICE, prompt: gr.purpose } as IAssist).unwrap();\n        if (promptResult.length) setServiceSuggestions(promptResult.join(', '));\n        setGroup(gr);\n      }\n    }\n    void go();\n  }, [groupsValues]);\n\n  return <Grid container spacing={2}>\n\n    <Grid item xs={12}>\n      <Card style={{ display: 'flex', flexDirection: 'column' }}>\n        <CardHeader\n          title=\"Create Service\"\n          subheader=\"Services are the functions of your organization. Each service has a set of tiers and features. As well, a cost may be associated with the service. If there is a cost, tiers can be used to provide a higher level of service at a higher cost, using the multiplier. Features can be added to each tier as necessary.\"\n          action={\n            <TextField\n              select\n              value={group.id}\n              label=\"Group\"\n              onChange={e => setGroup(groupsValues.filter(g => g.id === e.target.value)[0])}\n            >\n              {groupsValues.map(group => <MenuItem key={`group-select${group.id}`} value={group.id}>{group.name.replaceAll('_', ' ')}</MenuItem>)}\n            </TextField>\n          }\n        />\n        <CardContent>\n\n          <Grid container>\n            <Grid item xs={12} md={6}>\n              <Box mb={4}>\n                <TextField\n                  fullWidth\n                  label=\"Name\"\n                  value={newService.name}\n                  onChange={e => setNewService({ ...newService, name: e.target.value })}\n                  onBlur={() => {\n                    // When this service name changes, let's get a new prompt for tier name suggestions\n                    getPrompt({ id: IPrompts.SUGGEST_TIER, prompt: `${newService.name.toLowerCase()} at ${group.name.replaceAll('_', ' ')}`} as IAssist).unwrap().then(({ promptResult }) => {\n                      if (promptResult.length) setTierSuggestions(promptResult.join(', '));\n                    }).catch(console.error);\n                  }}\n                  helperText={`${serviceSuggestions ? `AI: ${serviceSuggestions}` : 'Ex: Website Hosting, Yard Maintenance, Automotive Repair'}`}\n                />\n              </Box>\n\n              <Box mb={4}>\n                <TextField fullWidth label=\"Cost\" helperText=\"Optional.\" value={newService.cost || ''} onChange={e => validCost(e.target.value) && setNewService({ ...newService, cost: /\\.\\d\\d/.test(e.target.value) ? parseFloat(e.target.value).toFixed(2) : e.target.value })} />\n              </Box>\n\n              <Box>\n                <TextField\n                  select\n                  fullWidth\n                  value={newService.formId}\n                  label=\"Form\"\n                  helperText=\"Optional.\"\n                  onChange={async e => {\n                    const form = await getGroupFormById({ groupName: group.name, formId: e.target.value }).unwrap();\n                    if (form) {\n                      setNewService({ ...newService, formId: form.id })\n                    }\n                  }}\n                >\n                  {groupForms?.map(form => <MenuItem key={`form-version-select${form.id}`} value={form.id}>{form.name}</MenuItem>)}\n                </TextField>\n              </Box>\n            </Grid>\n          </Grid>\n        </CardContent>\n      </Card>\n    </Grid>\n\n    <Grid item xs={12}>\n      <Card style={{ display: 'flex', flexDirection: 'column' }}>\n        <CardHeader title=\"Add Tier\" subheader='Some services divide their offering up into tiers. For example, a \"Basic\" tier may have some basic features, and the \"Advanced\" tier has more features. You should have at least 1 tier which describes the features offered by your service. During booking, your users will see this information.' />\n\n        <CardContent sx={{ padding: '0 15px' }}>\n          <Grid container>\n            <Grid item xs={12} md={6}>\n              <Box mb={4}>\n                {/* <Typography variant=\"body2\">Some services divide their offering up into tiers. For example, a \"Basic\" tier may some basic features, and the \"Advanced\" tier has more features. If your service has no tier, you can ignore this section and we'll create a standard tier for you.</Typography> */}\n                <TextField\n                  fullWidth\n                  label=\"Name\"\n                  value={newServiceTier.name}\n                  onBlur={() => {\n                    // When this tier name changes, let's get a new prompt for feature name suggestions\n                    getPrompt({ id: IPrompts.SUGGEST_FEATURE, prompt: `${newServiceTier.name} ${newService.name}`} as IAssist).unwrap().then(({ promptResult }) => {\n                      if (promptResult.length) setFeatureSuggestions(promptResult.join(', '));\n                    }).catch(console.error);\n                  }}\n                  onChange={e => setNewServiceTier({ ...newServiceTier, name: e.target.value })}\n                  helperText={`${tierSuggestions.length ? `AI: ${tierSuggestions}` : 'Ex: Basic, Mid-Tier, Advanced'}`}\n                />\n              </Box>\n\n              {group.name && <Box mb={4} flexDirection=\"column\" sx={{ display: 'flex', alignItems: 'baseline' }}>\n                <SelectLookup\n                  multiple\n                  lookupName='Feature'\n                  lookups={groupServiceAddons}\n                  lookupValue={serviceTierAddonIds}\n                  parentUuid={group.name}\n                  parentUuidName='groupName'\n                  lookupChange={(val: string[]) => {\n                    const gsa = groupServiceAddons?.filter(s => val.includes(s.id)).map(s => s.id);\n                    if (gsa) setServiceTierAddonIds(gsa);\n                  }}\n                  createAction={postServiceAddon}\n                  deleteAction={deleteGroupServiceAddon}\n                  deleteActionIdentifier='serviceAddonId'\n                  refetchAction={getGroupServiceAddons}\n                  attachAction={postGroupServiceAddon}\n                  attachName='serviceAddonId'\n                  {...props}\n                />\n                <Box pl={2}>\n                  <FormHelperText>{featureSuggestions.length ? `AI: ${featureSuggestions}` : 'Ex: 24-Hour Support, Premium Access, Domain Registration, 20GB Storage'}</FormHelperText>\n                </Box>\n              </Box>}\n\n              <Box mb={4}>\n                <TextField\n                  select\n                  fullWidth\n                  value={newServiceTier.formId}\n                  label=\"Form\"\n                  helperText=\"Optional.\"\n                  onChange={async e => {\n                    const form = await getGroupFormById({ groupName: group.name, formId: e.target.value }).unwrap();\n                    if (form) {\n                      setNewServiceTier({ ...newServiceTier, formId: form.id })\n                    }\n                  }}\n                >\n                  {groupForms?.map(form => <MenuItem key={`form-version-select${form.id}`} value={form.id}>{form.name}</MenuItem>)}\n                </TextField>\n              </Box>\n\n              <Box>\n                <Typography variant=\"h6\">Multiplier</Typography>\n                <Box sx={{ display: 'flex', alignItems: 'baseline' }}>\n                  <span>{newServiceTier.multiplier}x <span>&nbsp;</span> &nbsp;</span>\n                  <Slider value={parseFloat(newServiceTier.multiplier)} onChange={(e, val) => setNewServiceTier({ ...newServiceTier, multiplier: parseFloat(val.toString()).toFixed(2) })} step={.01} min={1} max={5} />\n                </Box>\n              </Box>\n            </Grid>\n          </Grid>\n        </CardContent>\n        <CardActionArea onClick={() => {\n          if (newServiceTier.name && serviceTierAddonIds.length) {\n            const created = (new Date()).getTime().toString();\n            newServiceTier.id = created;\n            newServiceTier.createdOn = created;\n            newServiceTier.order = Object.keys(newService.tiers).length + 1;\n            newServiceTier.addons = serviceTierAddonIds.reduce((m, id, i) => {\n              const addon = groupServiceAddons?.find(gs => gs.id === id) || { name: '' };\n              return {\n                ...m,\n                [id]: addon && {\n                  id,\n                  name: addon.name,\n                  order: i + 1\n                }\n              }\n            }, {});\n            newService.tiers[newServiceTier.id] = newServiceTier;\n            setNewServiceTier({ ...serviceTierSchema, addons: {} } as IServiceTier);\n            setServiceTierAddonIds([]);\n          } else {\n            void setSnack({ snackOn: 'Provide a tier name and at least 1 feature.', snackType: 'info' });\n          }\n        }}>\n          <Box m={2} sx={{ display: 'flex', alignItems: 'center' }}>\n            <Typography color=\"secondary\" variant=\"button\">Add Tier to Service</Typography>\n          </Box>\n        </CardActionArea>\n      </Card>\n    </Grid>\n\n    <Grid item xs={12}>\n      <Card>\n        <CardContent sx={{ padding: '0 15px' }}>\n          <Box>\n            <Typography variant=\"h6\">Tiers</Typography>\n            <Typography variant=\"body2\">The order that tiers appear here is the order they will be listed during booking.</Typography>\n            {Object.keys(newService.tiers).length > 0 && <Box mt={4} sx={{ display: 'flex', alignItems: 'flex-end', flexWrap: 'wrap' }}>\n              {Object.values(newService.tiers).sort((a, b) => new Date(a.createdOn).getTime() - new Date(b.createdOn).getTime()).map((tier, i) => {\n                const addons = Object.values(tier.addons);\n                return <Box key={`service-tier-chip${i + 1}new`} m={1}><Chip classes={{ root: classes.chipRoot, label: classes.chipLabel }} label={<Typography>{`#${i + 1} ` + tier.name + ' (' + tier.multiplier + 'x): ' + (addons.length ? addons.map(a => a.name).join(', ') : 'No features.')}</Typography>} onDelete={() => {\n                  delete newService.tiers[tier.id];\n                  setNewService({ ...newService, tiers: { ...newService.tiers } });\n                }} /></Box>\n              })}\n            </Box>}\n          </Box>\n        </CardContent>\n      </Card>\n    </Grid>\n\n    <Grid item xs={12}>\n      <Card>\n        <CardActionArea onClick={async () => {\n          if (newService.name && group.name && Object.keys(newService.tiers)?.length) {\n            const postedService = await postService({ ...newService }).unwrap();\n            await postGroupService({ serviceId: postedService.id, groupName: group.name }).unwrap();\n            await getGroupServices({ groupName: group.name }).unwrap();\n            setSnack({ snackOn: `Successfully added ${newService.name} to ${group.name.replaceAll('_', ' ')}`, snackType: 'info' });\n            setNewService({ ...serviceSchema, tiers: {} } as IService);\n            setServiceTierAddonIds([]);\n          } else {\n            void setSnack({ snackOn: 'Provide the service name, cost and at least 1 tier.', snackType: 'info' });\n          }\n        }}>\n          <Box m={2} sx={{ display: 'flex' }}>\n            <Typography color=\"secondary\" variant=\"button\">Create Service</Typography>\n          </Box>\n        </CardActionArea>\n      </Card>\n    </Grid>\n  </Grid>\n}\n\nexport const roles = [];\n\nexport default ServiceHome;"}
{"prompt":"Create a react component ManageUserModal.tsx implementing application types IGroupUser, IUserProfile. Implement useState parts named [profile, setProfile] that uses IGroupUser. Create interface IProps implementing IUserProfile as a property type, method parameter or return type. As a reminder, the application types related to this task and their purposes: IGroupUserIUserProfile.","completion":"import React, { useCallback, useEffect, useState } from 'react';\r\nimport { useParams } from 'react-router';\r\n\r\nimport Grid from '@mui/material/Grid';\r\nimport Card from '@mui/material/Card';\r\nimport CardHeader from '@mui/material/CardHeader';\r\nimport CardContent from '@mui/material/CardContent';\r\nimport CardActions from '@mui/material/CardActions';\r\nimport MenuItem from '@mui/material/MenuItem';\r\nimport Typography from '@mui/material/Typography';\r\nimport FormControl from '@mui/material/FormControl';\r\nimport Input from '@mui/material/Input';\r\nimport FormHelperText from '@mui/material/FormHelperText';\r\nimport Button from '@mui/material/Button';\r\nimport InputLabel from '@mui/material/InputLabel';\r\nimport TextField from '@mui/material/TextField';\r\nimport InputAdornment from '@mui/material/InputAdornment';\r\n\r\nimport { IGroupUser, IUserProfile, passwordGen } from 'awayto/core';\r\nimport { sh } from 'awayto/hooks';\r\n\r\ndeclare global {\r\n  interface IProps {\r\n    editUser?: IUserProfile;\r\n  }\r\n}\r\n\r\nexport function ManageUserModal({ editUser, closeModal }: IProps): JSX.Element {\r\n\r\n  const { groupName } = useParams();\r\n  if (!groupName) return <></>;\r\n\r\n  const { data: groupRoles } = sh.useGetGroupRolesQuery({ groupName });\r\n\r\n  const [getGroupUsers] = sh.useLazyGetGroupUsersQuery();\r\n  const [getGroupUserById] = sh.useLazyGetGroupUserByIdQuery();\r\n  const [putGroupUser] = sh.usePutGroupUserMutation();\r\n\r\n  const [password, setPassword] = useState('');\r\n  const [profile, setProfile] = useState({\r\n    firstName: '',\r\n    lastName: '',\r\n    email: '',\r\n    username: '',\r\n    roleId: '',\r\n    roleName: '',\r\n    ...editUser\r\n  } as IGroupUser);\r\n\r\n  useEffect(() => {\r\n    async function go() {\r\n      if (groupName && editUser?.id && !profile.roleId) {\r\n        const user = await getGroupUserById({ groupName, userId: editUser.id }).unwrap();\r\n        setProfile({ ...profile, ...user });\r\n      }\r\n    }\r\n    void go();\r\n  }, [editUser, profile]);\r\n\r\n  const handlePassword = useCallback(({ target: { value } }: React.ChangeEvent<HTMLTextAreaElement>) => setPassword(value), [])\r\n  const handleProfile = useCallback(({ target: { name, value } }: React.ChangeEvent<HTMLTextAreaElement>) => setProfile({ ...profile, [name]: value }), [profile])\r\n\r\n  const handleSubmit = useCallback(async () => {\r\n    if (editUser?.id) {\r\n      const { id, roleId } = profile;\r\n      const { name } = groupRoles?.find(gr => gr.id === roleId) || {};\r\n      if (name) {\r\n        await putGroupUser({ groupName, userId: id, roleId, roleName: name }).unwrap();\r\n        await getGroupUsers({ groupName }).unwrap();\r\n        if (closeModal)\r\n          closeModal();\r\n      }\r\n    }\r\n    // async function submitUser() {\r\n    //   let user = profile as IUserProfile;\r\n    //   const { id, sub } = user;\r\n\r\n    //   const groupRoleKeys = Object.keys(userGroupRoles);\r\n\r\n    //   if (!groupRoleKeys.length)\r\n    //     return act(SET_SNACK, { snackType: 'error', snackOn: 'Group roles must be assigned.' });\r\n\r\n    //   user.groups = groupRoleKeys // { \"g1\": [...], \"g2\": [...] } => [\"g1\", \"g2\"];\r\n    //     .reduce((memo, key) => {\r\n    //       if (userGroupRoles[key].length) { // [...].length\r\n    //         const group = { ...groups?.find(g => g.name == key) } as IGroup; // Get a copy from repository\r\n    //         if (group.roles) {\r\n    //           group.roles = group.roles.filter(r => userGroupRoles[key].includes(r.name)) // Filter roles\r\n    //           memo.push(group);\r\n    //         }\r\n    //       }\r\n    //       return memo;\r\n    //     }, [] as IGroup[]);\r\n\r\n    //   // User Update - 3 Scenarios\r\n    //   // User-Originated - A user signed up in the wild, created a cognito account, has not done anything to \r\n    //   //                  generate an application account, and now an admin is generating one\r\n    //   // Admin-Originated - A user being created by an admin in the manage area\r\n    //   // Admin-Updated - A user being updated by an admin in the manage area\r\n\r\n    //   // If there's already a sub, PUT/manage/users will update the sub in cognito;\r\n    //   // else we'll POST/manage/users/sub for a new sub\r\n    //   user = await api(sub ? PUT_MANAGE_USERS : POST_MANAGE_USERS_SUB, true, sub ? user : { ...user, password }) as IUserProfile;\r\n\r\n    //   // Add user to application db if needed no user.id\r\n    //   if (!id)\r\n    //     user = await api(sub ? POST_MANAGE_USERS_APP_ACCT : POST_MANAGE_USERS, true, user) as IUserProfile;\r\n\r\n    //   if (closeModal)\r\n    //     closeModal();\r\n    // }\r\n\r\n    // void submitUser();\r\n  }, [profile, password]);\r\n\r\n  const passwordGenerator = useCallback(() => {\r\n    setPassword(passwordGen());\r\n  }, []);\r\n\r\n  return <>\r\n    <Card>\r\n      <CardHeader\r\n        title={`Manage ${profile.username}`}\r\n        subheader={`${profile.firstName} ${profile.lastName}`}\r\n      />\r\n      <CardContent>\r\n        <Grid container direction=\"row\" spacing={2} justifyContent=\"space-evenly\">\r\n          <Grid item xs={12}>\r\n            <Grid container direction=\"column\" spacing={4} justifyContent=\"space-evenly\" >\r\n\r\n              <Grid item>\r\n                <TextField select fullWidth id=\"roleId\" label=\"Role\" value={profile.roleId} name=\"roleId\" onChange={handleProfile}>\r\n                  {groupRoles?.map(role => <MenuItem key={`${role.id}_user_profile_role_select`} value={role.id}>{role.name}</MenuItem>)}\r\n                </TextField>\r\n              </Grid>\r\n\r\n              {!editUser && (\r\n                <Grid item xs>\r\n                  <Grid container direction=\"column\" justifyContent=\"space-evenly\" spacing={4}>\r\n                    <Grid item xs={12}>\r\n                      <Typography variant=\"h6\">Account</Typography>\r\n                    </Grid>\r\n                    <Grid item xs={12}>\r\n                      <TextField fullWidth id=\"username\" label=\"Username\" value={profile.username} name=\"username\" onChange={handleProfile} />\r\n                    </Grid>\r\n                    <Grid item xs={12}>\r\n                      <FormControl fullWidth>\r\n                        <InputLabel htmlFor=\"password\">Password</InputLabel>\r\n                        <Input type=\"text\" id=\"password\" aria-describedby=\"password\" value={password} onChange={handlePassword}\r\n                          endAdornment={\r\n                            <InputAdornment position=\"end\">\r\n                              <Button onClick={passwordGenerator} style={{ backgroundColor: 'transparent' }}>Generate</Button>\r\n                            </InputAdornment>\r\n                          }\r\n                        />\r\n                        <FormHelperText>Password must be at least 8 characters and contain 1 uppercase, lowercase, number, and special (e.g. @^$!*) character. The user must change this passowrd upon logging in for the first time.</FormHelperText>\r\n                      </FormControl>\r\n                    </Grid>\r\n                  </Grid>\r\n                </Grid>\r\n              )}\r\n            </Grid>\r\n          </Grid>\r\n        </Grid>\r\n      </CardContent>\r\n      <CardActions>\r\n\r\n        <Grid container justifyContent=\"space-between\">\r\n          <Button onClick={closeModal}>Cancel</Button>\r\n          <Button onClick={handleSubmit}>{profile.sub ? 'update' : 'create'}</Button>\r\n        </Grid>\r\n      </CardActions>\r\n    </Card>\r\n  </>\r\n}\r\n\r\nexport default ManageUserModal;"}
{"prompt":"Create a react component ManageUsers.tsx implementing application types IGroupRole, IGroupUser. Implement useState parts named [user, setUser] that uses IGroupUser. Create a constant variable named UserGrid that uses IGroupUser. As a reminder, the application types related to this task and their purposes: IGroupRoleIGroupUser.","completion":"import React, { useEffect, useState, useMemo, Suspense } from 'react';\r\nimport dayjs from 'dayjs';\r\n\r\nimport Box from '@mui/material/Box';\r\nimport Typography from '@mui/material/Typography';\r\nimport IconButton from '@mui/material/IconButton';\r\nimport Dialog from '@mui/material/Dialog';\r\n\r\nimport CreateIcon from '@mui/icons-material/Create';\r\n\r\nimport { IGroupUser, IActionTypes, IGroupRole } from 'awayto/core';\r\nimport { sh, useGrid } from 'awayto/hooks';\r\n\r\nimport ManageUserModal from './ManageUserModal';\r\nimport { useParams } from 'react-router';\r\n\r\nexport function ManageUsers(props: IProps): JSX.Element {\r\n  \r\n  const { groupName } = useParams();\r\n  if (!groupName) return <></>;\r\n\r\n  const { data: groupUsers } = sh.useGetGroupUsersQuery({ groupName });\r\n\r\n  const [user, setUser] = useState<IGroupUser>();\r\n  const [selected, setSelected] = useState<string[]>([]);\r\n  const [dialog, setDialog] = useState('');\r\n\r\n  const actions = useMemo(() => {\r\n    const { length } = selected;\r\n    const actions = length == 1 ? [\r\n      <IconButton key={'manage_user'} onClick={() => {\r\n        setUser(groupUsers?.find(gu => gu.id === selected[0]));\r\n        setDialog('manage_user');\r\n        setSelected([]);\r\n      }}>\r\n        <CreateIcon />\r\n      </IconButton>\r\n    ] : [];\r\n\r\n    return [\r\n      ...actions,\r\n      // <IconButton key={'lock_user'} onClick={() => {\r\n      //   api(lockUsersAction, { users: selected.map(u => ({ username: u.username })) }, { load: true });\r\n      //   setToggle(!toggle);\r\n      // }}><LockIcon /></IconButton>,\r\n      // <IconButton key={'unlock_user'} onClick={() => {\r\n      //   api(unlockUsersAction, { users: selected.map(u => ({ username: u.username })) }, { load: true });\r\n      //   setToggle(!toggle);\r\n      // }}><LockOpenIcon /></IconButton>,\r\n    ];\r\n  }, [selected]);\r\n\r\n  const UserGrid = useGrid<IGroupUser>({\r\n    rows: groupUsers || [],\r\n    columns: [\r\n      { flex: 1, headerName: 'Username', field: 'username' },\r\n      { flex: 1, headerName: 'First Name', field: 'firstName' },\r\n      { flex: 1, headerName: 'Last Name', field: 'lastName' },\r\n      { flex: 1, headerName: 'Role', field: 'roleName' },\r\n      { field: 'createdOn', headerName: 'Created', flex: 1, renderCell: ({ row }) => dayjs().to(dayjs.utc(row.createdOn)) }\r\n    ],\r\n    selected,\r\n    onSelected: selection => setSelected(selection as string[]),\r\n    toolbar: () => <>\r\n      <Typography variant=\"button\">Users</Typography>\r\n      {!!selected.length && <Box sx={{ flexGrow: 1, textAlign: 'right' }}>{actions}</Box>}\r\n    </>\r\n  });\r\n\r\n  return <>\r\n    <Dialog open={dialog === 'manage_user'} fullWidth maxWidth=\"xs\">\r\n      <Suspense>\r\n        <ManageUserModal {...props} editUser={user} closeModal={() => setDialog('')} />\r\n      </Suspense>\r\n    </Dialog>\r\n    \r\n    <UserGrid />\r\n  </>\r\n}\r\n\r\nexport default ManageUsers;"}