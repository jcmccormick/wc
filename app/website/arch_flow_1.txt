Respond with only a period until I provide the contents of a TSX react file, ManageFeedbacks.tsx. The files depict the architecture of a web app API and usage in a react component. Examine the structure of the API and then design and develop a unified testing framework capable of testing all layers of the application, including examples of testing arbitrary functionality in a utility file.

// group_feedback.ts
import { Extend } from '../util';
import { ApiHandler, ApiOptions, EndpointType, siteApiHandlerRef, siteApiRef } from './api';
import { IFeedback } from './feedback';
import { IGroup } from './group';

const groupFeedbackApi = {
  postGroupFeedback: {
    kind: EndpointType.MUTATION,
    url: 'feedback',
    method: 'POST',
    opts: {} as ApiOptions,
    queryArg: { message: '' as string, groupName: '' as string },
    resultType: { success: true as boolean }
  },
  getGroupFeedback: {
    kind: EndpointType.QUERY,
    url: 'feedback/:groupName',
    method: 'GET',
    opts: {} as ApiOptions,
    queryArg: { groupName: '' as string },
    resultType: [] as IFeedback[]
  },
} as const;

const groupFeedbackApiHandlers: ApiHandler<typeof groupFeedbackApi> = {
  postGroupFeedback: async props => {
    const { message, groupName } = props.event.body;

    const { id: groupId } = await props.tx.one<IGroup>(`
      SELECT id FROM dbtable_schema.groups
      WHERE name = $1
    `, [groupName]);

    await props.tx.none(`
      INSERT INTO dbtable_schema.group_feedback (message, group_id, created_sub, created_on)
      VALUES ($1, $2::uuid, $3::uuid, $4)
    `, [message, groupId, props.event.userSub, new Date()]);

    return { success: true };
  },
  getGroupFeedback: async props => {
    const { groupName } = props.event.pathParameters;

    const { id: groupId } = await props.db.one<IGroup>(`
      SELECT id FROM dbtable_schema.groups
      WHERE name = $1
    `, [groupName]);

    const feedback = await props.db.manyOrNone<IFeedback>(`
      SELECT f.id, f.message, f.created_on as "createdOn", u.username
      FROM dbtable_schema.group_feedback f
      JOIN dbtable_schema.users u ON u.sub = f.created_sub
      WHERE f.group_id = $1
      ORDER BY f.created_on DESC
    `, [groupId]);

    return feedback;
  },
} as const;

type GroupFeedbackApi = typeof groupFeedbackApi;

type GroupFeedbackApiHandler = typeof groupFeedbackApiHandlers;

declare module './api' {
  interface SiteApiRef extends Extend<GroupFeedbackApi> { }
  interface SiteApiHandlerRef extends Extend<GroupFeedbackApiHandler> { }
}

Object.assign(siteApiRef, groupFeedbackApi);
Object.assign(siteApiHandlerRef, groupFeedbackApiHandlers);

###
// store.ts
import createDebounce from 'redux-debounced';
import logger from 'redux-logger';
import thunk from 'redux-thunk';

import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import { fetchBaseQuery, SkipToken } from '@reduxjs/toolkit/dist/query';
import { configureStore, AnyAction, createSlice, Middleware, Reducer, Store, ThunkDispatch } from '@reduxjs/toolkit';
import { createApi, setupListeners } from '@reduxjs/toolkit/query/react';

import { QueryDefinition, MutationDefinition } from '@reduxjs/toolkit/dist/query/endpointDefinitions';
import { MutationTrigger, LazyQueryTrigger, UseLazyQueryLastPromiseInfo, UseQuery, UseLazyQuery, UseMutation } from '@reduxjs/toolkit/dist/query/react/buildHooks';

import { EndpointType, RemoveNever, ReplaceVoid, siteApiRef, SiteApiRef, utilConfig } from 'awayto/core';

import { QueryArgFrom, ResultTypeFrom } from '@reduxjs/toolkit/dist/query/endpointDefinitions';

export const getQueryAuth = fetchBaseQuery({
  baseUrl: '/api',
  prepareHeaders: headers => {
    const token = localStorage.getItem('kc_token');
    if (token) {
      headers.set('Authorization', `Bearer ${token}`);
    }
    return headers;
  }
});

export type SiteBaseEndpoint = typeof getQueryAuth;
export type SiteQuery<TQueryArg, TResultType> = QueryDefinition<TQueryArg, SiteBaseEndpoint, 'Root', TResultType, 'api'>;
export type SiteMutation<TQueryArg, TResultType> = MutationDefinition<TQueryArg, SiteBaseEndpoint, 'Root', TResultType, 'api'>;

export type { MutationTrigger };
/**
 * The following collection of types tracks a custom set of react hooks which are adapted from the hooks autogenerated by RTK-Query.
 * Some of the base types are directly adapted from, i.e. https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usequery which should be used as a reference.
 */

type UseQueryOptions<R> = {
  pollingInterval?: number
  refetchOnReconnect?: boolean
  refetchOnFocus?: boolean
  skip?: boolean
  refetchOnMountOrArgChange?: boolean | number
  selectFromResult?: (result: R) => R
};

type UseLazyQueryOptions<R> = {
  pollingInterval?: number
  refetchOnReconnect?: boolean
  refetchOnFocus?: boolean
  selectFromResult?: (result: R) => R
}

type UseMutationStateOptions<R> = {
  selectFromResult?: (result: R) => R
  fixedCacheKey?: string
}

type CommonHookResult<T> = {
  // Base query state
  originalArgs?: unknown // Arguments passed to the query

  error?: unknown // Error result if present
  requestId?: string // A string generated by RTK Query
  endpointName?: string // The name of the given endpoint for the query

  startedTimeStamp?: number // Timestamp for when the query was initiated
  fulfilledTimeStamp?: number // Timestamp for when the query was completed

  // Derived request status booleans
  isUninitialized: boolean // Query has not started yet.
  isLoading: boolean // Query is currently loading for the first time. No data yet.
  isFetching: boolean // Query is currently fetching, but might have data from an earlier request.
  isSuccess: boolean // Query has data from a successful load.
  isError: boolean // Query is currently in an "error" state.
} & T extends unknown[] ? { data: T } : { data: Partial<T> };


type UseQueryResult<T> = CommonHookResult<T> & {
  currentData: T
  refetch: () => void
};

type UseLazyQueryResult<T> = CommonHookResult<T> & {
  currentData: T;
};

type UseMutationResult<T> = CommonHookResult<T> & {
  reset: () => void
};

type CustomUseQuery<D extends QueryDefinition<QueryArgFrom<D>, SiteBaseEndpoint, 'Root', ResultTypeFrom<D>, 'api'>> = (
  arg: QueryArgFrom<D> | SkipToken,
  options?: UseQueryOptions<ResultTypeFrom<D>>
) => UseQueryResult<ResultTypeFrom<D>>;

type CustomUseLazyQuery<D extends QueryDefinition<QueryArgFrom<D>, SiteBaseEndpoint, 'Root', ResultTypeFrom<D>, 'api'>> = (
  options?: UseLazyQueryOptions<ResultTypeFrom<D>>
) => [
  LazyQueryTrigger<D>, 
  UseLazyQueryResult<ResultTypeFrom<D>>, 
  UseLazyQueryLastPromiseInfo<D>
];

type CustomUseMutation<D extends MutationDefinition<QueryArgFrom<D>, SiteBaseEndpoint, 'Root', ResultTypeFrom<D>, 'api'>> = (
  options?: UseMutationStateOptions<ResultTypeFrom<D>>
) => [
  MutationTrigger<D>, 
  UseMutationResult<ResultTypeFrom<D>>
];

type QueryKeys<T> = {
  [K in keyof T]: T[K] extends { kind: EndpointType.QUERY }
  ? `use${Capitalize<string & K>}Query`
  : never;
}[keyof T];

type LazyQueryKeys<T> = {
  [K in keyof T]: T[K] extends { kind: EndpointType.QUERY }
  ? `useLazy${Capitalize<string & K>}Query`
  : never;
}[keyof T];

type MutationKeys<T> = {
  [K in keyof T]: T[K] extends { kind: EndpointType.MUTATION }
  ? `use${Capitalize<string & K>}Mutation`
  : never;
}[keyof T];

type EndpointInfo<T> = {
  [K in QueryKeys<T>]: K extends `use${infer U}Query`
  ? Uncapitalize<U> extends keyof T ? UseQuery<
    SiteQuery<
      ReplaceVoid<Extract<T[Uncapitalize<U>], { queryArg: unknown }>['queryArg']>,
      ReplaceVoid<Extract<T[Uncapitalize<U>], { resultType: unknown }>['resultType']>
    >
  > : never
  : never;
} & {
    [K in LazyQueryKeys<T>]: K extends `useLazy${infer U}Query`
    ? Uncapitalize<U> extends keyof T ? UseLazyQuery<
      SiteQuery<
        ReplaceVoid<Extract<T[Uncapitalize<U>], { queryArg: unknown }>['queryArg']>,
        ReplaceVoid<Extract<T[Uncapitalize<U>], { resultType: unknown }>['resultType']>
      >
    > : never
    : never;
  } & {
    [K in MutationKeys<T>]: K extends `use${infer U}Mutation`
    ? Uncapitalize<U> extends keyof T ? UseMutation<
      SiteMutation<
        ReplaceVoid<Extract<T[Uncapitalize<U>], { queryArg: unknown }>['queryArg']>,
        ReplaceVoid<Extract<T[Uncapitalize<U>], { resultType: unknown }>['resultType']>
      >
    > : never
    : never;
  };

type EndpointQuery<T> = (args: T) => string | { url: string; method: string; body: T };

// Store Hooks
export const sh = createApi({
  baseQuery: getQueryAuth,
  endpoints: builder => Object.keys(siteApiRef).reduce((m, endpointName) => {
    const endpointKey = endpointName as keyof SiteApiRef;
    type BuiltEndpoint = typeof siteApiRef[typeof endpointKey];

    const ep = siteApiRef[endpointName as keyof SiteApiRef] as BuiltEndpoint;
    const { method, queryArg, resultType, kind, url } = ep;

    type EPQueryArg = typeof queryArg;
    type EPResultType = typeof resultType;

    const builderPayload: {
      query: EndpointQuery<EPQueryArg>;
    } = {
      query: ((args: EPQueryArg) => {
        const processedUrl = url.replace(/:(\w+)/g, (_, key) => args[key as keyof EPQueryArg]);
        if (kind === EndpointType.QUERY) {
          return processedUrl;
        }
        return { url: processedUrl, method, body: args };
      })
    };

    return {
      ...m,
      [endpointName]: kind === EndpointType.QUERY ?
        builder.query<EPResultType, EPQueryArg>(builderPayload) :
        builder.mutation<EPResultType, EPQueryArg>(builderPayload),
    };
  }, {})
}) as RemoveNever<EndpointInfo<SiteApiRef>> & ReturnType<typeof createApi>;

console.log({ loadedup: Object.keys(sh) })

export const utilSlice = createSlice(utilConfig);

export const store = configureStore({
  reducer: {
    [sh.reducerPath]: sh.reducer as Reducer,
    util: utilSlice.reducer
  },
  middleware: getDefaultMiddleware => getDefaultMiddleware().concat(
    sh.middleware as Middleware,
    createDebounce(),
    thunk,
    logger
  )
});

setupListeners(store.dispatch);

export type AppDispatch = typeof store.dispatch;

export const useAppDispatch: () => AppDispatch = useDispatch;


export interface RootState extends ReturnType<typeof store.getState> { }

export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

export type ThunkStore = Store<RootState, AnyAction> & {
  dispatch: ThunkDispatch<RootState, undefined, AnyAction>;
}

declare global {
  interface IProps {
    store?: ThunkStore;
  }
}

export default {};

###
// keycloak.ts
import Keycloak from 'keycloak-js';

const {
  REACT_APP_KC_REALM,
  REACT_APP_KC_CLIENT,
  REACT_APP_KC_PATH
} = process.env as { [prop: string]: string };

const keycloak = new Keycloak({
  url: REACT_APP_KC_PATH,
  realm: REACT_APP_KC_REALM,
  clientId: REACT_APP_KC_CLIENT
});

export function initKeycloak(this: { cb: () => void }): void {

  const token = localStorage.getItem('kc_token') as string;
  const refreshToken = localStorage.getItem('kc_refreshToken') as string;

  void keycloak.init({
    onLoad: 'login-required',
    checkLoginIframe: false,
    token,
    refreshToken
  }).then(async (authenticated) => {
    setInterval(() => void keycloak.updateToken(58), 58 * 1000);
    if (authenticated) {
      localStorage.setItem('kc_token', keycloak.token as string);
      localStorage.setItem('kc_refreshToken', keycloak.refreshToken as string);

      await fetch('/api/auth/checkin', {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${keycloak.token as string}`
        }
      });

      this.cb();
    }
  }).catch((err) => {
    console.log({ err: err as string })
  })

}

export default keycloak;

###
// index.tsx

import 'typeface-roboto';

import React, { ReactNode } from 'react';
import { createRoot } from 'react-dom/client';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';

import { Theme } from '@mui/material/styles/createTheme';

import dayjs from 'dayjs';
import duration from 'dayjs/plugin/duration';
import relativeTime from 'dayjs/plugin/relativeTime';
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';

import 'dayjs/locale/en';

import { store } from 'awayto/hooks';

import reportWebVitals from './reportWebVitals';
import { initKeycloak } from './keycloak';

import './App.css';

import App from './App';

dayjs.extend(duration);
dayjs.extend(relativeTime);
dayjs.extend(utc);
dayjs.extend(timezone);

declare global {

  interface IProps {
    children?: ReactNode;
    loading?: boolean;
    closeModal?(): void;
    theme?: Theme;
  }
}

void initKeycloak.call({
  cb: function () {

    try {
      const root = createRoot(document.getElementById('root') as Element);
      root.render(
        <Provider store={store}>
            {/* <PersistGate persistor={persistor}> */}
              <BrowserRouter basename="/app">
                <App />
              </BrowserRouter>
            {/* </PersistGate> */}
          </Provider>
      )
      reportWebVitals(console.log);
    } catch (error) {
      console.log('the final error', error)
    }

  }
});

###
// useComponents.tsx
import { ComponentType, FunctionComponent, ReactNode, LazyExoticComponent, createElement, useMemo, lazy } from 'react';
import { useParams } from 'react-router';

import { hasGroupRole, SiteRoles } from 'awayto/core';

export type IBaseComponent = FunctionComponent<IProps> & ComponentType<any> & ReactNode;

export type IBaseComponents = { [component: string]: LazyExoticComponent<IBaseComponent> | (() => JSX.Element) }

import buildOutput from '../build.json';
import rolesOutput from '../roles.json';
import { sh } from './store';

const { views } = buildOutput as Record<string, Record<string, string>>;
const { roles } = rolesOutput as {
  roles: {
    [prop: string]: SiteRoles[]
  }
};

const components = {} as IBaseComponents;
export function useComponents(): IBaseComponents {
  const { data: profile } = sh.useGetUserProfileDetailsQuery();

  const { groupName } = useParams();

  const comps = useMemo(() => {
    return new Proxy(components, {
      get: function (target: IBaseComponents, prop: string): LazyExoticComponent<IBaseComponent> | (() => JSX.Element) {

        if (!profile) {
          return () => createElement('div');
        }

        const compPath = views[prop];

        if (groupName && roles[compPath]?.length && !hasGroupRole(groupName, profile.availableUserGroupRoles, roles[compPath] )) {
          components[prop] = ((): JSX.Element => createElement('div'));
        }
      
        if (!components[prop]) components[prop] = lazy<IBaseComponent>(() => import(`../${views[prop]}`) as Promise<{ default: IBaseComponent }>);

        target[prop] = views[prop] ? components[prop] : ((): JSX.Element => createElement('div'));

        return Reflect.get(target, prop);
      }
    });
  }, [profile, groupName]);

  return comps;
}

###
// app.tsx
import React, { useEffect, useState, Suspense } from 'react';
import keycloak from './keycloak';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';

import Box from '@mui/material/Box';
import Snackbar from '@mui/material/Snackbar';
import Backdrop from '@mui/material/Backdrop';
import Grid from '@mui/material/Grid';
import Typography from '@mui/material/Typography';
import CircularProgress from '@mui/material/CircularProgress';
import MuiAlert, { AlertProps } from '@mui/material/Alert';
import ThemeProvider from '@mui/material/styles/ThemeProvider';
import deepmerge from '@mui/utils/deepmerge';
import createTheme from '@mui/material/styles/createTheme';
import useMediaQuery from '@mui/material/useMediaQuery';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';

import { getBaseComponents, getDesignTokens, getThemedComponents } from './hooks/useStyles';
import { SiteRoles } from 'awayto/core';
import { useUtil, sh, useAppSelector, useComponents } from 'awayto/hooks';

import './App.css';

import Layout from './modules/common/Layout';

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(function Alert(
  props,
  ref,
) {
  return <MuiAlert elevation={6} ref={ref} variant="filled" {...props} />;
});

const {
  REACT_APP_KC_CLIENT
} = process.env as { [prop: string]: string };

export default function App (props: IProps): JSX.Element {
  const { setSnack } = useUtil();
  const { Onboard, ConfirmAction } = useComponents();
  const { theme, snackOn, snackType, snackRequestId, isLoading, loadingMessage } = useAppSelector(state => state.util);
  const { data: profile, refetch } = sh.useGetUserProfileDetailsQuery();
  
  const [ready, setReady] = useState(false);
  const [onboarding, setOnboarding] = useState(false);

  const defaultTheme = useMediaQuery('(prefers-color-scheme: dark)') ? 'dark' : 'light';
  const currentTheme = React.useMemo(() => createTheme(deepmerge(deepmerge(getDesignTokens(theme || defaultTheme), getThemedComponents(theme || defaultTheme)), getBaseComponents())), [theme]);

  useEffect(() => {
    const interval: NodeJS.Timeout = setInterval(() => {
      const resources = keycloak.tokenParsed?.resource_access;
      if (resources && resources[REACT_APP_KC_CLIENT]?.roles.includes(SiteRoles.APP_ROLE_CALL)) {
        void refetch();
      }
    }, 58 * 1000);

    return () => {
      clearInterval(interval);
    }
  }, []);

  useEffect(() => {
    if (profile) {
      if (Object.keys(profile.groups || {}).length) {
        setReady(true);
      } else {
        setOnboarding(true)
      }
    }
  }, [profile]);

  const hideSnack = (): void => {
    setSnack({ snackOn: '', snackRequestId: '' })
  }

  return <>
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <ThemeProvider theme={currentTheme}>
        {onboarding && <Suspense>
          <Onboard {...props} />
        </Suspense>}
        {ready && <Layout {...props} />}
        {!!snackOn && <Snackbar anchorOrigin={{ vertical: 'top', horizontal: 'center' }} open={!!snackOn} autoHideDuration={15000} onClose={hideSnack}>
          <Alert onClose={hideSnack} severity={snackType || "info"}>
            <Box>{snackOn}</Box>
            <Box><sub>{snackRequestId}</sub></Box>
          </Alert>
        </Snackbar>}

        <Suspense fallback="">
          <ConfirmAction {...props} />
        </Suspense>

        {!!isLoading && <Backdrop sx={{ zIndex: 9999, color: '#fff' }} open={!!isLoading}>
          <Grid container direction="column" alignItems="center">
            <CircularProgress color="inherit" />
            {loadingMessage && <Box m={4}>
              <Typography variant="caption">{loadingMessage}</Typography>
            </Box>}
          </Grid>
        </Backdrop>}
      </ThemeProvider>
    </LocalizationProvider>
  </>
}

###
// Layout.tsx

import React, { Suspense } from 'react';
import { Route, Routes } from 'react-router-dom';
import Grid from '@mui/material/Unstable_Grid2';

import CssBaseline from '@mui/material/CssBaseline';

import { useComponents } from 'awayto/hooks';

import Home from './Home';
import Topbar from './Topbar';
import Sidebar from './Sidebar';

const Layout = (props: IProps): JSX.Element => {

  const { Exchange, ExchangeProvider, Profile, GroupPaths, ServiceHome, ScheduleHome, RequestQuote } = useComponents();

  return <>
    <CssBaseline />

    <Grid container direction="row">
      <Grid  width={175} sx={{ bgcolor: 'primary.dark', position: 'fixed', minWidth: '175px', display: { xs: 'none', md: 'flex' } }}>
        <Sidebar />
      </Grid>
      <Grid xs={12} container direction="column" sx={{ marginLeft: { xs: 0, md: '175px' } }}>
        <Grid px={1} sx={{ bgcolor: 'primary.dark' }}>
          <Topbar {...props} />
        </Grid>
        <Grid p={2} width="100%">
          <Routes>
            <Route path="/" element={<Suspense fallback={<></>}><Home {...props} /></Suspense>} />
            <Route path="/profile" element={<Suspense fallback={<></>}><Profile {...props} /></Suspense>} />
            <Route path="/service" element={<Suspense fallback={<></>}><ServiceHome {...props} /></Suspense>} />
            <Route path="/quote/request" element={<Suspense fallback={<></>}><RequestQuote {...props} /></Suspense>} />
            <Route path="/schedule" element={<Suspense fallback={<></>}><ScheduleHome {...props} /></Suspense>} />
            <Route path="/group/:groupName/*" element={<Suspense fallback={<></>}><GroupPaths {...props} /></Suspense>} />
            <Route path="/exchange" element={
              <Suspense fallback={<></>}>
                <ExchangeProvider>
                  <Exchange {...props} />
                </ExchangeProvider>
              </Suspense>
            } />
          </Routes>
        </Grid>
      </Grid>
    </Grid>
  </>
}

export default Layout;

###
// ManageFeedbacks.tsx

import React from 'react';
import dayjs from 'dayjs';

import { useGrid, sh } from 'awayto/hooks';
import { useParams } from 'react-router';

export function ManageFeedbacks(): JSX.Element {

  const { groupName } = useParams();
  if (!groupName) return <></>;
  
  const { data: feedbacks } = sh.useGetGroupFeedbackQuery({ groupName });

  const FeedbackGrid = useGrid({
    rows: feedbacks || [],
    columns: [
      { flex: 1, headerName: 'User', field: 'username' },
      { flex: 1, headerName: 'Message', field: 'message' },
      { flex: 1, headerName: 'Created', field: 'createdOn', renderCell: ({ row }) => dayjs(row.createdOn).format("YYYY-MM-DD hh:mm a") }
    ]
  });

  return <FeedbackGrid />
}

export default ManageFeedbacks;
