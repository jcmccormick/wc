

const localId = btoa(`${navigator.userAgent.toLowerCase()}-${(new Date).getTime()}`).slice(-8, -1);
let socket;
let localStream;
let senderStreams = {};
var peerConnectionConfig = {
  'iceServers': [
    { urls: 'turn:192.168.1.53:3478', credential: 'test123', username: 'test' },
    // { 'urls': 'stun:stun.stunprotocol.org:3478' },
    // { 'urls': 'stun:stun.l.google.com:19302' },
  ]
};

const form = document.getElementById('form');
const messageInput = document.getElementById('message');
const messages = document.getElementById('messages');
const videos = document.getElementById('videos');

// Join the video call
const startSharingForm = document.getElementById('start-video');
startSharingForm.addEventListener('submit', function (event) {
  event.preventDefault();
  !localStream && socket && startSharing();
});

async function startSharing(responding = false) {
  let share = !responding;

  if (responding) {
    share = await confirm('Do you want to join the video call?');
  }

  if (!share) return;

  localStream = await navigator.mediaDevices.getUserMedia({
    video: {
      width: { max: 320 },
      height: { max: 240 },
      frameRate: { max: 30 }
    },
    audio: {
      autoGainControl: true
    }
  });

  if (localStream) {
    document.getElementById('local-video').srcObject = localStream
    if (!responding && socket) {
      socket.send(JSON.stringify({
        sender: localId,
        type: 'join-call',
        rtc: true
      }))
    }
  }

}

// Leave the video call
const stopSharingForm = document.getElementById('stop-video');
stopSharingForm.addEventListener('submit', function (event) {
  event.preventDefault();
  localStream && socket && stopSharing();
});

function stopSharing() {
  document.getElementById('local-video').srcObject = undefined;
  localStream.getTracks().forEach(t => t.stop());
  localStream = undefined;
  Object.keys(senderStreams).forEach(function (sender) {
    document.getElementById(`${sender}_sender_video`).remove();
    senderStreams[sender].pc.close();
  })
}

function hb() {
  console.log('pinged');
  clearTimeout(this.pingTimeout);
  this.pingTimeout = setTimeout(function () {
    console.log('server didn\'t ping');
  }, 30000 + 1000);
}

async function bootstrap() {
  const ticket = await fetch(`https://${location.hostname}/api/ticket/`, {
    method: 'POST',
    body: JSON.stringify({
      localId
    }),
    headers: {
      Authorization: 'Bearer blah'
    }
  });

  console.log(await ticket.text());

  socket = new WebSocket(`wss://${location.hostname}/sock/${localId}`);

  window.addEventListener('unload', function () {
    if (socket.readyState === WebSocket.OPEN) socket.close();
  });

  // Send text messages
  form.addEventListener('submit', function (event) {
    event.preventDefault();
    socket.send(JSON.stringify({
      sender: localId,
      type: 'text',
      message: messageInput.value
    }));
    messageInput.value = '';
  });

  socket.addEventListener('error', console.log);
  socket.addEventListener('open', hb);
  socket.addEventListener('ping', hb);
  socket.addEventListener('close', function () {
    console.log('closed connection.');
    clearTimeout(this.pingTimeout);
  });

  socket.addEventListener('message', async function (sockMsg) {
    const { sender, type, target, sdp, ice, message, rtc, status } = JSON.parse(await sockMsg.data.text());

    if (sender === localId || (target !== localId && !(rtc || sdp || ice))) return;

    if ('text' === type) {
      const newMessage = document.createElement('div');
      newMessage.innerHTML = `${sender}- ${message}`;
      messages.append(newMessage);
    } else if ('join-call' === type) {
      // if (!localStream) {
      //   await startSharing(true);
      // }
    
      // if (!localStream) return;

      // Parties to an incoming caller will see this, and then notify the caller that they exist in return
      await generatePeerConnection(sender);
      socket.send(JSON.stringify({
        sender: localId,
        target: sender,
        type: 'peer-response',
        rtc: true
      }));
    } else if ('peer-response' === type) {
      // The caller gets a party member's response, and sets them up in return
      await generatePeerConnection(sender, true);
    } else if (sdp) {
      await senderStreams[sender].pc.setRemoteDescription(new RTCSessionDescription(sdp));
      if ('offer' === sdp.type) {
        const description = await senderStreams[sender].pc.createAnswer();
        await createdDescription(description, sender);
      }
    } else if (ice) {
      await senderStreams[sender].pc.addIceCandidate(new RTCIceCandidate(ice));
    }
  });
}

async function generatePeerConnection(sender, initCall = false) {
  const rtcPeer = new RTCPeerConnection(peerConnectionConfig)
  rtcPeer.onicecandidate = event => gotIceCandidate(event, sender);
  rtcPeer.ontrack = event => gotRemoteStream(event, sender);
  rtcPeer.oniceconnectionstatechange = event => checkPeerDisconnect(event, sender);
  if (localStream) {
    const tracks = localStream.getTracks();
    tracks.forEach(track => rtcPeer.addTrack(track));
  }

  senderStreams[sender] = {
    pc: rtcPeer
  };

  if (initCall) {
    const description = await senderStreams[sender].pc.createOffer();
    await createdDescription(description, sender);
  }
}

async function createdDescription(description, sender) {
  await senderStreams[sender].pc.setLocalDescription(description)
  socket.send(JSON.stringify({
    sdp: senderStreams[sender].pc.localDescription,
    sender: localId,
    target: sender,
    rtc: true
  }));
}

function gotIceCandidate(event, sender) {
  if (event.candidate !== null) {
    socket.send(JSON.stringify({
      ice: event.candidate,
      sender: localId,
      target: sender,
      rtc: true
    }));
  }
}

function gotRemoteStream(event, sender) {

  if (!senderStreams[sender].mediaStream) {
    document.getElementById(`${sender}_sender_video`)?.remove();

    senderStreams[sender].mediaStream = new MediaStream();

    var video = document.createElement('video');
    video.id = `${sender}_sender_video`;
    video.setAttribute('autoplay', '');
    video.setAttribute('controls', '');
    video.style = 'float:left;'
    video.srcObject = senderStreams[sender].mediaStream;
    document.getElementById('videos').appendChild(video);
  }

  senderStreams[sender].mediaStream.addTrack(event.track);
}

function checkPeerDisconnect(event, sender) {
  var state = senderStreams[sender].pc.iceConnectionState;
  if (['failed', 'closed', 'disconnected'].includes(state)) {
    delete senderStreams[sender];
    document.getElementById('videos').removeChild(document.getElementById(`${sender}_sender_video`));
  }
}

bootstrap();